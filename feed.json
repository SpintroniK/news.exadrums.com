{
    "version": "https://jsonfeed.org/version/1",
    "title": "exadrums - news",
    "home_page_url": "https://news.exadrums.com/feed.json",
    "description": "eXaDrums project: latest news.",
    "items": [
        {
            "id": "https://news.exadrums.com/article/TD-4KP-configuration",
            "content_html": "\nYou might not now that you can export and import your exadrums configuration.\nThis is a simple feature, but it can be very useful to create backups of your drum kits, or share them.\nThe first eXaDrums triggers input board has been designed for the Roland TD-4KP.\nWouldn't be nice to save all the triggers settings, instruments sounds, etc. for this drum kit, so that anyone can play with the TD-4KP?\nHere's why I'm sharing the configuration I've been using for my tests on that drum kit: [https://github.com/SpintroniK/exadrums-data/tree/TD-4KP](https://github.com/SpintroniK/exadrums-data/tree/TD-4KP).\n\n<!--more-->\n\nIf you click on the link, you'll notice that there's a little Readme file to help you install the kit.\nIt's a very simple and quick operation.\n\nWith any luck, reading this post will make you want to export some of your kits.\nI think this is one of the steps that will add a social dimension to exadrums, so be prepared to see more things going in that direction in the future!\n",
            "url": "https://news.exadrums.com/article/TD-4KP-configuration",
            "title": "TD-4KP Configuration",
            "summary": "You might not now that you can export and import your exadrums configuration.\nThis is a simple feature, but it can be very useful to create backups of your drum kits, or share them.\nThe first eXaDrums triggers input board has been designed for the Roland TD-4KP.\nWouldn't be nice to save all the triggers settings, instruments sounds, etc. for this drum kit, so that anyone can play with the TD-4KP?\nHere's why I'm sharing the configuration I've been using for my tests on that drum kit: https://github.com/SpintroniK/exadrums-data/tree/TD-4KP.",
            "date_modified": "2021-09-27T20:26:32.000Z",
            "date_published": "2021-09-27T20:26:32.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/debian-bullseye",
            "content_html": "\nToday, Debian 11 (Bullseye), has been officially released. This is a great news for *exadrums*, as this means it is now available in Debian. If you're using Debian (or Ubuntu, Raspberry Pi OS, and some [other distros](https://repology.org/project/exadrums/packages)), you can install exadrums via `apt`, i.e.:\n\n```bash\nsudo apt install exadrums\n```\n<!--more-->\n\n## What does this mean?\n\nWell, if you have about 5 MB to spare, you can install exadrums from the command line directly.\nHere's what you see from a fresh Debian Bullseye install:\n\n![image](/images/debian-bullseye/Screenshot_2021-08-15_11-14-02.png)\n\nNo more compiling, etc. `apt` handles everything for you!\n\n## What about Raspberry Pi OS?\n\nIt's only been a few hours since Debian 11 has been released, so there's no news about the next Raspberry Pi OS (formerly Raspbian). Let's give them some time to publish a proper release.\nI can already tell you that you'll get the same version of exadrums as Debian in Raspberry Pi OS, it'll be exadrums 0.6.0.\n\nAnyhow, when the new Raspberry Pi OS will be released, you'll be able to install exadrums via `apt` on your Raspberry Pi.\n\n## Using Debian Bullseye on a Raspberry Pi\n\nIf you don't want to wait until the version of Raspberry Pi OS comes out, you can install Debian Bullseye on your Raspberry Pi using one of the images available at: [ Tested images](https://raspi.debian.net/tested-images/). I haven't tried any of them, but they've been tested, so they should work.",
            "url": "https://news.exadrums.com/article/debian-bullseye",
            "title": "Debian 11 - Bullseye",
            "summary": "Today, Debian 11 (Bullseye), has been officially released. This is a great news for exadrums, as this means it is now available in Debian. If you're using Debian (or Ubuntu, Raspberry Pi OS, and some other distros), you can install exadrums via apt, i.e.:\nsudo apt install exadrums\n",
            "date_modified": "2021-08-21T16:17:58.000Z",
            "date_published": "2021-08-14T12:08:07.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/exadrums-dot-com",
            "content_html": "\nThe official exadrums website, [exadrums.com](https://exadrums.com), is online.\nIt shows that there's more than a just software to exadrums.\nEven though it is more a landing page than a website, it gives valuable information about the project.\nAnd frankly, I'm quite proud of the video!\n\n<div class=\"columns\">\n    <div class=\"column has-text-centered is-centered\">\n        <video controls=\"\" playsinline loop style=\"max-width: 40%;\" poster=\"/images/exadrums-dot-com/hero_img.jpg\">\n            <source src=\"https://freewebmaster.fr/exadrums.com/assets/exadrums_hero_video.mp4\" type=\"video/mp4\">\n            <source src=\"https://freewebmaster.fr/exadrums.com/assets/exadrums_hero_video.webm\" type=\"video/webm\">\n            <source src=\"https://freewebmaster.fr/exadrums.com/assets/exadrums_hero_video.ogv\" type=\"video/ogg\"> \n            Your browser does not support the video tag.\n        </video>\n    </div>\n</div>\n\n<!--more-->\n\nThe website's goal is also to explain how to build an exadrums module.\nBuilding the whole module (which is currently designed to work with the Roland TD4-KP), requires three main steps:\n\n- To install the software on a Raspberry Pi\n- To make the trigger input board.\n- To 3D-print the enclosure.\n\nJust so you know, you don't have to go through each step, as you can already play a fair bit with the software even on your PC or laptop.\n\nThere is also this _Make your Own_ button, which redirects to another web page that is currently under construction.\nThis page will be a custom user guide generator.\n\nThe idea is that everyone wants something different (or have a different drum set configuration), so it makes sense to have a custom user guide.\nI'll keep you informed about the progress I make on that page.\nIt should be available in a few weeks, or a few months.\nI'm not in a rush, as my goal is to make the best user guide possible.\n",
            "url": "https://news.exadrums.com/article/exadrums-dot-com",
            "title": "Exadrums.com",
            "summary": "The official exadrums website, exadrums.com, is online.\nIt shows that there's more than a just software to exadrums.\nEven though it is more a landing page than a website, it gives valuable information about the project.\nAnd frankly, I'm quite proud of the video!\n\n    \n        \n            \n            \n             \n            Your browser does not support the video tag.\n        \n    \n",
            "date_modified": "2021-09-01T17:04:20.000Z",
            "date_published": "2021-09-01T17:04:20.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/how-to-make-a-drum-module",
            "content_html": "\nOver the past few years, I've worked on improving exadrums to make it as complete as possible.\nHowever, before that, I spent a lot of time making sure the software and hardware would meet some very specific requirements.\nOn the software side, the latency had to be below 10ms, and the sound quality at least as good as our dear old compact discs.\nAnd on the hardware side, the trigger input board had to preserve the piezos' dynamics, and be compatible with most edrums out there.\nAchieving all of this wasn't an easy task, and took about three years, from September 2015 to September 2018.\n\nMoreover, exadrums had to be a *modern* and accessible drum module. Which is why it is based on the Raspberry Pi (2+) and uses a 7\" touchscreen. So, September 2018 was the confirmation that all those targets were reached, and it was time to write down how all these things came together.\n\n<!--more-->\n\n## How to Make it Work as Expected?\n\nAbout three years ago, I wrote a short article that describes how and why I defined the software and hardware requirements, but also how I managed to make everything work as expected. I'll go into a bit more details below, but you can skip that part if you're in a hurry, and go straight to the article.\n\n## Making a Modern Drum Module\n\nMaking a modern drum module means breaking the rules. Nearly a hundred percent of the existing drum modules use a microcontroller to leverage their real-time properties. However, that means that the amount of memory is often limited, and the user interface is rudimentary (buttons, sliders, etc.), and can't evolve without modifying the hardware.\n\nBy choosing the Raspberry Pi, I made it possible to have a modern user interface, using a touchscreen, but I lost all the real-time goodness that microcontrollers have to offer.\nFortunately, there was a solution to reduce the latency with a Raspberry Pi.\nUnsurprisingly, getting more performance means going low-level, but also getting a good soundcard.\nThe soundcard latency represents a third of the total latency.\nThe software adds another third, and the last third is the trigger scan time.\n\n## Making a Trigger Input Board\n\nMaking a trigger input board, is not overly complicated. But there are still two big challenges:\n\n- Make sure all the components fit on the board.\n- Find a way to make the board compatible with all the drum pads out there.\n\nThe first challenge is not too hard, thanks to SMD components. Especially for a 8-input board. That'll be a bit more difficult with 16 inputs...\nAs for making the board compatible with all the drum pads, I decided to connect potentiometers to the piezos, so that their output voltage can be scaled down if necessary. That avoids the biggest problem: clipping!\n\n## How to Make a Modern Drum Module\n\nNow that you've got the context, maybe you'd like to read the article, so here it is.\nIf for some reason your web browser doesn't show the pdf, here's a link to it: <a href=\"/docs/how-to-make-a-drum-module/HTMADM.pdf\" target=\"_blank\">How to Make a Modern Drum Module</a>.\n<object data=\"/docs/how-to-make-a-drum-module/HTMADM.pdf\" type=\"application/pdf\" style=\"width: 100%; height: 100vh\"></object>\n",
            "url": "https://news.exadrums.com/article/how-to-make-a-drum-module",
            "title": "How to Make a Modern Drum Module",
            "summary": "Over the past few years, I've worked on improving exadrums to make it as complete as possible.\nHowever, before that, I spent a lot of time making sure the software and hardware would meet some very specific requirements.\nOn the software side, the latency had to be below 10ms, and the sound quality at least as good as our dear old compact discs.\nAnd on the hardware side, the trigger input board had to preserve the piezos' dynamics, and be compatible with most edrums out there.\nAchieving all of this wasn't an easy task, and took about three years, from September 2015 to September 2018.\nMoreover, exadrums had to be a modern and accessible drum module. Which is why it is based on the Raspberry Pi (2+) and uses a 7\" touchscreen. So, September 2018 was the confirmation that all those targets were reached, and it was time to write down how all these things came together.",
            "date_modified": "2021-10-02T06:27:36.000Z",
            "date_published": "2021-10-02T06:27:36.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/libexadrums-js",
            "content_html": "\nAchieving low latency and performance for exadrums was possible thanks to the C++ programming language.\nC++ is a great language because it offers both low- and high-level programming styles, but I find it a bit limited when it comes to user interfaces.\nOn the other hand, javascript isn't the best language for performance, but or user interfaces it really shines, thanks to its integration with html and css.\n\nBut can we get a nice and responsive html + css + js user interface, and get the C++ performance?\nThat's what [libexadrums.js](https://github.com/SpintroniK/libexadrums.js) does.\nIt is basically javascript a wrapper of the exadrums C++ library (libexadrums).\nUsing the Node-API interface, (lib)exadrums can be used in any nodejs project, with almost no performance loss.\nIt is a node package that [brings libexadrums to the nodejs world](https://news.exadrums.com/article/the-future-of-exadrums), and you can find it here: https://www.npmjs.com/package/@exadrums/libexadrums.js.\n\n<!--more-->\n\n## How it works\n\nThe way libexadrums.js works is very simple, it is just a javascript wrapper around the original C++ library.\nEvery function call is translated from javascript to a C++ function call.\n\nSo when you start your drum module, a javascript function calls the C++ start function, which in turns starts the module.\nBut the cool thing is, once the module has started, it runs the native compiled C++ program, so there's no performance hit whatsoever.\nThat way, you do get the best of both worlds.\n\n## What's next?\n\nSo far, libexadrums.js is not complete, some functions are missing, and it will take some time to add them.\nBut the main goal is to make a better user interface.\nThe plan is to develop an [electron](https://www.electronjs.org/) application, that will become an alternative to the native C++ interface.\nI don't think it will replace it, but it'll be used by people who want a more connected experience.\n\nImagine a user interface than leverages CSS transitions, animations, together with [vuejs](https://vuejs.org/), and javascript's fetch api. I think that can make the development easier, and faster. And hopefully drummers that use exadrums will highly benefit from that!\n",
            "url": "https://news.exadrums.com/article/libexadrums-js",
            "title": "libexadrums.js",
            "summary": "Achieving low latency and performance for exadrums was possible thanks to the C++ programming language.\nC++ is a great language because it offers both low- and high-level programming styles, but I find it a bit limited when it comes to user interfaces.\nOn the other hand, javascript isn't the best language for performance, but or user interfaces it really shines, thanks to its integration with html and css.\nBut can we get a nice and responsive html + css + js user interface, and get the C++ performance?\nThat's what libexadrums.js does.\nIt is basically javascript a wrapper of the exadrums C++ library (libexadrums).\nUsing the Node-API interface, (lib)exadrums can be used in any nodejs project, with almost no performance loss.\nIt is a node package that brings libexadrums to the nodejs world, and you can find it here: https://www.npmjs.com/package/@exadrums/libexadrums.js.",
            "date_modified": "2021-10-16T13:26:21.000Z",
            "date_published": "2021-10-16T13:26:21.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/new-arduino-nano-every-board-part2",
            "content_html": "\nThis is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 1](/article/new-arduino-nano-every-board-part1).\nIn this part, I'm going to describe how to compile C++ code and upload it to the Arduino Nano Every without using the Arduino library.\n\nBut why would one want to do that, you may ask?\nThe answer is simple: the Arduino library does a lot of things that may impact performance.\nFor instance, some interrupts are being fired frequently, and slow things down.\n\nLet's be honest, we're not going to reinvent the wheel, most of what we are going to do here is to use the Arduino IDE's compiler and tools.\nSay we install the Arduino IDE (version 1.8.9) and compile a program.\nHere's what we're going to see:\n\n![image](/images/new-arduino-nano-every-board/arduino-ide.png)\n\nThe interesting part is the console, where all the compilation-related messages are shown.\nWe see that the IDE uses avr-gcc version 7.3.0, along with a few other tools.\nLet's see what we can do with that.\n\n<!--more-->\n\nFirst of all, we can see *where* all these tools are located.\nA little digging reveals that an environment variable named *AVR_TOOLS_DIR* contains the tools folder location.\nThus, we can type the following: `$AVR_TOOLS_DIR/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin/avr-gcc --version` and execute the command in a terminal.\nThis will print the avr-gcc version.\n\n## Makefile for the Arduino Nano Every\n\nThis is not a tutorial about makefiles, if you want an in-depth tutorial about makefiles, please read the official [GNU Make Manual](https://www.gnu.org/software/make/manual/).\nWith that out of the way, let's write a makefile.\n\n### Variables\n\nFirst of all, we need to define some variables.\nHaving the avr-gcc bin directory as variable seems like a good idea, so we define the following: `BIN_DIR?=${AVR_TOOLS_DIR}/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin`.\nYour bin directory may differ, so be sure to check its correct location.\nThat's the only variable we'll need for the compiling process.\n\nThere's one more thing that we need in order to upload the compiled program to the Arduino, though.\nThis thing is avrdude.\nIt's a little bit trickier, as we need the avrdude executable and a configuration file.\nSo here are our variables:\n\n```makefile\nAVRDUDE_DIR?=${AVR_TOOLS_DIR}/avrdude/6.3.0-arduino17/\nAVRDUDE?=${AVRDUDE_DIR}/bin/avrdude\nCONFDIR?=${AVRDUDE_DIR}/etc/avrdude.conf\n```\n\nAgain, be sure to check the the executable path.\nIf you want to provide your own configuration file, you can use the following (sorry, it isn't a short snippet...):\n\n```ini\n\n#------------------------------------------------------------\n# AVR8X family common values\n#------------------------------------------------------------\n\npart\n    id        = \".avr8x\";\n    desc    = \"AVR8X family common values\";\n    has_updi    = yes;\n    nvm_base    = 0x1000;\n    ocd_base    = 0x0F80;\n\n    memory \"signature\"\n        size        = 3;\n        offset        = 0x1100;\n    ;\n\n    memory \"prodsig\"\n        size        = 0x3D;\n        offset        = 0x1103;\n        page_size    = 0x3D;\n        readsize    = 0x3D;\n    ;\n\n    memory \"fuses\"\n        size        = 9;\n        offset        = 0x1280;\n    ;\n\n    memory \"fuse0\"\n        size        = 1;\n        offset        = 0x1280;\n    ;\n\n    memory \"fuse1\"\n        size        = 1;\n        offset        = 0x1281;\n    ;\n\n    memory \"fuse2\"\n        size        = 1;\n        offset        = 0x1282;\n    ;\n\n    memory \"fuse4\"\n        size        = 1;\n        offset        = 0x1284;\n    ;\n\n    memory \"fuse5\"\n        size        = 1;\n        offset        = 0x1285;\n    ;\n\n    memory \"fuse6\"\n        size        = 1;\n        offset        = 0x1286;\n    ;\n\n    memory \"fuse7\"\n        size        = 1;\n        offset        = 0x1287;\n    ;\n\n    memory \"fuse8\"\n        size        = 1;\n        offset        = 0x1288;\n    ;\n\n    memory \"lock\"\n        size        = 1;\n        offset        = 0x128a;\n    ;\n\n    memory \"data\"\n        # SRAM, only used to supply the offset\n        offset        = 0x1000000;\n    ;\n;\n\n\n#------------------------------------------------------------\n# AVR8X mega family common values\n#------------------------------------------------------------\n\npart parent    \".avr8x\"\n    id            = \".avr8x_mega\";\n    desc        = \"AVR8X mega family common values\";\n    family_id    = \"megaAVR\";\n\n    memory \"usersig\"\n        size        = 0x40;\n        offset        = 0x1300;\n        page_size    = 0x40;\n        readsize    = 0x100;\n    ;\n;\n\n#------------------------------------------------------------\n# ATmega4809\n#------------------------------------------------------------\n\npart parent    \".avr8x_mega\"\n    id        = \"m4809\";\n    desc      = \"ATmega4809\";\n    signature = 0x1E 0x96 0x51;\n\n    memory \"flash\"\n        size      = 0xC000;\n        offset    = 0x4000;\n        page_size = 0x80;\n        readsize  = 0x100;\n    ;\n\n    memory \"eeprom\"\n        size      = 0x100;\n        offset    = 0x1400;\n        page_size = 0x40;\n        readsize  = 0x100;\n    ;\n;\n\nprogrammer\n  id    = \"jtag2updi\";\n  desc  = \"JTAGv2 to UPDI bridge\";\n  type  = \"jtagmkii_pdi\";\n  connection_type = serial;\n  baudrate = 115200;\n;\n\n```\n\nAnd the last variable that we need is the Arduino serial port: `PORT?=/dev/ttyACM0`.\nYou can find that information in the Arduino IDE (in the *tools* menu).\n\n### Rules\n\nNow that we have defined all the variables that we need, we have to create some rules to compile and upload our code to the Arduino.\nTo that end, we are going to have three rules: `all`, to compile the code, `upload`, to upload the binary to the board, and `clean` to remove all the build files.\n\nLet's start with the `all` rule:\n\n```makefile\nall:\n    ${BIN_DIR}/avr-g++ -c -g -Os -w -std=c++17 -fpermissive -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -Wno-error=narrowing -MMD -flto -mmcu=atmega4809 -DF_CPU=16000000L -DARDUINO=10809 -DARDUINO_AVR_NANO_EVERY main.cpp -o main.o\n    ${BIN_DIR}/avr-g++ -w -Os -g -flto -fuse-linker-plugin -Wl,--gc-sections -Wl,--section-start=.text=0x0 -mmcu=atmega4809 -o main.elf main.o\n    ${BIN_DIR}/avr-objcopy -O binary -R .eeprom main.elf main.bin\n    ${BIN_DIR}/avr-objcopy -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 main.elf main.eep\n    ${BIN_DIR}/avr-objcopy -O ihex -R .eeprom main.elf main.hex\n    ${BIN_DIR}/avr-size -C main.elf\n```\n\nThis mostly comes from the Arduino IDE's console output window.\nI've made only very small modifications.\nThe `upload` rule is also taken from the Arduino IDE:\n\n```makefile\nupload:\n    python3 ./reset.py ${PORT}\n    ${AVRDUDE} -C${CONFDIR} -v -patmega4809 -cjtag2updi -P${PORT} -b115200 -e -D -Uflash:w:main.hex:i -Ufuse2:w:0x01:m -Ufuse5:w:0xC9:m -Ufuse8:w:0x00:m\n```\n\nThere is one subtle thing here.\nIf we check the Arduino IDE's console output, we can read the following message: `Forcing reset using 1200 bps open/close on port /dev/ttyACM0`.\nThis means that we need to reset the Arduino before avrdude starts uploading the program.\nI found that the more reliable way to do that is to use a little python3 script:\n\n```python\n#!/usr/bin/python\n\nimport sys\nimport serial\n\ncom = serial.Serial(sys.argv[1], 1200)\ncom.dtr=False\ncom.close()\n```\n\nFinally, we need a `clean` rule that removes all the compiled files.\nThis is a pretty easy rule to write, so I'll just throw the whole makefile there:\n\n```makefile\nBIN_DIR?=${AVR_TOOLS_DIR}/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin\nAVRDUDE_DIR?=${AVR_TOOLS_DIR}/avrdude/6.3.0-arduino17/\nAVRDUDE?=${AVRDUDE_DIR}/bin/avrdude\nCONFDIR?=${AVRDUDE_DIR}/etc/avrdude.conf\n\nPORT?=/dev/ttyACM0\n\nall:\n    ${BIN_DIR}/avr-g++ -c -g -Os -w -std=c++17 -fpermissive -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -Wno-error=narrowing -MMD -flto -mmcu=atmega4809 -DF_CPU=16000000L -DARDUINO=10809 -DARDUINO_AVR_NANO_EVERY main.cpp -o main.o\n    ${BIN_DIR}/avr-g++ -w -Os -g -flto -fuse-linker-plugin -Wl,--gc-sections -Wl,--section-start=.text=0x0 -mmcu=atmega4809 -o main.elf main.o\n    ${BIN_DIR}/avr-objcopy -O binary -R .eeprom main.elf main.bin\n    ${BIN_DIR}/avr-objcopy -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 main.elf main.eep\n    ${BIN_DIR}/avr-objcopy -O ihex -R .eeprom main.elf main.hex\n    ${BIN_DIR}/avr-size -C main.elf\n\n\nupload:\n    python3 ./reset.py ${PORT}\n    ${AVRDUDE} -C${CONFDIR} -v -patmega4809 -cjtag2updi -P${PORT} -b115200 -e -D -Uflash:w:main.hex:i -Ufuse2:w:0x01:m -Ufuse5:w:0xC9:m -Ufuse8:w:0x00:m\n\n\nclean:\n    rm -f main.bin main.d main.eep main.elf main.hex main.o\n```\n\nThere we are, all that's left is to put this in a `Makefile`file.\nNow we can type `make` to compile the code and `make upload` to upload it to the board.\n\n## Example: Blink the On-board LED\n\nWe are going to go through a very simple example: the LED blink example.\n\n### Arduino Version\n\nHere's the Arduino code for the LED blink example:\n\n```cpp\nconst int ledPin = 13;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(ledPin, HIGH);   // set the LED on\n  delay(1000);                  // wait for a second\n  digitalWrite(ledPin, LOW);    // set the LED off\n  delay(1000);                  // wait for a second\n}\n```\n\nUsing the Arduino IDE to compile this code, we get the following message:\n\n```text\nSketch uses 1118 bytes (2%) of program storage space. Maximum is 49152 bytes.\nGlobal variables use 22 bytes (0%) of dynamic memory, leaving 6122 bytes for local variables. Maximum is 6144 bytes.\n```\n\nSo, in order to make a LED blink every second, we need 1118 bytes of program space, and 22 bytes of RAM.\nTo me, that sounds like a lot!\n\n### C Version\n\nNow let's go low-level and see what we can do without using the Arduino library.\nSince we're using a C++ compiler, it's not really C code, but it looks like it is:\n\n```cpp\n#include <avr/io.h>\n#include <util/delay.h>\n\nint main()\n{\n    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler\n\n    PORTE.DIRSET |= PIN2_bm;\n\n    for(;;)\n    {\n        _delay_ms(1000);\n        PORTE.OUTTGL |= PIN2_bm;\n    }\n\n    return 0;\n}\n```\n\nThe first line of the main function is used to disable the prescaler, which ensures that the CPU runs at the wanted 16MHz frequency.\nIf you check out the Arduino Nano Every connector pinouts, you'll see that the on-board LED is connected to `D13`.\nThis pin is also labeled `SCK` and `PE2`.\nThe latter tells us that this particular pin is wired to port E, pin 2.\nAnd that's all we need for our LED blink example.\nFirst we use the `DIRSET` register of port E to set the pin 2 bit, which will set pin 2 as an output.\nThen, in the main for loop, we write the pin 2 bit into the `OUTTGL` register, which toggles the state of pin 2.\nIn between each toggling, we use the `_delay_ms` function, which allows us to wait for a given time.\n\nThe ports registers and pins definitions are provided by the `avr/io.h` header which contains everything we need.\nBecause we passed the `-mmcu=atmega4809` flag to avr-gcc in our makefile, it knows that we are using an ATMega4809.\nThe `_delay_ms` function comes from `util/delay.h`, it needs to know the CPU clock frequency, which why we passed to avr-gcc using `-DF_CPU=16000000L`.\n\nThis program does the same thing as the previous one, except it uses a lot less memory and needs no RAM:\n\n```text\nAVR Memory Usage\n----------------\nDevice: Unknown\n\nProgram:     238 bytes\n(.text + .data + .bootloader)\n\nData:          0 bytes\n(.data + .bss + .noinit)\n```\n\n### C++ Version\n\nOkay, so I'm not a big fan of C, and I wonder if we could make this code more readable.\nI would like to be able to write something like `led.Toggle()` instead of `PORTE.OUTTGL |= PIN2_bm`.\n\nIn order to be as generic as possible, we are going to define a class that allows pin manipulation.\nOne more thing: I really don't like pointers, so we are going to try to avoid them at all cost.\n\nFirst of all, we need to know how `PORTE` is defined.\nIts definition lies in the `avr/include/avr/iom4809.h` file: `#define PORTE                (*(PORT_t *) 0x0480) /* I/O Ports */`, where `PORT_t` is a big struct with a bunch of `register_t` in it.\nFort instance, `OUTTGL` and `DIRSET` are in that struct.\nAnd here's where it gets kind of ugly: `typedef volatile uint8_t register8_t;`.\nEvery `register8_t` is declared as volatile, which makes sense because our LED blink wouldn't work otherwise (the compiler would optimize away the `PORTE.OUTTGL |= PIN2_bm` line).\n\nSo, the first thing that we need, is the address of `PORTE`.\nBecause of that `volatile` keyword, we can't use `constexpr` nor `static_cast`, so we are going to define it as: `static const auto PORTE_ADDR = reinterpret_cast<uint16_t>(&PORTE);`.\nNote that this is a 16-bit address\n\nNow we define a pin as a port and a pin number.\nIn our case: port E (its address) and pin 2 (its bit mask).\nThese two things are known at compile time, so we can use them as template parameters.\nHence, we are going to define a `Pin` class that take these two parameters as template parameters:\n\n```cpp\nnamespace DigitalIO\n{\n\n    static const auto PORTE_ADDR = reinterpret_cast<uint16_t>(&PORTE);\n\n    template <uint16_t portAddr, uint8_t mask>\n    class Pin\n    {\n    public:\n        Pin() = delete;\n        ~Pin() = delete;\n\n        static constexpr void ConfigureAsInput()\n        {\n            port().DIRSET &= ~mask;\n        }\n\n        static constexpr void ConfigureAsOutput()\n        {\n            port().DIRSET |= mask;\n        }\n\n        static constexpr void Toggle()\n        {\n            port().OUTTGL |= mask;\n        }\n\n        static constexpr void SetHigh()\n        {\n            port().OUTSET |= mask;\n        }\n\n        static constexpr void SetLow()\n        {\n            port().OUTCLR |= mask;\n        }\n\n        static constexpr auto& port()\n        {\n            return *reinterpret_cast<PORT_t*>(portAddr);\n        }\n        \n    private:\n\n    };\n    \n} // namespace IO\n```\n\nWe need to cast the port address back to a `PORT_t` struct, which is the role of the `port()` function.\nThe rest of the code is pretty straightforward, we encapsulate our C code into `static` methods.\n\nHere's how to use this code:\n\n```cpp\n#include \"DigitalIO.h\"\n\n#include <avr/io.h>\n#include <util/delay.h>\n\n#include <stdint.h>\n\nusing Led = DigitalIO::Pin<DigitalIO::PORTE_ADDR, PIN2_bm>;\n\nint main()\n{\n    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler\n\n    Led::ConfigureAsOutput();\n\n    for(;;)\n    {\n        _delay_ms(1000);\n        Led::Toggle();\n    }\n\n    return 0;\n}\n```\n\nIt looks almost the same as the previous code, except that it's a bit more readable.\n\nBut we did add quite a bit of boilerplate code in our `DigitalIO.h` file, is that a good idea?\nI believe it is. Right now, we don't see how this can be very useful because our program is small and basic.\nWith a bigger code base, I think it would be way easier to understand our code with a well-structured C++ program.\n\nBut wait a minute, isn't all that code going to add more bytes to our program?\nLet's check that, shall we?\n\n```text\nAVR Memory Usage\n----------------\nDevice: Unknown\n\nProgram:     238 bytes\n(.text + .data + .bootloader)\n\nData:          0 bytes\n(.data + .bss + .noinit)\n```\n\nIt doesn't. In fact the assembly code is exactly the same as the previous one.\nWhy is that? Because gcc is awesome, of course!\nSo, we can write C++ code and get the same assembly code as a C program, that's what we call *zero cost abstraction*.\n\n## What's Next?\n\nOkay, so we've seen how to program an Arduino Nano Every without using the Arduino library.\nThrough a very simple example, we've also seen that C and C++ code lead to the same assembly code.\n\nIn the next part, we will focus on MIDI and see how we can turn our Arduino Nano Every into a MIDI device.\n",
            "url": "https://news.exadrums.com/article/new-arduino-nano-every-board-part2",
            "title": "New Arduino Nano Every Trigger Board - Part 2",
            "summary": "This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 1.\nIn this part, I'm going to describe how to compile C++ code and upload it to the Arduino Nano Every without using the Arduino library.\nBut why would one want to do that, you may ask?\nThe answer is simple: the Arduino library does a lot of things that may impact performance.\nFor instance, some interrupts are being fired frequently, and slow things down.\nLet's be honest, we're not going to reinvent the wheel, most of what we are going to do here is to use the Arduino IDE's compiler and tools.\nSay we install the Arduino IDE (version 1.8.9) and compile a program.\nHere's what we're going to see:\n\nThe interesting part is the console, where all the compilation-related messages are shown.\nWe see that the IDE uses avr-gcc version 7.3.0, along with a few other tools.\nLet's see what we can do with that.",
            "date_modified": "2022-05-08T15:42:25.000Z",
            "date_published": "2022-05-08T15:42:25.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/new-arduino-nano-every-board-part1",
            "content_html": "\nThis project has been in the works for about a year.\nI often get questions about MIDI support, so I spent some time developing a new exadrums board that supports MIDI.\nBefore we start, please note that this post will be split into several parts.\n\nThe board is capable of handling 8 triggers.\nIt can send MIDI notes over USB, or directly to a serial device such as a Raspberry Pi.\nThere is no on-board Analog to Digital Converter (ADC). Instead, there are two 15-position Arduino Nano-compatible female headers.\nAny microcontroller that is pin-compatible with the Arduino Nano will fit.\nFor the rest of this post, I'll assume that the microcontroller is an Arduino Nano Every.\n\nBut before we dive into the details, check out that board!\n\n![image](/images/new-arduino-nano-every-board/board.png)\n![image](/images/new-arduino-nano-every-board/board-arduino.png)\n\nBoard alone (left), and board with Arduino mounted on (right).\nI went for a blue PCB so that it would match the Arduino's color.\n\n\n<!--more-->\n\n## Board Specs\n\nSo far, with an Arduino Nano Every, I've achieved the following:\n\n- Compatible with Roland TD-9, TD-11, TD-15, TD-17, TD-25, and TD-27-based edrum kits (DB25 connector).\n- Sample rate greater than 70ksps (kilo samples per second).\n- Nearly 9 samples per milliseconds and per channel (8.93 in average).\n- Configurable trigger parameters: threshold, scan time and mask time (1ms step).\n- Configurable MIDI channel and notes.\n\nUsing 7 of the 8 inputs (the pads only), I managed to optimize the firmware quite a bit, as it fits into less than 2k bytes of flash and uses less than 128 bytes of RAM. Of course, this will increase a little when the hi-hat pedal code will be added.\n\n## This New Board is Called TB08-SE\n\nThis new board's name is *eXaDrums TB08-SE*.\nRead *eXaDrums Trigger Board, 8 inputs, Special Edition*.\nI consider this board a special edition because this is the first exadrums board that is MIDI-compliant, and also because it is modular.\nAs you can see on the photos above, the Arduino isn't soldered to the board, which means you can use another microcontroller if you want to (for instance an STM32 Nucleo board). As long as the pinout is compabitle, of course. Note that I don't recommend the Arduino Nano for this board, as its ADC is way too slow. The Arduino Nano Every, on the other hand, is a perfect fit!\n\n## How it Works\n\n### Analog Circuitry\n\nThe analog part of the board is quite straightforward. It uses op-amps and passive components to scale down the piezo voltage to the 0-3.3V range.\nAt rest, the output voltage is 1.65V (3.3V/2).\nAmong the 8 inputs, 7 are intended to be used with single-zone pads, and one is to be used with a hi-hat controller.\n\nHere's how everything is wired:\n\n|  Instrument   | Cable Reference | Arduino Analog Input | ATMega4809 Analog Input |\n|---------------|-----------------|----------------------|-------------------------|\n| Kick          |  KIK            |  A0                  |  AIN3                   |\n| Snare         |  SNR            |  A1                  |  AIN2                   |\n| Hi-hat        |  HH             |  A2                  |  AIN1                   |\n| Hi-hat Control|  HHC            |  A3                  |  AIN0                   |\n| Crash         |  CR1            |  A4                  |  AIN12                  |\n| Tom1          |  T1             |  A5                  |  AIN13                  |\n| Tom3          |  T3             |  A6                  |  AIN4                   |\n| Ride          |  RD             |  A7                  |  AIN5                   |\n\n### Arduino Nano Every\n\nI chose the Arduino Nano Every because it's affordable, popular, small, and more importantly, because it has the right specs for the job!\nThe on-board ATMega4809 has plenty of flash and RAM, so I knew these wouldn't cause any issues.\nThe ADC is a crucial element for an edrum project, and the ATMega4809 has a 10-bit ADC that is capable of running at a 115ksps.\nFor a 8-input board, that means about 14 samples per millisecond and per channel, which is quite good (it's recommended to get, at the very least, 5 samples per ms and per channel. But usually, [it's best to get around 10 samples/ms/channel](https://www.vdrums.com/forum/advanced/technical/1215866-edrumin-let-s-talk-about-it?p=1216107#post1216107)).\n\nHowever, the ATMega4809 isn't a powerful beast. First of all, the Arduino Nano Every runs at 16MHz by default.\nAlthough you can change the CPU clock to a slightly higher frequency of 20MHz, I decided not to do that in order to keep things simple (and challenging).\nYou might think that 16MHz is quite a lot, after all it means that one clock cycle is as short as 62.5ns, but there's another catch.\nThe ATMega4809 is an 8-bit microcontroller, which means that even adding two 32-bit integers requires several clock cycles.\nSo, when you only have a few microseconds between each ADC reading, it's kind of foolish to consider floating point arithmetic...\nFIY, the Arduino Nano Every's score at the CoreMark CPU Benchmark is 8.20, where 32-bit microcontroller such as the Teensy 3.2 (72MHz) scores well above 100, and a Teensy 3.6 gets a core of 440, [which is more than 50 times the Arduino Nano Every score](https://github.com/PaulStoffregen/CoreMark).\n\nSo with all those limitations in mind, I decided to go for 12 microseconds between each sample.\nThat leaves around 200 instructions (per channel) for all the computations.\nUnfortunately, that was a bit ambitious, so I had to increase that time to 14µs, which leads to almost 9 samples per millisecond and per channel.\nBut you already knew that if you read the post from the beginning.\n\n## The Devil is in the Details\n\nSo what do we need to make this work?\nHere's a list I came up with when I was starting to think about this project.\nWe need to:\n\n- Get at least 5 samples per milliseconds and per channel.\n- Provide an internal time reference.\n- Avoid floating point numbers and complex calculations.\n- Use hardware capabilities whenever possible.\n- Go as low level as possible to optimize computations.\n- Write high level code to improve readability.\n\nBut how to go as high level as possible and optimize the code at the same time?\nTo be honest, I didn't even think about that at first...\nI started to write all the code in C, so that I could get a working prototype.\nThen I introduced some high level C++ to improve the code readability.\nAs I was doing that, I noticed the compiled program was getting smaller and smaller.\nSo, without any massive effort, I managed to write high level readable code that was also quite optimized.\nAt some point, the program was mainly written in C and was using 978 bytes of flash.\nRewriting the same program in C++ decreased the program size to 918 bytes.\nI didn't try to find the reason why that is, but my conclusion was that gcc is awesome!\n\n## What's Next?\n\nIt would take a long time to describe everything that's going on, so I'll stop here for now and cover more things in part 2.\nThe next part will be about getting the code to compile and upload to the Arduino board, without the Arduino library.\n",
            "url": "https://news.exadrums.com/article/new-arduino-nano-every-board-part1",
            "title": "New Arduino Nano Every Trigger Board - Part 1",
            "summary": "This project has been in the works for about a year.\nI often get questions about MIDI support, so I spent some time developing a new exadrums board that supports MIDI.\nBefore we start, please note that this post will be split into several parts.\nThe board is capable of handling 8 triggers.\nIt can send MIDI notes over USB, or directly to a serial device such as a Raspberry Pi.\nThere is no on-board Analog to Digital Converter (ADC). Instead, there are two 15-position Arduino Nano-compatible female headers.\nAny microcontroller that is pin-compatible with the Arduino Nano will fit.\nFor the rest of this post, I'll assume that the microcontroller is an Arduino Nano Every.\nBut before we dive into the details, check out that board!\n\n\nBoard alone (left), and board with Arduino mounted on (right).\nI went for a blue PCB so that it would match the Arduino's color.",
            "date_modified": "2022-05-01T12:41:05.000Z",
            "date_published": "2022-05-01T12:41:05.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/new-arduino-nano-every-board-part3",
            "content_html": "\nThis is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 2](/article/new-arduino-nano-every-board-part2).\n\nIn this part, we are going to send MIDI notes over USB using the Arduino Nano Every.\nTo understand everything correctly, make sure you read the previous parts.\n\n♬ ♪ ♬ ♪\n\n<!--more-->\n\n## MIDI Protocol for a Basic Drum Module\n\nFirst, we are going to talk about MIDI and what it actually is at the \"hardware\" level.\nI'll be honest, I probably know only the basis of MIDI.\nHowever, I believe I know enough to make a drum module that sends MIDI notes and messages.\n\nFor a basic drum module, we'll need two MIDI ingredients: notes and control change.\nMIDI is old, so most messages are represented by bytes, that is values that can go from 0 to 255, or -128 to 127 if you represent byte as signed integers using two's complement.\nBut there's a catch, MIDI doesn't always use 8-bit data, rather, some parameters use 7-bit data, so their values go from 0 to 127.\nThat means, there are 128 MIDI notes.\n\nSo what is a MIDI (drum) note exactly?\nWell, drums are a bit different than other instruments in a sense that there aren't actual notes per say.\nThere is one thing called *Universal General MIDI Drum Notes* that saves us, though.\nIt defines more than 40 \"notes\" (from note 35 to 81) that [represent drum instruments](https://www.zendrum.com/resource-site/drumnotes.htm).\nHere are some examples: 35 is *Acoustic Bass Drum*, 38 is *Acoustic Snare*, 70 is *Maracas*, and 81 is *Open Triangle*.\n\n### MIDI Commands\n\nIn practice, MIDI notes are sent using commands. There are two note commands: *Note On* and *Note Off*.\nAs the names suggest, the former tells the instrument to play a note, and the latter says that we need to stop playing that note.\nA command, such as *Note On*, is represented by a byte.\nThis byte is divided into two distinct parts: the command itself, and the MIDI channel.\nThere are 16 MIDI channels, so in theory you can send 16 *Note On* commands over the 16 available channels.\n\nThe way it works is that the command byte is cut in half. The most significant bits represent the command, and the least significant bits represent the channel number.\nHere's an example. We would like to send a *Note On* command over channel 0.\nThe command number for *Note On* is 144, so we simply send a byte that holds the value 144, easy.\nBut, in MIDI, drums use channel 10, so how do we send a note over channel 10?\n\nTo answer that question, we are going to use hexadecimal values instead of decimal.\nThe *Note On* command for channel 0 is 144, which becomes `0x90` in hexadecimal.\nChannel number 10, becomes channel number `0x0A`, so a *Note On* command over channel 10 is `0x9A`.\nBy the way `0x9A` is 154 in decimal, so that's just `144 + 10`, which is the *Note On* command *plus* the channel number.\n\n### Drum Notes\n\nNow, we know how to send a *Note On* command. It is quite simple, as only one byte needs to be sent.\nThis byte value is `0x9A` in hexadecimal if we use channel 10.\n\nIf a MIDI instrument were to received that command, it would need to know which note to play.\nThis is why the *Note On* command must be followed by the note number.\nLets say we want a snare drum sound, we need to send `0x9A` followed by 38, or `0x26`.\n\nAnd that's it. If an instrument receives those two bytes one after another it will know that it should play a snare drum note.\nBut it won't, because there's still one thing that's missing here: the velocity.\n\n### Note Velocity\n\nIt would be no fun at all if all the notes had the same velocity.\nThat's why a third byte follows the MIDI command and MIDI note number, and that third byte represents the velocity.\nThe velocity goes from 0 to 127 (yes it uses only 7 bits).\n\nFinally, to send a snare drum note with a velocity of 92, we have to send 3 bytes: `154, 38, 92` or, in hexadecimal: `0x9A, 0x26, 0x5C`.\n\n### Baud Rate & Latency\n\nYou probably think that sending only 3 bytes must be very fast, but is it really that fast?\nMIDI communications usually happen at 38400 bauds per second.\nThe actual speed in bytes per seconds is 38400 divided by 8, which gives 4800 Bps.\nSay we send 3 bytes per note, that gives us 1600 notes per second, or 0.625 milliseconds (ms) to send a note.\nThat may not seem like a lot, and it isn't really a lot, but that's getting close to 1 ms.\n\nDo we really have to stick with 38400 bps?\nI believe we don't, but it depends on the VST (Virtual Studio Technology) you use.\nNow, if we use a baud rate of 115200 bps, we get 14400 Bps, so 4800 notes per second.\nThat means we're sending one note in nearly 0.2 ms. That's a bit better.\n\n### Control Change\n\nOkay, it's quite easy to understand what a note is, but perhaps we need a little bit more than that.\nWith MIDI notes, we can have a drum kit that's made of pads.\nEvery time we hit a pad, we send a note whose velocity is proportional to the pad's volume.\nWe can have drums and cymbals, but how do we deal with the hi-hat controller?\n\nWe could vary the note number according to the pedal's openness.\nAfter all, there are two notes dedicated to the hi-hat: 42 is *Closed Hi-Hat* and 46 *Open Hi-Hat*, and some VSTs also define a *Semi-Open Hi-Hat* note.\nThat's a totally fine thing to do, but there's a better solution: control change.\n\nControl change may seem more complicated than note commands, but it really is based on the same principle: send 3 bytes.\nThe first byte is the command byte, and it is 176 or `0xB0` in hexadecimal.\nAs for the notes, it has to be combined with the channel number.\nSo for channel 10, we get 186 or `0xBA`.\n\nThe second byte represents the control function. It can be a modulation wheel, a foot controller, an expression controller, etc.\nThere are 128 possible control functions, but some of them are undefined.\nFor the hi-hat controller, the one we are interested in is the *foot controller*, so control function number 4.\nThe second byte is 4, `0x04`.\n\nNow the third byte is the value the control function should take.\nJust like the velocity, this value goes from 0 to 127.\n\nIf the hi-hat pedal is half-open, we send the following three bytes: `186, 4, 63`, or `0xBA, 0x04, 0x3F`.\nAt least that what we send when a control change message needs to be sent. But when do we send a control change exactly?\n\nTwo options come to mind: when the sensor register a change that's big enough to be perceptible, or at regular time interval.\nWe'll go for the former, as there's no reason to send a control change if there's no change in the sensor value.\n\n## Serial MIDI Over USB\n\nSo far we've talked about MIDI as bytes we send to a device, but we need to address how we send those bytes.\n\n### The Hard Truth About the ATMega4809\n\nThe ATMega4809 has 4 USART (universal synchronous and asynchronous receiver-transmitter) preipherals.\nOne of them is accessible via the Arduino Nano Every board pins `RX` and `TX`, and the other one is hardwired to another microcontroller that's on the board: the SAMD11D14A.\n\nWhy is there another microcontroller on the board? Here's what the official documentation has to say:\n\n```text\nThe SAMD11D14A processor is shipped with a firmware that implements USB to serial bridge and handles\nATMega4809 firmware upgrade through the UPDI interface.\n```\n\nThe ATMega4809 doesn't support the USB protocol, so another microcontroller handles that instead.\nIt acts as a USB to serial bridge, and is connected to one of the ATMega4809's USART peripherals.\nSo when you use `Serial.println` in your Arduino IDE, the data goes from your Arduino USART numnber 3 to the SAMD11D14A which sends it over USB to you PC.\n\nAs a consequence, the Arduino Nano Every can't be recognized as a USB device, so no USB MIDI!\n\n### How to Send MIDI Notes to a Computer\n\nAll hope is not lost, we can send MIDI data over USB, the catch is that we can't use the USB protocol.\nInstead we can transfer serial data directly, which has one advantage: the code is simpler to write!\nThere are two options: we can use a serial to USB adapter and connect our Arduino (using two resistors) to it.\nOr we can use the on-board USB and convert the serial data adequately on the target PC.\n\nWe are going to go for option number two, as we'd prefer not to rely on additional hardware.\nThe way it works is pretty straightforward, we are just going to send our bytes over the USART3.\n\n## ATMega4809 USART & MIDI\n\nHere we are, ready to write some code.\nIn order to send the notes over USB, we need to use USART3.\nThe ATMega4809's documentation tells us a few things:\n\n- We need to set the USART pins as output (TX) and input (RX).\n- Then, we have to configure the USART (especially its baud rate).\n- Only after the USART's been configured, we can use its registers to send and receive data.\n\nWe are going to need to configure PORTB (please refer to [part 2 of this series](/article/new-arduino-nano-every-board-part2) for more info).\nTo that end, we use the following code:\n\n```cpp\n\n#include <avr/io.h>\n\n#include <stdint.h>\n\nnamespace DigitalIO\n{\n    \n    static const auto PORTA_ADDR = reinterpret_cast<uint16_t>(&PORTA); \n    static const auto PORTB_ADDR = reinterpret_cast<uint16_t>(&PORTB); \n    static const auto PORTC_ADDR = reinterpret_cast<uint16_t>(&PORTC); \n    static const auto PORTD_ADDR = reinterpret_cast<uint16_t>(&PORTD); \n    static const auto PORTE_ADDR = reinterpret_cast<uint16_t>(&PORTE);\n    static const auto PORTF_ADDR = reinterpret_cast<uint16_t>(&PORTF);\n\n\n    template <uint16_t portAddr, uint8_t mask>\n    class Pin\n    {\n    public:\n        Pin() = delete;\n        ~Pin() = delete;\n\n        static constexpr void ConfigureAsInput()\n        {\n            port().DIRSET &= ~mask;\n        }\n\n        static constexpr void ConfigureAsOutput()\n        {\n            port().DIRSET |= mask;\n        }\n\n        static constexpr void Toggle()\n        {\n            port().OUTTGL |= mask;\n        }\n\n        static constexpr void SetHigh()\n        {\n            port().OUTSET |= mask;\n        }\n\n        static constexpr void SetLow()\n        {\n            port().OUTCLR |= mask;\n        }\n\n        static constexpr auto& port()\n        {\n            return *reinterpret_cast<PORT_t*>(portAddr);\n        }\n        \n    private:\n\n    };\n    \n} // namespace IO\n```\n\nNow we need to configure the USART. I'll give the code for USART3 only, feel free to improve it to handle other USARTs if you wish.\n\n```cpp\n#include \"Pin.hpp\"\n#include \"Port.hpp\"\n\n#include <avr/io.h>\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\nnamespace DigitalIO\n{\n\n    template <uint8_t N>\n    class Usart\n    {\n    public:\n\n    constexpr explicit Usart(uint32_t br)\n    {\n        switch(N)\n        {\n            // TODO: configure Usart 0 to 2\n            case 3: \n            {    \n                PORTMUX.USARTROUTEA |= PORTMUX_USART30_bm;\n                using Usart3InputPin = Pin<PORTB_ADDR, PIN5_bm>;\n                using Usart3OutputPin = Pin<PORTB_ADDR, PIN4_bm>;\n\n                Usart3InputPin::ConfigureAsInput();\n                Usart3OutputPin::ConfigureAsOutput();\n                \n                break;\n            }\n            default: static_assert(N <= 3, \"Invalid USART number.\"); break;\n        }\n\n        usart().BAUD = BaudRate(br);\n        usart().CTRLB |= USART_RXEN_bm | USART_TXEN_bm; \n        usart().CTRLC |= USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc;\n    }\n\n    constexpr void SendByte(uint8_t c)\n    {\n        while(!(usart().STATUS & USART_DREIF_bm))\n        {\n            ;\n        }        \n        usart().TXDATAL = c;\n    }\n\n    static constexpr uint16_t BaudRate(uint32_t baudRate)\n    {\n        return static_cast<uint16_t>(static_cast<float>((F_CPU * 64 / (16 * static_cast<float>(baudRate))) + 0.5));\n    }\n\n    static constexpr USART_t& usart()\n    {\n        switch(N)\n        {\n            case 0: return USART0;\n            case 1: return USART1;\n            case 2: return USART2;\n            case 3: return USART3;\n            default: static_assert(N <= 3, \"Invalid USART number.\");\n        }\n    }\n\n    private:\n\n    };\n\n} // namespace IO\n```\n\nYou'll notice that there is a `SendByte` function.\nThat's all we need to send MIDI notes, as we need to send 3 bytes for each `Note On` command.\n\n## Sending MIDI Over USART\n\nAll right, lets wring some code that sends MIDI notes.\nWe are going to use one more little helper:\n\n```cpp\n#include \"DigitalIO/Usart.hpp\"\n\ntemplate <typename Usart>   \nclass SerialMidi\n{\n\npublic:\n\n    SerialMidi() = delete;\n    ~SerialMidi() = default;\n\n    SerialMidi(Usart& usart) : usart_{usart}\n    {\n\n    }\n\n    template <uint8_t channel>\n    inline void NoteOn(uint8_t note, uint8_t velocity) const noexcept\n    {\n        usart_.SendByte(0x90 | (channel & 0x0f));\n        usart_.SendByte(note);\n        usart_.SendByte(velocity);\n    }\n\n    template <uint8_t channel, uint8_t control>\n    inline void ControlChange(uint8_t value) const noexcept\n    {\n        static_assert(control <= 127, \"Invalid control value.\");\n        usart_.SendByte(0xB0 | (channel & 0x0f));\n        usart_.SendByte(control);\n        usart_.SendByte(value);\n    }\n\n\nprivate:\n\n    Usart& usart_;\n\n};\n```\n\nEven if we are not going to use it, I included the `ControlChange` function.\n\n```cpp\n#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <util/delay.h>\n\nusing Usart3 = DigitalIO::Usart<3>;\n\nstatic Usart3 usart{115'200};\nstatic SerialMidi midi{usart};\n\nint main()\n{\n    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler\n\n    sei();\n\n    const uint8_t snareNote = 38;\n    const uint8_t bdNote = 36;\n    const uint8_t hhNote = 42;\n\n    const uint8_t nbNotes = 8;\n    const uint8_t snareNotes[nbNotes] =    {0, 0, 1, 0, 0, 0, 1, 0};\n    const uint8_t hihatNotes[nbNotes] =    {1, 1, 1, 1, 1, 1, 1, 1};\n    const uint8_t bassDrumNotes[nbNotes] = {1, 0, 0, 0, 1, 1, 0, 0};\n\n    uint8_t i = 0;\n\n    for(;;)\n    {\n        _delay_ms(400);\n\n        if(snareNotes[i] == 1)\n        {\n            midi.NoteOn<10>(snareNote, 80);\n        }\n\n        if(hihatNotes[i] == 1)\n        {\n            midi.NoteOn<10>(hhNote, 80);\n        }\n\n        if(bassDrumNotes[i] == 1)\n        {\n            midi.NoteOn<10>(bdNote, 80);\n        }\n\n        i = ++i % nbNotes;\n    }\n\n    return 0;\n}\n```\n\nWe have defined three instruments: a snare drum, a hi-hat, and a bass drum, each having its MIDI note: 38, 42 and 36, respectively.\nWe also define an array of eight notes for each instrument.\nIn that array, a \"1\" means that the instrument's note is to be played, and a \"0\" means nothing happens.\nWe iterate the array in loop, and play a note every 400 ms.\nI believe the code is self-explanatory.\n\n## Playing Those Notes\n\nAs I have already mentioned, our Arduino isn't recognized as a MIDI device because it doesn't use the USB protocol.\nConsequently, we need to *convert* the incoming serial data to MIDI data.\nTo that end, we can use [ttymidi](https://github.com/cjbarnes18/ttymidi).\nIt isn't too hard to use, and works well on Linux.\nFirst of all, we need to clone the repository: `git clone https://github.com/cjbarnes18/ttymidi`.\nThen, in the `ttymidi` directory, we need to compile it using `make`.\nAnd finally, to start the program, we run the following command:\n\n```text\n./ttymidi -s /dev/ttyACM0 -b 115200 -v\n```\n\nWhere `/dev/ttyACM0` is the Arduino's serial port.\nLet ttymidi run with the Arduino plugged in and you'll see MIDI notes being received in real-time.\n\n## What's Next?\n\nWe are going to take a break for now.\nI don't when the next part will be posted, but I know it'll be about the Analog to Digital Converter (ADC).\nWe'll probably get back to MIDI-related topics another time.\nSee you next time!\n",
            "url": "https://news.exadrums.com/article/new-arduino-nano-every-board-part3",
            "title": "New Arduino Nano Every Trigger Board - Part 3",
            "summary": "This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 2.\nIn this part, we are going to send MIDI notes over USB using the Arduino Nano Every.\nTo understand everything correctly, make sure you read the previous parts.\n♬ ♪ ♬ ♪",
            "date_modified": "2022-05-15T12:49:07.000Z",
            "date_published": "2022-05-15T12:49:07.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/new-arduino-nano-every-board-part4",
            "content_html": "\nThis is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 3](/article/new-arduino-nano-every-board-part3).\n\nIn this part, we are going to read data from the Analog to Digital Converter (ADC) and make an oscilloscope.\nIt'll show us what the piezo voltage of drum pad looks like when hit with a drum stick.\n\n![signal](/images/new-arduino-nano-every-board/signal.png)\n\nTo understand everything correctly, make sure you read the previous parts.\n\n<!--more-->\n\n## How the ADC Works\n\nThis part is going to be a little bit more theoretical.\nBut we'll see a concrete example at the end.\n\n### ADC Configuration\n\nFirst of all, we need to talk about the ATMega4809's ADC configuration.\nWithout going into the very technical details, I'll talk about some of the important parameters of the ADC.\nIt needs a clock source, which can be obtained from the peripheral clock.\nThe way this clock signal is generated, is by dividing the CPU clock by a 'divider' that goes from 2 to 256.\nSince the CPU clock is 16 MHz, that leaves with an ADC frequency that goes from 62.5 kHz to 8 MHz.\nIn practice, it is recommended to avoid low frequencies, and to not go above 1.5 MHz.\nA normal conversion takes 13 ADC clock cycles, so the fastest conversion time we can get is 8.67 µs.\nThat is a bit over 115 kilo samples per seconds (ksps).\n\nAnother important parameter is the resolution of the ADC. Here we have two choices: 8-bit or 10-bit.\nIn the case of 8-bit sampling, we can store the data into a single byte.\nHowever, 10-bit resolution will require 16-bit integers to store the results, which can lead to slower code.\n\nThere are different modes of operation. We are interested in the 'normal' mode, in which we ask the microcontroller to start a new conversion ourselves. There's also the free-running mode, in which the ADC starts a new conversion every time the previous one has finished.\n\n### Events and Interrupts\n\nThere are two ways the microcontroller can communicate with peripherals:\n\n- Interrupts: they let you execute a function automatically after an hardware event has occurred.\n- Events: they allow peripherals to communicate with one another.\n\nWe are going to use both of them, the event will trigger a new conversion when a timer overflows, and the interrupt will be used to fetch the conversion result.\n\n## Using the ADC in C++\n\nFirst, let's see how to use the ADC in C++.\nWe define a few useful things: \n\n```cpp\nstatic const auto Adc0Addr = reinterpret_cast<uint16_t>(&ADC0);\n\nclass Adc10bitType;\nclass Adc8bitType;\n\nenum class Vref : uint8_t\n{\n    External,\n    Internal, \n    Vdd,\n};\n\nenum class Prescaler : uint8_t\n{\n    Div2,\n    Div4,\n    Div8,\n    Div16,\n    Div32,\n    Div64,\n    Div128,\n    Div256\n};\n\ntemplate <typename T, typename Enable = void>\nclass AdcBase;\n\ntemplate <typename T>\nclass AdcBase<T, Util::enable_if_t<Util::is_same_v<T, Adc8bitType>>>\n{\npublic:\n    AdcBase() = delete;\n    ~AdcBase() = delete;\n\nprotected:\n\n    inline static uint8_t value{};\n\n};\n\n\ntemplate <typename T>\nclass AdcBase<T, Util::enable_if_t<Util::is_same_v<T, Adc10bitType>>>\n{\npublic:\n    AdcBase() = delete;\n    ~AdcBase() = delete;\n\nprotected:\n\n    inline static uint16_t value{};\n\n};\n```\n\nThe ADC register's address is stored in `Adc0Addr`.\nWe've defined utilities for the ADC resolution, its voltage reference, and the frequency divider.\n\nNotice the use of `enable_if`, which is defined as:\n\n```cpp\nnamespace Util\n{\n    \n    template <class T, T v>\n    struct integral_constant \n    {\n        static constexpr T value = v;\n        using value_type = T;\n        using type = integral_constant; // using injected-class-name\n        constexpr operator value_type() const noexcept { return value; }\n        constexpr value_type operator()() const noexcept { return value; } // since c++14\n    };\n\n    template <class T, class U>\n    struct is_same : integral_constant<bool, false> {};\n    \n    template <class T>\n    struct is_same<T, T> : integral_constant<bool, true> {};\n\n    template<bool B, class T = void>\n    struct enable_if {};\n    \n    template<class T>\n    struct enable_if<true, T> { using type = T; };\n\n    template< bool B, class T = void >\n    using enable_if_t = typename enable_if<B,T>::type;\n\n    template< class T, class U >\n    inline constexpr bool is_same_v = is_same<T, U>::value;\n\n} // namespace Util\n```\n\nThis is usually part of the standard C++ library, but we don't have it, so these definitions help us achieve what we need: two different types for the 8-bit and 10-bit modes.\nAlright, now we're done with the boilerplate, so let's get all the basic stuff out of the way:\n\n```cpp\ntemplate <uint16_t addr, typename ValueType>\nclass Adc : private AdcBase<ValueType>\n{\n\npublic:\n\n    Adc() = delete;\n    ~Adc() = delete;\n\n    template <Prescaler div>\n    static constexpr void SetPrescaler()\n    {\n        switch(div)\n        {\n            case Prescaler::Div2:   adc().CTRLC |= ADC_PRESC_DIV2_gc; break;\n            case Prescaler::Div4:   adc().CTRLC |= ADC_PRESC_DIV4_gc; break;\n            case Prescaler::Div8:   adc().CTRLC |= ADC_PRESC_DIV8_gc; break;\n            case Prescaler::Div16:  adc().CTRLC |= ADC_PRESC_DIV16_gc; break;\n            case Prescaler::Div32:  adc().CTRLC |= ADC_PRESC_DIV32_gc; break;\n            case Prescaler::Div64:  adc().CTRLC |= ADC_PRESC_DIV64_gc; break;\n            case Prescaler::Div128: adc().CTRLC |= ADC_PRESC_DIV128_gc; break;\n            case Prescaler::Div256: adc().CTRLC |= ADC_PRESC_DIV256_gc; break;\n        }\n    }\n\n    template <Vref vref>\n    static constexpr void SetReference()\n    {\n        switch(vref)\n        {\n            case Vref::External: adc().CTRLC |= ADC_REFSEL_VREFA_gc; break;\n            case Vref::Internal: adc().CTRLC |= ADC_REFSEL_INTREF_gc; break;\n            case Vref::Vdd: adc().CTRLC |= ADC_REFSEL_VDDREF_gc; break;\n        }\n    }\n\n    static constexpr void SelectChannel(ADC_MUXPOS_t chan)\n    {\n        channel = chan;\n        adc().MUXPOS = channel;\n    }\n\n    static constexpr void Enable()\n    {\n        if constexpr(Util::is_same_v<ValueType, Adc8bitType>)\n        {\n            adc().CTRLA = ADC_ENABLE_bm | ADC_RESSEL_8BIT_gc;\n        }\n        \n        if constexpr(Util::is_same_v<ValueType, Adc10bitType>)\n        {\n            adc().CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc;\n        }\n    }\n\n    static constexpr void StartConversion()\n    {\n        adc().COMMAND = ADC_STCONV_bm;\n    }\n\n\n    static constexpr bool ConversionDone()\n    {\n        return adc().INTFLAGS & ADC_RESRDY_bm;\n    }\n\n    static constexpr auto GetValue()\n    {\n        return Adc<addr, ValueType>::value;\n    }\n\n\nprivate:\n\n    static constexpr auto& adc()\n    {\n        return *reinterpret_cast<ADC_t*>(addr);\n    }\n\n    inline static ValueType value = 0;\n    inline static ADC_MUXPOS_t channel = ADC_MUXPOS_t::ADC_MUXPOS_AIN0_gc;\n\n};\n```\n\nHere are the things we can do with this code:\n\n- Set the ADC clock frequency by changing the clock divider (or prescaler) using `SetPrescaler()`.\n- Set the voltage reference (we'll use an external reference here) using `SetReference()`.\n- Select the input channel (from 0 to 7), using `SelectChannel(ADC_MUXPOS_t chan)`.\n- Of course, we can enable the ADC, start a conversion, and check if the conversion is done.\n\nWith all that we can write an infinite loop, start a conversion, do some things, wait until the conversion is done (in a loop), read the result and use the value as we see fit.\nBut that wouldn't correspond to what we really need.\nWhat we do need is to trigger conversions at a regular interval so that we know exactly how much time has elapsed since the previous value was retrieved from the ADC.\n\n## Using a Timer to Trigger the ADC at Regular Intervals\n\nWe are not going to go into much details about setting up the timer.\nHowever, we are going to focus on the event system that allows to trigger the ADC when the timer overflows.\n\n### Timer Configuration\n\nWe are going to use the TCA timer.\nIt will be configured as follows:\n\n```cpp\n// Configure TCA\nTca::SetSingleMode<Timing::TCASingleMode::Normal>();\nTca::DisableEventCounting();\nTca::SetPeriod(13);             // 14 µs\n\nTca::SetClockDivider<Timing::TCAClockDiv::Div16>();\nTca::Enable();\n```\n\nThe complete code will be on [GitHub](https://github.com/SpintroniK/exadrumino-Nano-Every) soon.\nI believe the code speaks for itself: the timer will overflow every 14 µs.\nIt will count up to 13 (including 0), at a frequency of 1 MHz (CPU clock divided by 16).\n\n### Event System\n\nLet's see how we can trigger an ADC conversion automatically when the timer overflows.\nTo that end, we are going to use the ATMega4809's event system.\nThe event system has 8 channels that allows peripherals to communicate with each other.\nEach channel can be used to connect a peripheral to another one, or itself.\nWe are interested in the overflow event of the TCA timer and the ADC conversion start event.\n\nBut first let's use a little helper that'll make our life easier and the code more readable: \n\n```cpp\n#include <avr/io.h>\n\n#include <stdint.h>\n\ninline constexpr uint8_t EVSYS_GENERATOR_TCA0_OVF_gc = 0x80 << 0; // Should already be defined, but it's not...\n\nnamespace Event\n{\n\n    using Generator = uint8_t;\n    using Event = register8_t;\n\n\n    class EventSystem\n    {\n        \n    public:\n        EventSystem() = delete;\n        ~EventSystem() = delete;\n\n        template <uint8_t channel>\n        static constexpr void Connect(Generator in, Event& out)\n        {\n            switch(channel)\n            {\n                case 0:\n                {\n                    EVSYS.CHANNEL0 = in;\n                    out = EVSYS_CHANNEL_CHANNEL0_gc;\n                    break;\n                }\n\n                case 1:\n                {\n                    EVSYS.CHANNEL1 = in;\n                    out = EVSYS_CHANNEL_CHANNEL1_gc;\n                    break;\n                }\n\n                default: static_assert(channel <= 7, \"\"); break;\n            }\n        }\n\n    private:\n\n    };\n    \n} // namespace Event\n```\n\nI've only implemented the code for channel 0 and channel 1. Other channels can be added by filling the switch-case statement.\nAnd that's how we 'connect' the TCA's overflow to the ADC's start conversion event:\n\n```cpp\nEvent::EventSystem::Connect<0>(EVSYS_GENERATOR_TCA0_OVF_gc, EVSYS.USERADC0);\n```\n\n## ADC Events and Interrupts\n\nA few things are missing in our ADC class.\nWe need to be able to enable events and interrupts, so we can add the following member functions:\n\n```cpp\nstatic constexpr void EnableInterrupts()\n{\n    adc().INTCTRL |= ADC_RESRDY_bm;\n}\n\nstatic constexpr void EnableEvents()\n{\n    adc().EVCTRL |= ADC_STARTEI_bm;\n}\n```\n\nThat's it for the event's configuration, but what about the interrupt?\nAn interrupt is triggered by the hardware, but it needs to be handled on the software side.\nMore precisely, we need to define a function that is going to be called when an interrupt is fired.\nIt is kind of a callback function that takes no arguments and returns nothing.\n\nI'm not going to go into the gory details of gcc, but because of a bug in the compiler, with have to define a new class with a static function that handles the interrupt:\n\n```cpp\nclass AdcInterrupts\n{\npublic:\n\n    AdcInterrupts() = delete;\n    ~AdcInterrupts() = delete;\n\nprivate:\n\n    static void ResReady() __asm__(\"__vector_22\") __attribute__((__signal__, __used__, __externally_visible__));\n};\n```\n\nWe can handle some other ADC interrupts in the same class if we need to.\nBut how do we know that we need to use the vector 22?\nAgain without going into a lot of details, the answer is in the `iom4809.h` header, where we can find:\n\n```cpp\n/* ADC0 interrupt vectors */\n#define ADC0_RESRDY_vect_num  22\n#define ADC0_RESRDY_vect      _VECTOR(22)  /*  */\n#define ADC0_WCOMP_vect_num  23\n#define ADC0_WCOMP_vect      _VECTOR(23)  /*  */\n```\n\n## Putting it All Together\n\nOkay, now we have almost everything we need, so it's time to write our main function.\nBut before that, we need to define the body of our ADC interrupt in a `.cpp` file.\nLet's put it in our `main.cpp` file then:\n\n```cpp\n\nusing Adc0 = Adc<Adc0Addr, Adc8bitType>;\n\nvoid Analog::AdcInterrupts::ResReady()\n{\n    Adc0::ResetInterrupt();\n    // Do somehing with the ADC value ADC0.RES here\n}\n```\n\nWhat we do with the resulting value is up to us, as long as our computations finish before the timer overflows again.\n\nNow to our main function.\n\n```cpp\nint main()\n{\n\n    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler\n\n    sei();\n\n    Event::EventSystem::Connect<0>(EVSYS_GENERATOR_TCA0_OVF_gc, EVSYS.USERADC0);\n\n    // Configure ADC\n    Adc0::EnableInterrupts();\n    Adc0::EnableEvents();\n    Adc0::SelectChannel(ADC_MUXPOS_AIN0_gc);\n    Adc0::SetPrescaler<Analog::Prescaler::Div8>();\n    Adc0::SetReference<Analog::Vref::External>();\n    Adc0::Enable();\n\n    // Configure TCA\n    Tca::SetSingleMode<Timing::TCASingleMode::Normal>();\n    Tca::DisableEventCounting();\n    Tca::SetPeriod(13);             // 14 µs\n    \n    Tca::SetClockDivider<Timing::TCAClockDiv::Div16>();\n    Tca::Enable();\n\n\n\n    for(;;)\n    {\n    }\n\n    return 0;\n}\n```\n\nFirst of all, we disable the CPU clock prescaler.\nThen, we enable interrupts, and we connect the TCA overflow event to the ADC start conversion event.\nWe configure the ADC and the TCA.\nAnd finally, we write an infinite loop.\nOur ADC is sampling `AIN0` but, so far, we're not doing anything with the result.\n\n## Arduino Nano Every Oscilloscope\n\nIn this last section, we are going to use everything that has been presented above, plus the previous part of this series of articles.\nSo if you haven't read the [previous part](/article/new-arduino-nano-every-board-part3), I encourage you to do so.\n\n### Retrieve the ADC Value\n\nWe are going to need a variable to store the ADC value.\nAs this variable will be accessed by both the ADC interrupt and our main function, we ought to declare it as a global variable.\n\n```cpp\n\nusing Adc0 = Adc<Adc0Addr, Adc8bitType>;\n\nstatic uint8_t adcValue{};\n\nvoid Analog::AdcInterrupts::ResReady()\n{\n    Adc0::ResetInterrupt();\n    adcValue = ADC0.RES;\n}\n```\n\n### Send ADC Values Over the USART\n\nWe're going to use the USART code that we wrote in the previous part of this series.\nThe last thing we need to do is to is be able to send strings over the USART.\nIn the previous part, we wrote a function that allowed us to send a single byte.\nA string is an array of characters, and every character can be represented as a single byte.\nAll we need is to format the string and send the bytes it is made of.\nUsing `string.h` this isn't too hard to achieve.\n\n```cpp\n#include \"Adc.hpp\"\n#include \"Usart.hpp\"\n\n#include <avr/io.h>\n#include <avr/interrupt.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nusing Adc0 = Adc<Adc0Addr, Adc8bitType>;\nusing Tca = TCA<TCASingle>;\n\nstatic uint8_t adcValue{};\n\nstatic DigitalIO::Usart<3> usart{115'200};\n\nvoid Analog::AdcInterrupts::ResReady()\n{\n    Adc0::ResetInterrupt();\n    adcValue = ADC0.RES;\n}\n\nint main()\n{\n\n    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler\n\n    sei();\n\n    Event::EventSystem::Connect<0>(EVSYS_GENERATOR_TCA0_OVF_gc, EVSYS.USERADC0);\n\n    // Configure ADC\n    Adc0::EnableInterrupts();\n    Adc0::EnableEvents();\n    Adc0::SelectChannel(ADC_MUXPOS_AIN2_gc);\n    Adc0::SetPrescaler<Analog::Prescaler::Div8>();\n    Adc0::SetReference<Analog::Vref::External>();\n    Adc0::Enable();\n\n    // Configure TCA\n    Tca::SetSingleMode<Timing::TCASingleMode::Normal>();\n    Tca::DisableEventCounting();\n    Tca::SetPeriod(13);             // 14 µs\n    \n    Tca::SetClockDivider<Timing::TCAClockDiv::Div16>();\n    Tca::Enable();\n\n    for(;;)\n    {\n        // brain.SendMidiNotes();\n        static char str[32];\n        ::sprintf(str, \"%d\\n\", adcValue);\n\n        for(uint8_t i = 0; i < ::strlen(str); ++i)\n        {\n            usart.SendByte(str[i]);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\nAnd here we are, we have an Arduino Nano Every oscilloscope.\nYou can use the [new exadrums Arduino Nano Every board](/article/new-arduino-nano-every-board-part3) to connect your e-drums to and have look at a piezo signal in real time, for instance the snare drum.\n\n![arduino-board](/images/new-arduino-nano-every-board/board-arduino.png)\n\nThen, you can launch the Arduino IDE, and hit Ctrl + Shift + L.\nYou'll see something like that if you play flams, for instance:\n\n![oscilloscope](/images/new-arduino-nano-every-board/oscilloscope.png)\n\nYou'll notice that we are getting one new sample every 14 µs, but sending data at a baudrate of 115200 bps, which corresponds to about 5000 values per second in average.\nWe are getting samples way to fast, but that's not really a problem since this is just a step towards our goal: making a drum module.\nSo getting one sample every 14 µs means we can aim for 8928 samples per second and per piezo if we use 8 piezos.\n\n## What's Next?\n\nNew time I'll share the code, as it is now usable and I've tested it with my Roland TD17 e-drum.\nStay tuned!\n",
            "url": "https://news.exadrums.com/article/new-arduino-nano-every-board-part4",
            "title": "New Arduino Nano Every Trigger Board - Part 4",
            "summary": "This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 3.\nIn this part, we are going to read data from the Analog to Digital Converter (ADC) and make an oscilloscope.\nIt'll show us what the piezo voltage of drum pad looks like when hit with a drum stick.\n\nTo understand everything correctly, make sure you read the previous parts.",
            "date_modified": "2022-06-06T19:48:22.000Z",
            "date_published": "2022-06-06T19:48:22.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/new-spi-sensors-config",
            "content_html": "\nExadrums 0.7.0 is currently under development. The biggest feature of this release is the addition of configurable SPI (Serial Peripheral Interface) devices.\nThis features aims to provide a way to add as many SPI devices as you want.\nCurrently supported devices are of the MCP3XXX family, including MCP3008, MCP3204, and MCP3208, but there's a good chance more chips will be added before and after the release of this new version.\n\nThis means that it'll become possible to add more inputs to the trigger input board, by adding more analog to digital converters.\n\n![image](/images/new-spi-sensors-config/spidev-config.png)\n\n<!--more-->\n\n## How SPI Devices Work\n\nAn SPI analog to digital converter takes in analog data, digitizes it, and sends it to a Raspberry Pi using the SPI bus.\nSPI communication offers many advantages, and one of them is that it's quite easy to communicate with several devices.\nThe first eXaDrums input board uses a single MCP3008 chip, which limits the number of inputs to 8.\nAdding another MCP3008 would increase that number to 16, and if you want even more inputs, you could add a third one.\n\nThe Raspberry Pi offers at least one SPI interface that has two `Chip Select` inputs (also called *Chip Enable*).\nSo, with a single SPI bus, `SPI0`, the Raspberry Pi can communicate with two devices, by changing the states of the chip selects pins `CE0` and `CE1`.\n\nBut that's not it. Recent Raspberry Pis have another SPI *bus*: `SPI1`. And it can handle up to three devices via its three chip select inputs `CE0`, `CE1`, and `CE2`.\nSo, in theory it's possible to have up to 5 SPI Analog to Digital converters. Imagine 5 MCP3008, that would mean up to 40 inputs!\nNote that the Raspberry Pi 4 has even more SPI buses, so that should be more than enough, even for a big drum kit with a lot of triggers.\n\nIt's important to note that SPI devices are grouped by bus and chip select, and this is exactly how the SPI configuration works in exadrums.\n\n## How to Configure SPI Devices\n\nOnly supported devices are allowed in the SPI configuration dialog. They are currently limited to MCP3008, MCP3204, and MCP3208.\nEach device must be associated to a bus and a chip select.\nAnd that's basically it.\n\nHere is an example.\nYou make a trigger input board that needs to handle up to 16 analog inputs.\nThe MCP3008 is a good choice, so you decide to use two of them.\nYou can either have one of them use the `SPI0`, and the other the `SPI1`, or you can have them both use `SPI1` and choose to use two different chip selects, i.e. `CE0` and `CE1`.\nSo your configuration is:\n|  Name   | Bus | CS |\n|---------|-----|----|\n| MCP3008 |  0  |  0 |\n| MCP3008 |  0  |  1 |\n\nAnd this is exactly how you can configure your SPI devices in exadrums (see screenshot above).\nBy doing that, you'll be able to create up to 16 triggers, numbered 0 to 15, and everything will work out of the box.\n",
            "url": "https://news.exadrums.com/article/new-spi-sensors-config",
            "title": "New SPI Sensors Configurator ⇒ More Trigger Inputs",
            "summary": "Exadrums 0.7.0 is currently under development. The biggest feature of this release is the addition of configurable SPI (Serial Peripheral Interface) devices.\nThis features aims to provide a way to add as many SPI devices as you want.\nCurrently supported devices are of the MCP3XXX family, including MCP3008, MCP3204, and MCP3208, but there's a good chance more chips will be added before and after the release of this new version.\nThis means that it'll become possible to add more inputs to the trigger input board, by adding more analog to digital converters.\n",
            "date_modified": "2021-12-11T13:31:28.000Z",
            "date_published": "2021-12-11T13:31:28.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/raspberry-pi-os-bullseye",
            "content_html": "\nRemember this article about [exadrums becoming an official Debian package](article/debian-bullseye)?\nIt's now time to play (exa)drums on your Raspberry Pi.\nThe Raspberry Pi Foundation released the latest Raspberry Pi OS *bullseye* a few days ago, and as you may have guessed, it includes exadrums packages:\n\n![image](/images/raspberry-pi-os-bullseye/screenshot.png)\n\nNow, you simply have to type `sudo apt install exadrums` into a terminal to install exadrums on your Raspberry Pi.\n\n<!--more-->\n\nIt took some time to get to that point, but you get exadrums 0.6.0, which fairly recent, and works on my Roland TD-4KP drum set.\nIf you'd like to try exadrums with your TD-4KP drum set, it's quite easy.\nFirst of all, you'll need to install *zip*, as it's not installed by default: `sudo apt install zip`.\nThen, you can go to the following page: https://github.com/SpintroniK/exadrums-data/tree/TD-4KP and follow the instructions.\n\nObviously, the project is still under development and future versions will support more inputs, and have a lot of improvements.\nThe official documentation is far from being complete, but I'll make sure to add guidelines to help install the latest version of exadrums on a Raspberry Pi. I will make sure the future versions work on the current version of Raspberry Pi OS *bullseye*. Stay tuned, new versions are coming!\n",
            "url": "https://news.exadrums.com/article/raspberry-pi-os-bullseye",
            "title": "Raspberry Pi OS - Bullseye",
            "summary": "Remember this article about exadrums becoming an official Debian package?\nIt's now time to play (exa)drums on your Raspberry Pi.\nThe Raspberry Pi Foundation released the latest Raspberry Pi OS bullseye a few days ago, and as you may have guessed, it includes exadrums packages:\n\nNow, you simply have to type sudo apt install exadrums into a terminal to install exadrums on your Raspberry Pi.",
            "date_modified": "2021-11-12T18:07:46.000Z",
            "date_published": "2021-11-12T18:07:46.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/new-arduino-nano-every-board-part5",
            "content_html": "\nThis is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 4](/article/new-arduino-nano-every-board-part4).\n\nAs mentioned in the previous parts, especially the first one, the eXaDrums TB08-SE board can be used together with an Arduino Nano Every and the eXaDrumino Nano Every code to make a MIDI drum module. Here's a picture of the board.\n\n![image](/images/new-arduino-nano-every-board/board.png)\n\nI've been able to test it with my Roland TD17 and it works very well.\nIn particular, it is very impressive to see how much a tiny Arduino Nano Every can do.\nThanks to MIDI, the sound quality is spectacular, and we get multilayer sounds, round-robin, etc. for free by using a VST that handles those things.\nFor my tests, I used [hydrogen](https://hydrogen-music.org/) as a VST. It may not be the best, but it felt like playing with high quality material.\n\n<!--more-->\n\n## Context and Description\n\nThis project is part of the eXaDrums project.\nIt features a new board that allows to connect 8 drum pads to an Arduino Nano Every that, in turns, sends MIDI notes over USB.\nThe board hardware and software are both compatible with eXaDrums, but it can also be used as a standalone device.\n\nThe project name is eXadrumino Nano Every. It is a high performance firmware that allows to read eight analog inputs very fast and send MIDI notes over USB, or via the on-board USART. Using eXaDrums or a PC loaded with a VST, it allows to play drums with a very low latency.\nThe board itself is called *eXaDrums TB08-SE*, and it is compatible with other microcontrollers than the Arduino Nano Every.\n\nHere's a brief reminder of the specs I gave in the first part of this series of articles:\n\n- Works on PC and Raspberry Pi.\n- Up to 7 single-zone pads + 1 hi-hat controller.\n- Compatible with Roland TD-9, TD-11, TD-15, TD-17, TD-25, and TD-27-based edrum kits (DB25 connector).\n- Sample rate greater than 70ksps (kilo samples per second).\n- Nearly 9000 samples per second and per channel (8928 in average).\n- Configurable trigger parameters: threshold, scan time and mask time (1ms step).\n- Configurable MIDI channel and notes.\n\nThe last two are still under development.\n\n## How to Get the Board?\n\nI designed a board and got 5 prototypes PCBs.\nHowever, that board requires some refinements. I would like to make some changes before I share the whole PCB so that it is as good as it can be.\nMeanwhile, you can easily replicate the schematics, as it is a quite simple circuit.\nEvery piezo is wired to a single operational amplifier that acts as a simple amplifier that adds a bias voltage to the signal.\nHere's how it looks:\n\n![Circuit](/images/new-arduino-nano-every-board/Piezo-circuit.png)\n\nThe `Vcc` voltage is taken from the Arduino's 5V `power out` (pin number 12).\nAt the `Vbias` pin, the voltage is 1.65V.\nIt is obtained by using a voltage divider made of two 10k resistors that are wired to the 3.3V `power out` pin of the Arduino (pin number 2).\n\nThe hi-hat controller input is a little different, and simpler.\nIt consists of a single 4.7k resistor wired to the 3.3V pin of the Arduino on one side, and the hi-hat controller as well as the `+` input of voltage follower. It is the same divider for all operational amplifiers.\n\nAnd that's it, you know everything. There are 4 dual operational amplifiers on the board, which makes a total of 8 inputs.\nI got my prototypes from JLCPCB, using their SMT sevice, which means that I received assembled boards, that is, all the components were already soldered, except for the Raspberry Pi GPIO header socket.\nIf you'd like to get you own board, I do recommend JLCPCB, the PCBs are good quality and affordable, the only downside is the shipping cost.\nOr, if you're patient, you can wait until I'm done with improving the board's layout, it shouldn't take too long.\nAgain, I just want to make the best board possible, which will require a few changes.\n\n## Where is the Code?\n\nThe code is freely available at [GitHub](https://github.com/SpintroniK/exadrumino-Nano-Every).\nYou'll find more details as well as instructions that will help you flash the code to your Arduino.\nNote that the code is still a work in progress, some features are not their yet.\nThe most important missing features are those that allow to change trigger and MIDI parameters via the USART, and save those parameters to the on-board EEPROM.\n\n## Previous and Next Parts\n\nSo far there has been 4 parts published in this series of articles. This is the fifth one.\nHere's a reminder of the previous parts and what they talk about:\n\n- [Part 1](/article/new-arduino-nano-every-board-part1): New board specs, and how it works.\n- [Part 2](/article/new-arduino-nano-every-board-part2): Makefile and the way C++ has been used to write the firmware.\n- [Part 3](/article/new-arduino-nano-every-board-part3): Sending serial MIDI notes over USB.\n- [Part 4](/article/new-arduino-nano-every-board-part4): How to use the ADC to make an oscilloscope and read triggers voltages.\n\nThere will be at least two more parts which will deal with the following topics:\n\n- Part 6: How to get an efficient real-time counter.\n- Part 7: How to filter the piezo output signal very fast to make a drum trigger.\n- Part 8: How to read and write values to the on-board EEPROM.\n- Maybe more...\n\nSee you next time!\n",
            "url": "https://news.exadrums.com/article/new-arduino-nano-every-board-part5",
            "title": "New Arduino Nano Every Trigger Board - Part 5",
            "summary": "This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 4.\nAs mentioned in the previous parts, especially the first one, the eXaDrums TB08-SE board can be used together with an Arduino Nano Every and the eXaDrumino Nano Every code to make a MIDI drum module. Here's a picture of the board.\n\nI've been able to test it with my Roland TD17 and it works very well.\nIn particular, it is very impressive to see how much a tiny Arduino Nano Every can do.\nThanks to MIDI, the sound quality is spectacular, and we get multilayer sounds, round-robin, etc. for free by using a VST that handles those things.\nFor my tests, I used hydrogen as a VST. It may not be the best, but it felt like playing with high quality material.",
            "date_modified": "2022-06-15T18:25:57.000Z",
            "date_published": "2022-06-15T18:25:57.000Z"
        },
        {
            "id": "https://news.exadrums.com/article/the-future-of-exadrums",
            "content_html": "\nThe future of exadrums is probably different than what you may think.\n\nSo far, exadrums is a two-part software, there's a library, libexadrums, and another component: the user interface. The whole drum module is in the library, and exposes a C++ API. That means libexadrums can be used with other languages, such as Python, Javascript, etc.\n\n<!--more-->\n\nA C++ user interface has its advantages, but exadrums could benefit from other languages. For instance,  a more \"connected\" experience would be easier to implement in Python or Javascript.\n\nAnd that's how I see the future of exadrums: a Connected Open Source Drum Module. Some things are already in the works, but others will take some time. However, I'll do my best to publish news more frequently, to keep you informed about the project.\n\nAbout that, the project website [exadrums.com](https://exadrums.com) will be online pretty soon! Hope you'll like it.\n",
            "url": "https://news.exadrums.com/article/the-future-of-exadrums",
            "title": "The Future of exadrums",
            "summary": "The future of exadrums is probably different than what you may think.\nSo far, exadrums is a two-part software, there's a library, libexadrums, and another component: the user interface. The whole drum module is in the library, and exposes a C++ API. That means libexadrums can be used with other languages, such as Python, Javascript, etc.",
            "date_modified": "2021-08-25T14:48:20.000Z",
            "date_published": "2021-08-25T14:48:20.000Z"
        }
    ]
}