{
    "version": "https://jsonfeed.org/version/1",
    "title": "exadrums - news",
    "home_page_url": "https://news.exadrums.com/latest.json",
    "description": "eXaDrums project: latest news.",
    "items": [
        {
            "id": "https://news.exadrums.com/article/new-arduino-nano-every-board-part6",
            "content_html": "\nThis is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 5](/article/new-arduino-nano-every-board-part5).\n\nIn this part, we are going to talk about real-time counters.\nIn particular, we'll see advantages of using a relative time reference.\n\nAnd we'll also see how the following figure helps us measure a time difference efficiently using a single byte as our time reference!\n\n![delta](/images/new-arduino-nano-every-board/delta.png)\n\n<!--more-->\n\n## Absolute and Relative Time Reference\n\nThe first important thing that we need to know is that we can't have an absolute time reference.\nBecause our time reference needs to store the time in a variable, it will overflow at some point.\nThat means, an absolute time reference remains absolute as long as the counter variable doesn't overflow.\n\nThis is a major drawback, especially for limited hardware, where incrementing a 32-bit variable can be very expensive.\nAn 8-bit microcontroller such as the ATMega4809 isn't able to increment a 32-bit variable in a single instruction.\nSo, to avoid overflows, we need to either decrease the resolution of our counter, or store its value into a bigger variable.\nBut, this won't prevent the counter from overflowing at some point anyway... So what can we do about that?\n\nHere's an example to illustrate our problem.\nSay we want to increment a counter every microsecond.\nWe are playing drums an hour or two every day, and we'd like our time reference to be absolute.\n\nLet's say we want to store our counter value in a 32-bit integer.\nThat leaves us with 4295 seconds before the counter overflows, which is slightly more than an hour.\nWe have three solutions:\n\n- Use a 64-bit variable, which will cause an overflow after a few billion years.\n- Increase the resolution of our timer to, say 1 ms, so that we get nearly 50 days before the variable overflows.\n- Work with a relative time reference instead of an absolute one.\n\nAll three options work, but we are interested in the latter, as this will allow us to store our count in a 16-bit, possibly a 8-bit variable.\n\nA relative time reference is a single variable that is incremented at regular interval.\nThe only difference with an absolute time reference is that we know it will overflow at some point, and that's not a problem.\n\n## Relative Time Reference\n\n### How it Works\n\nContrary to the absolute time reference, the relative time reference needs to be compared to another variable.\nFor instance, if a drum pad is hit, we get the value of our relative time reference (counter) and memorize it.\nAfter some time, we are going to check how much time has elapsed since we've memorized the time reference value.\n\n### Practical Example\n\nFirst of all, we need to state the requirements for our time reference.\nWe'd like to make a drum module, so the time reference will be used to manage the triggers states.\nThat includes the trig time, scan time, and mask time.\nFor those values, it would be nice to have a resolution of 0.1 or 0.5 ms, something like that.\nHowever, I will choose a step of 1 ms.\nThe main reason for that, is that 0.1 ms is too small and 0.5 ms could lead to confusion...\n\nLet's say we use a 8-bit variable for our counter.\nIt is incremented every millisecond, so it can count from zero to 255 ms.\nAnd it does so continuously until it overflows and goes back to zero.\n\nNow if a drum pad is hit, the trigger registers the current value of the counter.\nImagine that the value of the counter is 42. It is stored in a `trigTime` variable.\nWe set the scan time to 4 ms, which means the scan time will be done when the counter reaches 46.\nThe only thing we need to know is: is the counter greater or equal to 46.\n\nA problem arises if the counter overflows, though.\nLet's say the pad has been hit when the counter's value was 254.\nWe'll know that the scan time is over when the counter's value will be greater or equal to 258.\nBut our 8-bit variable will overflow before that, so we'll get the following sequence: 254, 255, 0, 1, 2, instead of 254, 255, 256, 257, 258.\n\nFortunately, we can do something about that.\nInstead of using unsigned integers, we can use signed integers, but we're going to go over a few other details before we do so.\nWe still use a 8-bit unsigned integer to store our counter's value, so it can go from 0 to 255.\nWe do the same for our scan time variable.\nIn order to determine if we have waited for a longer time than the scan time here's what we need to compute: `const uint8_t delta = trigTime + scanTime - currentTime;`.\n\nSo far, we still use an unsigned integer, but, let's examine precisely what happens with the previous values.\nWe have `trigTime = 254` and `scanTime = 4`.\nHere's what happens if we subtract the `currentTime` variable to the previous value:\n\n1. If `currentTime = 255` we get `delta =  254 + 4 - 255 = 3`.\n2. If `currentTime` overflows, for instance, `currentTime = 1`, we get `delta =  254 + 4 - 1 = 1`.\n3. If `currentTime` overflows, and we've waited longer than the scan time, for instance, `currentTime = 4`, we get `delta = 254 + 4 - 4 = 254`.\n\n### A Little Bit of Theory\n\nNow let's see what happens for a different value of `trigTime`: `trigTime = 120`, and consider a longer scanTime: `scanTime = 100`.\n\n1. If `currentTime = 128` we get `delta =  120 + 100 - 128 = 92`.\n2. If `currentTime` doesn't overflow, for instance, `currentTime = 200`, we get `delta =  120 + 100 - 200 = 20`.\n3. If `currentTime` doesn't overflow, and we've waited longer than the scan time, for instance, `currentTime = 240`, we get `delta = 120 + 100 - 240 = 236`.\n\nWe see something interesting here, for cases 1 and 2, delta remains below 127, but in both cases, point number 3 gives us a value that is above 128.\nThis is understandable, because if `currentTime >= trigTime + scanTime`, `deltat = rigTime + scanTime - currentTime` goes below zero.\nBut with unsigned integers, that means `delta` is now 255 minus something, so we get 254 or 236 in the second third case.\nNotice how the result is the same whether the value overflows or not!\n\nWhat that means is that perhaps we should treat `delta` as a signed integer.\nIt's important to note that, even if we treat `delta` as a signed integer, the underlying binary value of `delta` remains the same.\n\nA signed 8-bit integer goes from -128 to 127. The most significant bit, or MSB, determines the sign.\nIf that bit is set to 1, the value is negative, otherwise, it is positive.\nSo, if we count from zero, the value goes like this: 0, 1, 2, 3, ..., 126, 127, -128, -127, -126, ..., -3, -2, -1.\nWhich is to be compared to a unsigned integer that goes like: 0, 1, 2, 3, ..., 126, 127, 128, 129, 130, ..., 253, 254, 255.\nBoth sequences are different representations of the same binary value.\n\nThis means that `delta` is negative if the elapsed time since the trig time is longer than the scan time.\nBack to our first example, but this time using the signed representation of delta:\n\n1. If `currentTime = 255` we get `delta =  254 + 4 - 255 = 3`.\n2. If `currentTime` overflows, for instance, `currentTime = 2`, we get `delta =  254 + 4 - 2 = 0`.\n3. If `currentTime` overflows, and we've waited longer than the scan time, for instance, `currentTime = 4`, we get `delta = 254 + 4 - 4 = -2`.\n\nWe have the following three cases:\n\n- If we have waited less than the scan time duration, the value is positive.\n- If we have waited exactly the duration of the scan time, the value is zero.\n- If we have waited more than the scan time duration, the value is negative.\n\nLet's visualize what's happening here.\n\n![delta](/images/new-arduino-nano-every-board/delta.png)\n\nThe value of `delta` reaches 0 when the elapsed time since the trig time is exactly the scan time.\nFor an unsigned integer, the next value is 255, and if we cast `delta` to a signed integer, it is -1.\nThere are a few options to detect the transition:\n\n- We could simply test if the unsigned representation of `delta` is greater or equal to 128.\n- We could test the MSB of the unsigned representation of `delta`.\n- Or we could cast `delta` to a signed integer an check if the value is negative.\n\nI like the latter the most because it gives us a useful information for free: the elapsed time since the end of the scan time.\nThat time is equal to `-delta`.\nHowever, there's one thing that I didn't mention: we loose half of the values of our 8-bit integer.\nAll three options above lead to the same result, we can now only measure time differences that go from 0 to 128ms.\n\nIf you'd like a to read a slightly different explanation of this idea, please read the [following article from Lucky Resistor](https://luckyresistor.me/2019/07/10/real-time-counter-and-integer-overflow/).\n\n## Using TCB0 as a Real Time Counter\n\nWe are already using the TCA counter to trigger the ADC conversions, so we are going to use the TCB0 timer/counter instead.\n\n### Configure TCB0 and Handle Interrupts\n\nThe TCB timer/counter can do a lot of things, but we're only going to use it as a counter here.\nFirst of all, we define a class to handle the counters interrupts:\n\n```cpp\nclass TCBInterrupts\n{\n\npublic:\n    TCBInterrupts() = delete;\n    ~TCBInterrupts() = delete;\n\nprivate:\n\n    static void TCB0Overflow() __asm__(\"__vector_12\") __attribute__((__signal__, __used__, __externally_visible__));\n    static void TCB1Overflow() __asm__(\"__vector_13\") __attribute__((__signal__, __used__, __externally_visible__));\n\n};\n```\n\nAnd yes, \"counters\" with an \"s\", as there are 4 TCB timers.\nNote that I implemented the interrupts for TCB0 and TCB1 only.\n\nNow let's add a little helper to choose the right clock for TCB0:\n\n```cpp\nenum class TCBClock\n{\n    Div1,\n    Div2,\n    TCA\n};\n```\n\nWe'll use the same clock as TCA.\nAnd now a class to configure the TCB counters:\n\n```cpp\ntemplate <uint8_t nb>\nclass TCB\n{\n\npublic:\n    TCB() = delete;\n    ~TCB() = delete;\n\n    static constexpr void EnableInterrupts()\n    {\n        tcb().INTCTRL =  TCB_CAPT_bm;\n    }\n\n    static constexpr void ResetInterrupt()\n    {\n        tcb().INTFLAGS |= TCB_CAPT_bm;\n    }\n\n    static constexpr void SetCompareOrCapture(uint16_t value)\n    {\n        tcb().CCMP = value;\n    }\n\n    static constexpr void Enable()\n    {\n        tcb().CTRLA |= TCB_ENABLE_bm;\n    }\n\n    template <TCBClock clock>\n    static constexpr void SetClock()\n    {\n        switch(clock)\n        {\n            case TCBClock::Div1: tcb().CTRLA |= TCB_CLKSEL_CLKDIV1_gc; break;\n            case TCBClock::Div2: tcb().CTRLA |= TCB_CLKSEL_CLKDIV2_gc; break;\n            case TCBClock::TCA: tcb().CTRLA |= TCB_CLKSEL_CLKTCA_gc; break;\n        }\n    }\n\nprivate:\n\n    static constexpr auto& tcb()\n    {\n        switch(nb)\n        {\n            case 0: return TCB0;\n            case 1: return TCB1;\n            case 2: return TCB2;\n            case 3: return TCB3;\n            default: static_assert(nb <= 3, \"Wrong TCB number.\");\n        }\n    }\n\n};\n\n```\n\nThe functions names are self-explanatory.\n\n### A Real-Time Counter\n\nBefore we continue, we need one more ingredient: a counter.\nTo that end, I'll make a class template that will allow to choose the type of variable that the counter uses.\n\n```cpp\ntemplate <typename T>\nclass Counter\n{     \n\npublic:\n\n    Counter() = default;\n    ~Counter() = default;\n\n    constexpr T GetCount()\n    {\n        return count;\n    }\n\n    constexpr void Increment()\n    {\n        ++count;\n    }\n\nprivate:\n\n    T count{};\n};\n```\n\nAnd that's it, now we can add all these niceties to our main function.\n\n```cpp\n\n#include \"Adc.hpp\"\n#include \"Counter.hpp\"\n#include \"TCB.hpp\"\n\n#include <avr/io.h>\n#include <avr/interrupt.h>\n\nusing Adc0 = Adc<Adc0Addr, Adc8bitType>;\nusing Tcb = TCB<0>;\n\nCounter<uint8_t> clock{};\n\nvoid Analog::AdcInterrupts::ResReady()\n{\n    Adc0::ResetInterrupt();\n    trigger.Process(ADC0.RES, clock.GetCount());\n}\n\nvoid Timing::TCBInterrupts::TCB0Overflow()\n{\n    Tcb::ResetInterrupt();\n    clock.Increment();\n}\n\nint main()\n{\n\n    while(1)\n    {\n        ;\n    }\n\n    return 0;\n}\n\n```\n\nWe use the relative time reference in the ADC interrupt, so that we know how much time has elapsed since we've received the previous samples.\nIn this interrupt there's a `trigger.Process()` function.\nIt is the function that will process the ADC data, together with the time reference, to compute the trigger state.\nHere's an example that shows how this function can use the relative time reference:\n\n```cpp\nvoid Trigger::Process(uint8_t data, uint8_t time) const\n{\n    // [...]\n\n    const uint8_t delta = this->trigTime + this->scanTime - time;\n\n    if(static_cast<int8_t>(delta) <= 0)\n    {\n        // ...\n    }\n\n    // [...]\n}\n```\n\nAt some point in time, the ADC value exceeds a certain threshold, which in turn, puts the trigger in scan state.\nThe trigger remains in that state for `scanTime` milliseconds.\nDuring that time, the peak value of the signal is computed.\n\nThe question we answer here is: how do we know when the scan time is over?\nAnd the answer is simple: we check whether the signed representation of `delta` is positive or negative.\nAs soon as it becomes a negative value, we know that the scan time is over and we're done computing the signal's peak value.\nThus, we can go on and put the trigger in its next state, etc.\n\nThere we are, with a single byte we get a relative time reference that we can use to measure delays from 1 to 128 ms.\nWe don't need it to be an absolute time reference as long as we use a variable to memorize the start of the delay (`trigTime`).\nUsing this method, we can measure as many delays as we want as long they remain under 128 ms, and that we use a byte for each delay to memorize the when it starts.\nOf course this also works if we use a 16-bit variable (or even bigger), it is just faster to use a 8-bit variable on a 8-bit CPU.\n\n## What's Next?\n\nNext time we'll talk about signal processing.\nIn particular, we will see how to make a high-pass filter that performs well with a 8-bit microcontroller.\n\nSee you next time!\n",
            "url": "https://news.exadrums.com/article/new-arduino-nano-every-board-part6",
            "title": "New Arduino Nano Every Trigger Board - Part 6",
            "summary": "This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 5.\nIn this part, we are going to talk about real-time counters.\nIn particular, we'll see advantages of using a relative time reference.\nAnd we'll also see how the following figure helps us measure a time difference efficiently using a single byte as our time reference!\n",
            "date_modified": "2022-07-05T16:11:31.000Z",
            "date_published": "2022-07-05T16:11:31.000Z"
        }
    ]
}