{
    "version": "https://jsonfeed.org/version/1",
    "title": "exadrums - news",
    "home_page_url": "https://news.exadrums.com/latest.json",
    "description": "eXaDrums project: latest news.",
    "items": [
        {
            "id": "https://news.exadrums.com/article/new-arduino-nano-every-board-part2",
            "content_html": "\nThis is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 1](/article/new-arduino-nano-every-board-part1).\nIn this part, I'm going to describe how to compile C++ code and upload it to the Arduino Nano Every without using the Arduino library.\n\nBut why would one want to do that, you may ask?\nThe answer is simple: the Arduino library does a lot of things that may impact performance.\nFor instance, some interrupts are being fired frequently, and slow things down.\n\nLet's be honest, we're not going to reinvent the wheel, most of what we are going to do here is to use the Arduino IDE's compiler and tools.\nSay we install the Arduino IDE (version 1.8.9) and compile a program.\nHere's what we're going to see:\n\n![image](/images/new-arduino-nano-every-board/arduino-ide.png)\n\nThe interesting part is the console, where all the compilation-related messages are shown.\nWe see that the IDE uses avr-gcc version 7.3.0, along with a few other tools.\nLet's see what we can do with that.\n\n<!--more-->\n\nFirst of all, we can see *where* all these tools are located.\nA little digging reveals that an environment variable named *AVR_TOOLS_DIR* contains the tools folder location.\nThus, we can type the following: `$AVR_TOOLS_DIR/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin/avr-gcc --version` and execute the command in a terminal.\nThis will print the avr-gcc version.\n\n## Makefile for the Arduino Nano Every\n\nThis is not a tutorial about makefiles, if you want an in-depth tutorial about makefiles, please read the official [GNU Make Manual](https://www.gnu.org/software/make/manual/).\nWith that out of the way, let's write a makefile.\n\n### Variables\n\nFirst of all, we need to define some variables.\nHaving the avr-gcc bin directory as variable seems like a good idea, so we define the following: `BIN_DIR?=${AVR_TOOLS_DIR}/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin`.\nYour bin directory may differ, so be sure to check its correct location.\nThat's the only variable we'll need for the compiling process.\n\nThere's one more thing that we need in order to upload the compiled program to the Arduino, though.\nThis thing is avrdude.\nIt's a little bit trickier, as we need the avrdude executable and a configuration file.\nSo here are our variables:\n\n```makefile\nAVRDUDE_DIR?=${AVR_TOOLS_DIR}/avrdude/6.3.0-arduino17/\nAVRDUDE?=${AVRDUDE_DIR}/bin/avrdude\nCONFDIR?=${AVRDUDE_DIR}/etc/avrdude.conf\n```\n\nAgain, be sure to check the the executable path.\nIf you want to provide your own configuration file, you can use the following (sorry, it isn't a short snippet...):\n\n```ini\n\n#------------------------------------------------------------\n# AVR8X family common values\n#------------------------------------------------------------\n\npart\n    id        = \".avr8x\";\n    desc    = \"AVR8X family common values\";\n    has_updi    = yes;\n    nvm_base    = 0x1000;\n    ocd_base    = 0x0F80;\n\n    memory \"signature\"\n        size        = 3;\n        offset        = 0x1100;\n    ;\n\n    memory \"prodsig\"\n        size        = 0x3D;\n        offset        = 0x1103;\n        page_size    = 0x3D;\n        readsize    = 0x3D;\n    ;\n\n    memory \"fuses\"\n        size        = 9;\n        offset        = 0x1280;\n    ;\n\n    memory \"fuse0\"\n        size        = 1;\n        offset        = 0x1280;\n    ;\n\n    memory \"fuse1\"\n        size        = 1;\n        offset        = 0x1281;\n    ;\n\n    memory \"fuse2\"\n        size        = 1;\n        offset        = 0x1282;\n    ;\n\n    memory \"fuse4\"\n        size        = 1;\n        offset        = 0x1284;\n    ;\n\n    memory \"fuse5\"\n        size        = 1;\n        offset        = 0x1285;\n    ;\n\n    memory \"fuse6\"\n        size        = 1;\n        offset        = 0x1286;\n    ;\n\n    memory \"fuse7\"\n        size        = 1;\n        offset        = 0x1287;\n    ;\n\n    memory \"fuse8\"\n        size        = 1;\n        offset        = 0x1288;\n    ;\n\n    memory \"lock\"\n        size        = 1;\n        offset        = 0x128a;\n    ;\n\n    memory \"data\"\n        # SRAM, only used to supply the offset\n        offset        = 0x1000000;\n    ;\n;\n\n\n#------------------------------------------------------------\n# AVR8X mega family common values\n#------------------------------------------------------------\n\npart parent    \".avr8x\"\n    id            = \".avr8x_mega\";\n    desc        = \"AVR8X mega family common values\";\n    family_id    = \"megaAVR\";\n\n    memory \"usersig\"\n        size        = 0x40;\n        offset        = 0x1300;\n        page_size    = 0x40;\n        readsize    = 0x100;\n    ;\n;\n\n#------------------------------------------------------------\n# ATmega4809\n#------------------------------------------------------------\n\npart parent    \".avr8x_mega\"\n    id        = \"m4809\";\n    desc      = \"ATmega4809\";\n    signature = 0x1E 0x96 0x51;\n\n    memory \"flash\"\n        size      = 0xC000;\n        offset    = 0x4000;\n        page_size = 0x80;\n        readsize  = 0x100;\n    ;\n\n    memory \"eeprom\"\n        size      = 0x100;\n        offset    = 0x1400;\n        page_size = 0x40;\n        readsize  = 0x100;\n    ;\n;\n\nprogrammer\n  id    = \"jtag2updi\";\n  desc  = \"JTAGv2 to UPDI bridge\";\n  type  = \"jtagmkii_pdi\";\n  connection_type = serial;\n  baudrate = 115200;\n;\n\n```\n\nAnd the last variable that we need is the Arduino serial port: `PORT?=/dev/ttyACM0`.\nYou can find that information in the Arduino IDE (in the *tools* menu).\n\n### Rules\n\nNow that we have defined all the variables that we need, we have to create some rules to compile and upload our code to the Arduino.\nTo that end, we are going to have three rules: `all`, to compile the code, `upload`, to upload the binary to the board, and `clean` to remove all the build files.\n\nLet's start with the `all` rule:\n\n```makefile\nall:\n    ${BIN_DIR}/avr-g++ -c -g -Os -w -std=c++17 -fpermissive -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -Wno-error=narrowing -MMD -flto -mmcu=atmega4809 -DF_CPU=16000000L -DARDUINO=10809 -DARDUINO_AVR_NANO_EVERY main.cpp -o main.o\n    ${BIN_DIR}/avr-g++ -w -Os -g -flto -fuse-linker-plugin -Wl,--gc-sections -Wl,--section-start=.text=0x0 -mmcu=atmega4809 -o main.elf main.o\n    ${BIN_DIR}/avr-objcopy -O binary -R .eeprom main.elf main.bin\n    ${BIN_DIR}/avr-objcopy -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 main.elf main.eep\n    ${BIN_DIR}/avr-objcopy -O ihex -R .eeprom main.elf main.hex\n    ${BIN_DIR}/avr-size -C main.elf\n```\n\nThis mostly comes from the Arduino IDE's console output window.\nI've made only very small modifications.\nThe `upload` rule is also taken from the Arduino IDE:\n\n```makefile\nupload:\n    python3 ./reset.py ${PORT}\n    ${AVRDUDE} -C${CONFDIR} -v -patmega4809 -cjtag2updi -P${PORT} -b115200 -e -D -Uflash:w:main.hex:i -Ufuse2:w:0x01:m -Ufuse5:w:0xC9:m -Ufuse8:w:0x00:m\n```\n\nThere is one subtle thing here.\nIf we check the Arduino IDE's console output, we can read the following message: `Forcing reset using 1200 bps open/close on port /dev/ttyACM0`.\nThis means that we need to reset the Arduino before avrdude starts uploading the program.\nI found that the more reliable way to do that is to use a little python3 script:\n\n```python\n#!/usr/bin/python\n\nimport sys\nimport serial\n\ncom = serial.Serial(sys.argv[1], 1200)\ncom.dtr=False\ncom.close()\n```\n\nFinally, we need a `clean` rule that removes all the compiled files.\nThis is a pretty easy rule to write, so I'll just throw the whole makefile there:\n\n```makefile\nBIN_DIR?=${AVR_TOOLS_DIR}/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin\nAVRDUDE_DIR?=${AVR_TOOLS_DIR}/avrdude/6.3.0-arduino17/\nAVRDUDE?=${AVRDUDE_DIR}/bin/avrdude\nCONFDIR?=${AVRDUDE_DIR}/etc/avrdude.conf\n\nPORT?=/dev/ttyACM0\n\nall:\n    ${BIN_DIR}/avr-g++ -c -g -Os -w -std=c++17 -fpermissive -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -Wno-error=narrowing -MMD -flto -mmcu=atmega4809 -DF_CPU=16000000L -DARDUINO=10809 -DARDUINO_AVR_NANO_EVERY main.cpp -o main.o\n    ${BIN_DIR}/avr-g++ -w -Os -g -flto -fuse-linker-plugin -Wl,--gc-sections -Wl,--section-start=.text=0x0 -mmcu=atmega4809 -o main.elf main.o\n    ${BIN_DIR}/avr-objcopy -O binary -R .eeprom main.elf main.bin\n    ${BIN_DIR}/avr-objcopy -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 main.elf main.eep\n    ${BIN_DIR}/avr-objcopy -O ihex -R .eeprom main.elf main.hex\n    ${BIN_DIR}/avr-size -C main.elf\n\n\nupload:\n    python3 ./reset.py ${PORT}\n    ${AVRDUDE} -C${CONFDIR} -v -patmega4809 -cjtag2updi -P${PORT} -b115200 -e -D -Uflash:w:main.hex:i -Ufuse2:w:0x01:m -Ufuse5:w:0xC9:m -Ufuse8:w:0x00:m\n\n\nclean:\n    rm -f main.bin main.d main.eep main.elf main.hex main.o\n```\n\nThere we are, all that's left is to put this in a `Makefile`file.\nNow we can type `make` to compile the code and `make upload` to upload it to the board.\n\n## Example: Blink the On-board LED\n\nWe are going to go through a very simple example: the LED blink example.\n\n### Arduino Version\n\nHere's the Arduino code for the LED blink example:\n\n```cpp\nconst int ledPin = 13;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(ledPin, HIGH);   // set the LED on\n  delay(1000);                  // wait for a second\n  digitalWrite(ledPin, LOW);    // set the LED off\n  delay(1000);                  // wait for a second\n}\n```\n\nUsing the Arduino IDE to compile this code, we get the following message:\n\n```text\nSketch uses 1118 bytes (2%) of program storage space. Maximum is 49152 bytes.\nGlobal variables use 22 bytes (0%) of dynamic memory, leaving 6122 bytes for local variables. Maximum is 6144 bytes.\n```\n\nSo, in order to make a LED blink every second, we need 1118 bytes of program space, and 22 bytes of RAM.\nTo me, that sounds like a lot!\n\n### C Version\n\nNow let's go low-level and see what we can do without using the Arduino library.\nSince we're using a C++ compiler, it's not really C code, but it looks like it is:\n\n```cpp\n#include <avr/io.h>\n#include <util/delay.h>\n\nint main()\n{\n    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler\n\n    PORTE.DIRSET |= PIN2_bm;\n\n    for(;;)\n    {\n        _delay_ms(1000);\n        PORTE.OUTTGL |= PIN2_bm;\n    }\n\n    return 0;\n}\n```\n\nThe first line of the main function is used to disable the prescaler, which ensures that the CPU runs at the wanted 16MHz frequency.\nIf you check out the Arduino Nano Every connector pinouts, you'll see that the on-board LED is connected to `D13`.\nThis pin is also labeled `SCK` and `PE2`.\nThe latter tells us that this particular pin is wired to port E, pin 2.\nAnd that's all we need for our LED blink example.\nFirst we use the `DIRSET` register of port E to set the pin 2 bit, which will set pin 2 as an output.\nThen, in the main for loop, we write the pin 2 bit into the `OUTTGL` register, which toggles the state of pin 2.\nIn between each toggling, we use the `_delay_ms` function, which allows us to wait for a given time.\n\nThe ports registers and pins definitions are provided by the `avr/io.h` header which contains everything we need.\nBecause we passed the `-mmcu=atmega4809` flag to avr-gcc in our makefile, it knows that we are using an ATMega4809.\nThe `_delay_ms` function comes from `util/delay.h`, it needs to know the CPU clock frequency, which why we passed to avr-gcc using `-DF_CPU=16000000L`.\n\nThis program does the same thing as the previous one, except it uses a lot less memory and needs no RAM:\n\n```text\nAVR Memory Usage\n----------------\nDevice: Unknown\n\nProgram:     238 bytes\n(.text + .data + .bootloader)\n\nData:          0 bytes\n(.data + .bss + .noinit)\n```\n\n### C++ Version\n\nOkay, so I'm not a big fan of C, and I wonder if we could make this code more readable.\nI would like to be able to write something like `led.Toggle()` instead of `PORTE.OUTTGL |= PIN2_bm`.\n\nIn order to be as generic as possible, we are going to define a class that allows pin manipulation.\nOne more thing: I really don't like pointers, so we are going to try to avoid them at all cost.\n\nFirst of all, we need to know how `PORTE` is defined.\nIts definition lies in the `avr/include/avr/iom4809.h` file: `#define PORTE                (*(PORT_t *) 0x0480) /* I/O Ports */`, where `PORT_t` is a big struct with a bunch of `register_t` in it.\nFort instance, `OUTTGL` and `DIRSET` are in that struct.\nAnd here's where it gets kind of ugly: `typedef volatile uint8_t register8_t;`.\nEvery `register8_t` is declared as volatile, which makes sense because our LED blink wouldn't work otherwise (the compiler would optimize away the `PORTE.OUTTGL |= PIN2_bm` line).\n\nSo, the first thing that we need, is the address of `PORTE`.\nBecause of that `volatile` keyword, we can't use `constexpr` nor `static_cast`, so we are going to define it as: `static const auto PORTE_ADDR = reinterpret_cast<uint16_t>(&PORTE);`.\nNote that this is a 16-bit address\n\nNow we define a pin as a port and a pin number.\nIn our case: port E (its address) and pin 2 (its bit mask).\nThese two things are known at compile time, so we can use them as template parameters.\nHence, we are going to define a `Pin` class that take these two parameters as template parameters:\n\n```cpp\nnamespace DigitalIO\n{\n\n    static const auto PORTE_ADDR = reinterpret_cast<uint16_t>(&PORTE);\n\n    template <uint16_t portAddr, uint8_t mask>\n    class Pin\n    {\n    public:\n        Pin() = delete;\n        ~Pin() = delete;\n\n        static constexpr void ConfigureAsInput()\n        {\n            port().DIRSET &= ~mask;\n        }\n\n        static constexpr void ConfigureAsOutput()\n        {\n            port().DIRSET |= mask;\n        }\n\n        static constexpr void Toggle()\n        {\n            port().OUTTGL |= mask;\n        }\n\n        static constexpr void SetHigh()\n        {\n            port().OUTSET |= mask;\n        }\n\n        static constexpr void SetLow()\n        {\n            port().OUTCLR |= mask;\n        }\n\n        static constexpr auto& port()\n        {\n            return *reinterpret_cast<PORT_t*>(portAddr);\n        }\n        \n    private:\n\n    };\n    \n} // namespace IO\n```\n\nWe need to cast the port address back to a `PORT_t` struct, which is the role of the `port()` function.\nThe rest of the code is pretty straightforward, we encapsulate our C code into `static` methods.\n\nHere's how to use this code:\n\n```cpp\n#include \"DigitalIO.h\"\n\n#include <avr/io.h>\n#include <util/delay.h>\n\n#include <stdint.h>\n\nusing Led = DigitalIO::Pin<DigitalIO::PORTE_ADDR, PIN2_bm>;\n\nint main()\n{\n    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler\n\n    Led::ConfigureAsOutput();\n\n    for(;;)\n    {\n        _delay_ms(1000);\n        Led::Toggle();\n    }\n\n    return 0;\n}\n```\n\nIt looks almost the same as the previous code, except that it's a bit more readable.\n\nBut we did add quite a bit of boilerplate code in our `DigitalIO.h` file, is that a good idea?\nI believe it is. Right now, we don't see how this can be very useful because our program is small and basic.\nWith a bigger code base, I think it would be way easier to understand our code with a well-structured C++ program.\n\nBut wait a minute, isn't all that code going to add more bytes to our program?\nLet's check that, shall we?\n\n```text\nAVR Memory Usage\n----------------\nDevice: Unknown\n\nProgram:     238 bytes\n(.text + .data + .bootloader)\n\nData:          0 bytes\n(.data + .bss + .noinit)\n```\n\nIt doesn't. In fact the assembly code is exactly the same as the previous one.\nWhy is that? Because gcc is awesome, of course!\nSo, we can write C++ code and get the same assembly code as a C program, that's what we call *zero cost abstraction*.\n\n## What's Next?\n\nOkay, so we've seen how to program an Arduino Nano Every without using the Arduino library.\nThrough a very simple example, we've also seen that C and C++ code lead to the same assembly code.\n\nIn the next part, we will focus on MIDI and see how we can turn our Arduino Nano Every into a MIDI device.\n",
            "url": "https://news.exadrums.com/article/new-arduino-nano-every-board-part2",
            "title": "New Arduino Nano Every Trigger Board - Part 2",
            "summary": "This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 1.\nIn this part, I'm going to describe how to compile C++ code and upload it to the Arduino Nano Every without using the Arduino library.\nBut why would one want to do that, you may ask?\nThe answer is simple: the Arduino library does a lot of things that may impact performance.\nFor instance, some interrupts are being fired frequently, and slow things down.\nLet's be honest, we're not going to reinvent the wheel, most of what we are going to do here is to use the Arduino IDE's compiler and tools.\nSay we install the Arduino IDE (version 1.8.9) and compile a program.\nHere's what we're going to see:\n\nThe interesting part is the console, where all the compilation-related messages are shown.\nWe see that the IDE uses avr-gcc version 7.3.0, along with a few other tools.\nLet's see what we can do with that.",
            "date_modified": "2022-05-08T15:42:25.000Z",
            "date_published": "2022-05-08T15:42:25.000Z"
        }
    ]
}