{
    "version": "https://jsonfeed.org/version/1",
    "title": "exadrums - news",
    "home_page_url": "https://news.exadrums.com/latest.json",
    "description": "eXaDrums project: latest news.",
    "items": [
        {
            "id": "https://news.exadrums.com/article/new-arduino-nano-every-board-part3",
            "content_html": "\nThis is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 2](/article/new-arduino-nano-every-board-part2).\n\nIn this part, we are going send MIDI notes over USB using the Arduino Nano Every.\nTo understand everything correctly, make sure you read the previous parts.\n\n♬ ♪ ♬ ♪\n\n<!--more-->\n\n## MIDI Protocol for a Basic Drum Module\n\nFirst, we are going to talk about MIDI and what it actually is at the \"hardware\" level.\nI'll be honest, I probably know only the basis of MIDI.\nHowever, I believe I know enough to make a drum module that sends MIDI notes and messages.\n\nFor a basic drum module, we'll need two MIDI ingredients: notes and control change.\nMIDI is old, so most messages are represented by bytes, that is values that can go from 0 to 255, or -128 to 127 if you represent byte as signed integers using two's complement.\nBut there's a catch, MIDI doesn't always use 8-bit data, rather, some parameters use 7-bit data, so their values go from 0 to 127.\nThat means, there are 128 MIDI notes.\n\nSo what is a MIDI (drum) note exactly?\nWell, drums are a bit different than other instruments in a sense that there aren't actual notes per say.\nThere is one thing called *Universal General MIDI Drum Notes* that saves us, though.\nIt defines more than 40 \"notes\" (from note 35 to 81) that [represent drum instruments](https://www.zendrum.com/resource-site/drumnotes.htm).\nHere are some examples: 35 is *Acoustic Bass Drum*, 38 is *Acoustic Snare*, 70 is *Maracas*, and 81 is *Open Triangle*.\n\n### MIDI Commands\n\nIn practice, MIDI notes are sent using commands. There are two note commands: *Note On* and *Note Off*.\nAs the names suggest, the former tells the instrument to play a note, and the latter says that we need to stop playing that note.\nA command, such as *Note On*, is represented by a byte.\nThis byte is divided into two distinct parts: the command itself, and the MIDI channel.\nThere are 16 MIDI channels, so in theory you can send 16 *Note On* commands over the 16 available channels.\n\nThe way it works is that the command byte is cut in half. The most significant bits represent the command, and the least significant bits represent the channel number.\nHere's an example. We would like to send a *Note On* command over channel 0.\nThe command number for *Note On* is 144, so we simply send a byte that holds the value 144, easy.\nBut, in MIDI, drums use channel 10, so how do we send a note over channel 10?\n\nTo answer that question, we are going to use hexadecimal values instead of decimal.\nThe *Note On* command for channel 0 is 144, which becomes `0x90` in hexadecimal.\nChannel number 10, becomes channel number `0x0A`, so a *Note On* command over channel 10 is `0x9A`.\nBy the way `0x9A` is 154 in decimal, so that's just `144 + 10`, which is the *Note On* command *plus* the channel number.\n\n### Drum Notes\n\nNow, we know how to send a *Note On* command. It is quite simple, as only one byte needs to be sent.\nThis byte value is `0x9A` in hexadecimal if we use channel 10.\n\nIf a MIDI instrument were to received that command, it would need to know which note to play.\nThis is why the *Note On* command must be followed by the note number.\nLets say we want a snare drum sound, we need to send `0x9A` followed by 38, or `0x26`.\n\nAnd that's it. If an instrument receives those two bytes one after another it will know that it should play a snare drum note.\nBut it won't, because there's still one thing that's missing here: the velocity.\n\n### Note Velocity\n\nIt would be no fun at all if all the notes had the same velocity.\nThat's why a third byte follows the MIDI command and MIDI note number, and that third byte represents the velocity.\nThe velocity goes from 0 to 127 (yes it uses only 7 bits).\n\nFinally, to send a snare drum note with a velocity of 92, we have to send 3 bytes: `154, 38, 92` or, in hexadecimal: `0x9A, 0x26, 0x5C`.\n\n### Baud Rate & Latency\n\nYou probably think that sending only 3 bytes must be very fast, but is it really that fast?\nMIDI communications usually happen at 38400 bauds per second.\nThe actual speed in bytes per seconds is 38400 divided by 8, which gives 4800 Bps.\nSay we send 3 bytes per note, that gives us 1600 notes per second, or 0.625 milliseconds (ms) to send a note.\nThat may not seem like a lot, and it isn't really a lot, but that's getting close to 1 ms.\n\nDo we really have to stick with 38400 bps?\nI believe we don't, but it depends on the VST (Virtual Studio Technology) you use.\nNow, if we use a baud rate of 115200 bps, we get 14400 Bps, so 4800 notes per second.\nThat means we're sending one note in nearly 0.2 ms. That's a bit better.\n\n### Control Change\n\nOkay, it's quite easy to understand what a note is, but perhaps we need a little bit more than that.\nWith MIDI notes, we can have a drum kit that's made of pads.\nEvery time we hit a pad, we send a note whose velocity is proportional to the pad's volume.\nWe can have drums and cymbals, but how do we deal with the hi-hat controller?\n\nWe could vary the note number according to the pedal's openness.\nAfter all, there are two notes dedicated to the hi-hat: 42 is *Closed Hi-Hat* and 46 *Open Hi-Hat*, and some VSTs also define a *Semi-Open Hi-Hat* note.\nThat's a totally fine thing to do, but there's a better solution: control change.\n\nControl change may seem more complicated than note commands, but it really is based on the same principle: send 3 bytes.\nThe first byte is the command byte, and it is 176 or `0xB0` in hexadecimal.\nAs for the notes, it has to be combined with the channel number.\nSo for channel 10, we get 186 or `0xBA`.\n\nThe second byte represents the control function. It can be a modulation wheel, a foot controller, an expression controller, etc.\nThere are 128 possible control functions, but some of them are undefined.\nFor the hi-hat controller, the one we are interested in is the *foot controller*, so control function number 4.\nThe second byte is 4, `0x04`.\n\nNow the third byte is the value the control function should take.\nJust like the velocity, this value goes from 0 to 127.\n\nIf the hi-hat pedal is half-open, we send the following three bytes: `186, 4, 63`, or `0xBA, 0x04, 0x3F`.\nAt least that what we send when a control change message needs to be sent. But when do we send a control change exactly?\n\nTwo options come to mind: when the sensor register a change that's big enough to be perceptible, or at regular time interval.\nWe'll go for the former, as there's no reason to send a control change if there's no change in the sensor value.\n\n## Serial MIDI Over USB\n\nSo far we've talked about MIDI as bytes we send to a device, but we need to address how we send those bytes.\n\n### The Hard Truth About the ATMega4809\n\nThe ATMega4809 has 4 USART (universal synchronous and asynchronous receiver-transmitter) preipherals.\nOne of them is accessible via the Arduino Nano Every board pins `RX` and `TX`, and the other one is hardwired to another microcontroller that's on the board: the SAMD11D14A.\n\nWhy is there another microcontroller on the board? Here's what the official documentation has to say:\n\n```text\nThe SAMD11D14A processor is shipped with a firmware that implements USB to serial bridge and handles\nATMega4809 firmware upgrade through the UPDI interface.\n```\n\nThe ATMega4809 doesn't support the USB protocol, so another microcontroller handles that instead.\nIt acts as a USB to serial bridge, and is connected to one of the ATMega4809's USART peripherals.\nSo when you use `Serial.println` in your Arduino IDE, the data goes from your Arduino USART numnber 3 to the SAMD11D14A which sends it over USB to you PC.\n\nAs a consequence, the Arduino Nano Every can't be recognized as a USB device, so no USB MIDI!\n\n### How to Send MIDI Notes to a Computer\n\nAll hope is not lost, we can send MIDI data over USB, the catch is that we can't use the USB protocol.\nInstead we can transfer serial data directly, which has one advantage: the code is simpler to write!\nThere are two options: we can use a serial to USB adapter and connect our Arduino (using two resistors) to it.\nOr we can use the on-board USB and convert the serial data adequately on the target PC.\n\nWe are going to go for option number two, as we'd prefer not to rely on additional hardware.\nThe way it works is pretty straightforward, we are just going to send our bytes over the USART3.\n\n## ATMega4809 USART & MIDI\n\nHere we are, ready to write some code.\nIn order to send the notes over USB, we need to use USART3.\nThe ATMega4809's documentation tells us a few things:\n\n- We need to set the USART pins as output (TX) and input (RX).\n- Then, we have to configure the USART (especially its baud rate).\n- Only after the USART's been configured, we can use its registers to send and receive data.\n\nWe are going to need to configure PORTB (please refer to [part 2 of this series](/article/new-arduino-nano-every-board-part2) for more info).\nTo that end, we use the following code:\n\n```cpp\n\n#include <avr/io.h>\n\n#include <stdint.h>\n\nnamespace DigitalIO\n{\n    \n    static const auto PORTA_ADDR = reinterpret_cast<uint16_t>(&PORTA); \n    static const auto PORTB_ADDR = reinterpret_cast<uint16_t>(&PORTB); \n    static const auto PORTC_ADDR = reinterpret_cast<uint16_t>(&PORTC); \n    static const auto PORTD_ADDR = reinterpret_cast<uint16_t>(&PORTD); \n    static const auto PORTE_ADDR = reinterpret_cast<uint16_t>(&PORTE);\n    static const auto PORTF_ADDR = reinterpret_cast<uint16_t>(&PORTF);\n\n\n    template <uint16_t portAddr, uint8_t mask>\n    class Pin\n    {\n    public:\n        Pin() = delete;\n        ~Pin() = delete;\n\n        static constexpr void ConfigureAsInput()\n        {\n            port().DIRSET &= ~mask;\n        }\n\n        static constexpr void ConfigureAsOutput()\n        {\n            port().DIRSET |= mask;\n        }\n\n        static constexpr void Toggle()\n        {\n            port().OUTTGL |= mask;\n        }\n\n        static constexpr void SetHigh()\n        {\n            port().OUTSET |= mask;\n        }\n\n        static constexpr void SetLow()\n        {\n            port().OUTCLR |= mask;\n        }\n\n        static constexpr auto& port()\n        {\n            return *reinterpret_cast<PORT_t*>(portAddr);\n        }\n        \n    private:\n\n    };\n    \n} // namespace IO\n```\n\nNow we need to configure the USART. I'll give the code for USART3 only, feel free to improve it to handle other USARTs if you wish.\n\n```cpp\n#include \"Pin.hpp\"\n#include \"Port.hpp\"\n\n#include <avr/io.h>\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\nnamespace DigitalIO\n{\n\n    template <uint8_t N>\n    class Usart\n    {\n    public:\n\n    constexpr explicit Usart(uint32_t br)\n    {\n        switch(N)\n        {\n            // TODO: configure Usart 0 to 2\n            case 3: \n            {    \n                PORTMUX.USARTROUTEA |= PORTMUX_USART30_bm;\n                using Usart3InputPin = Pin<PORTB_ADDR, PIN5_bm>;\n                using Usart3OutputPin = Pin<PORTB_ADDR, PIN4_bm>;\n\n                Usart3InputPin::ConfigureAsInput();\n                Usart3OutputPin::ConfigureAsOutput();\n                \n                break;\n            }\n            default: static_assert(N <= 3, \"Invalid USART number.\"); break;\n        }\n\n        usart().BAUD = BaudRate(br);\n        usart().CTRLB |= USART_RXEN_bm | USART_TXEN_bm; \n        usart().CTRLC |= USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc;\n    }\n\n    constexpr void SendByte(uint8_t c)\n    {\n        while(!(usart().STATUS & USART_DREIF_bm))\n        {\n            ;\n        }        \n        usart().TXDATAL = c;\n    }\n\n    static constexpr uint16_t BaudRate(uint32_t baudRate)\n    {\n        return static_cast<uint16_t>(static_cast<float>((F_CPU * 64 / (16 * static_cast<float>(baudRate))) + 0.5));\n    }\n\n    static constexpr USART_t& usart()\n    {\n        switch(N)\n        {\n            case 0: return USART0;\n            case 1: return USART1;\n            case 2: return USART2;\n            case 3: return USART3;\n            default: static_assert(N <= 3, \"Invalid USART number.\");\n        }\n    }\n\n    private:\n\n    };\n\n} // namespace IO\n```\n\nYou'll notice that there is a `SendByte` function.\nThat's all we need to send MIDI notes, as we need to send 3 bytes for each `Note On` command.\n\n## Sending MIDI Over USART\n\nAll right, lets wring some code that sends MIDI notes.\nWe are going to use one more little helper:\n\n```cpp\n#include \"DigitalIO/Usart.hpp\"\n\ntemplate <typename Usart>   \nclass SerialMidi\n{\n\npublic:\n\n    SerialMidi() = delete;\n    ~SerialMidi() = default;\n\n    SerialMidi(Usart& usart) : usart_{usart}\n    {\n\n    }\n\n    template <uint8_t channel>\n    inline void NoteOn(uint8_t note, uint8_t velocity) const noexcept\n    {\n        usart_.SendByte(0x90 | (channel & 0x0f));\n        usart_.SendByte(note);\n        usart_.SendByte(velocity);\n    }\n\n    template <uint8_t channel, uint8_t control>\n    inline void ControlChange(uint8_t value) const noexcept\n    {\n        static_assert(control <= 127, \"Invalid control value.\");\n        usart_.SendByte(0xB0 | (channel & 0x0f));\n        usart_.SendByte(control);\n        usart_.SendByte(value);\n    }\n\n\nprivate:\n\n    Usart& usart_;\n\n};\n```\n\nEven if we are not going to use it, I included the `ControlChange` function.\n\n```cpp\n#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <util/delay.h>\n\nusing Usart3 = DigitalIO::Usart<3>;\n\nstatic Usart3 usart{115'200};\nstatic SerialMidi midi{usart};\n\nint main()\n{\n    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler\n\n    sei();\n\n    const uint8_t snareNote = 38;\n    const uint8_t bdNote = 36;\n    const uint8_t hhNote = 42;\n\n    const uint8_t nbNotes = 8;\n    const uint8_t snareNotes[nbNotes] =    {0, 0, 1, 0, 0, 0, 1, 0};\n    const uint8_t hihatNotes[nbNotes] =    {1, 1, 1, 1, 1, 1, 1, 1};\n    const uint8_t bassDrumNotes[nbNotes] = {1, 0, 0, 0, 1, 1, 0, 0};\n\n    uint8_t i = 0;\n\n    for(;;)\n    {\n        _delay_ms(400);\n\n        if(snareNotes[i] == 1)\n        {\n            midi.NoteOn<10>(snareNote, 80);\n        }\n\n        if(hihatNotes[i] == 1)\n        {\n            midi.NoteOn<10>(hhNote, 80);\n        }\n\n        if(bassDrumNotes[i] == 1)\n        {\n            midi.NoteOn<10>(bdNote, 80);\n        }\n\n        i = ++i % nbNotes;\n    }\n\n    return 0;\n}\n```\n\nWe have defined three instruments: a snare drum, a hi-hat, and a bass drum, each having its MIDI note: 38, 42 and 36, respectively.\nWe also define an array of eight notes for each instrument.\nIn that array, a \"1\" means that the instrument's note is to be played, and a \"0\" means nothing happens.\nWe iterate the array in loop, and play a note every 400 ms.\nI believe the code is self-explanatory.\n\n## Playing Those Notes\n\nAs I have already mentioned, our Arduino isn't recognized as a MIDI device because it doesn't use the USB protocol.\nConsequently, we need to *convert* the incoming serial data to MIDI data.\nTo that end, we can use [ttymidi](https://github.com/cjbarnes18/ttymidi).\nIt isn't too hard to use, and works well on Linux.\nFirst of all, we need to clone the repository: `git clone https://github.com/cjbarnes18/ttymidi`.\nThen, in the `ttymidi` directory, we need to compile it using `make`.\nAnd finally, to start the program, we run the following command:\n\n```text\n./ttymidi -s /dev/ttyACM0 -b 115200 -v\n```\n\nWhere `/dev/ttyACM0` is the Arduino's serial port.\nLet ttymidi run with the Arduino plugged in and you'll see MIDI notes being received in real-time.\n\n## What's Next?\n\nWe are going to take a break for now.\nI don't when the next part will be posted, but I know it'll be about the Analog to Digital Converter (ADC).\nWe'll probably get back to MIDI-related topics another time.\nSee you next time!\n",
            "url": "https://news.exadrums.com/article/new-arduino-nano-every-board-part3",
            "title": "New Arduino Nano Every Trigger Board - Part 3",
            "summary": "This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 2.\nIn this part, we are going send MIDI notes over USB using the Arduino Nano Every.\nTo understand everything correctly, make sure you read the previous parts.\n♬ ♪ ♬ ♪",
            "date_modified": "2022-05-15T12:49:07.000Z",
            "date_published": "2022-05-15T12:49:07.000Z"
        }
    ]
}