{
    "version": "https://jsonfeed.org/version/1",
    "title": "exadrums - news",
    "home_page_url": "https://news.exadrums.com/latest.json",
    "description": "eXaDrums project: latest news.",
    "items": [
        {
            "id": "https://news.exadrums.com/article/new-arduino-nano-every-board-part7",
            "content_html": "\nThis is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 6](/article/new-arduino-nano-every-board-part6).\n\nIn this part, we are going to talk about digital filtering.\nThe board that was made for this project adds a DC offset to the signal to keep the voltage above 0V, as shown below.\n\n![Circuit](/images/new-arduino-nano-every-board/Piezo-circuit.png)\n\nIf we get bytes from the ADC, the values are going to be centered around 127, and go from 0 to 255.\nHowever, the offset won't always be exactly 127, as it depends on a voltage source and a voltage divider.\nThe offset may vary over time, so we can't really subtract 127 to the value read by the ADC.\nThis is why we need a high-pass filter.\n\n<!--more-->\n\n## High-pass Filter in Electronics\n\nIn electronics, a high-pass filter is made of two components: a resistor and a capacitor.\nThe capacitor naturally acts as a high-pass filter, but a resistor is required in order to control the cutoff frequency of the filter.\n\nFor a first order, RC, high-pass filter, the cutoff frequency is given by fc = 1/(2πRC).\nFor instance, the association of a 10 kΩ resistor and a 1 µF capacitor gives fc ≈ 16 Hz.\nThe signal amplitude below 16 Hz will be attenuated, which means that any DC offset will be automatically removed.\n\nIt means that, using such a high-pass filter, a signal that takes values from 0 to 255 while being centered around 127, will be shifted so that it is centered around zero and takes values that go from -127 to 128.\nAs a side-effect, the lowest frequencies (below 16 Hz) will also be filtered, but in our case, that is negligible.\n\n## Algorithmic Implementation\n\nWithout going into too much detail, the RC high-pass filter can be translated into equations that can then be translated into a simple algorithm.\nThe output value `out` depends only on the input `in` and the values of R and C.\nTime is 'translated' to indices, so `i` represents the time.\nThe output of the system is given by `out[i] = α × (out[i−1] + in[i] − in[i−1])`, where `α = RC / (RC + dt)`, `dt` being the elapsed time between samples `i` and `i+1`.\nSo we only need to know the previous output sample, and the current and previous input samples to compute the new output value.\n\nThis is fairly easy to implement, however, there is a problem.\nThe above algorithm requires the use of floating-point number.\nWhen dealing with a 8-bit microcontroller, this can become problematic.\n\nEnter the world of fixed-point arithmetic!\n\n## Fixed-Point DC Blocking Filter\n\n### DC Blocking Filter\n\nA DC blocking filter is not exactly the same thing as a high-pass filter.\nLet's focus a little bit on [digital filtering](https://en.wikipedia.org/wiki/Digital_filter).\nWhen dealing with digital filtering, filters are described using the so called [Z-transform](https://en.wikipedia.org/wiki/Z-transform).\nOne advantage I see in doing so, is that it's easy to reason about complex filters.\n\nFor instance, let's consider a simple high-pass filter.\nIn digital signal processing, its transfer function can be described as:\n\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\" title=\"T(z) = \\frac{out(z)}{in(z)} = \\frac{1 - z^{-1}}{1 - pz^{-1}}  \">\n  <mrow>\n    <mi>T</mi>\n    <mo stretchy=\"false\">(</mo>\n    <mi>z</mi>\n    <mo stretchy=\"false\">)</mo>\n    <mo>=</mo>\n    <mfrac>\n      <mrow>\n        <mi>o</mi>\n        <mi>u</mi>\n        <mi>t</mi>\n        <mo stretchy=\"false\">(</mo>\n        <mi>z</mi>\n        <mo stretchy=\"false\">)</mo>\n      </mrow>\n      <mrow>\n        <mi>i</mi>\n        <mi>n</mi>\n        <mo stretchy=\"false\">(</mo>\n        <mi>z</mi>\n        <mo stretchy=\"false\">)</mo>\n      </mrow>\n    </mfrac>\n    <mo>=</mo>\n    <mfrac>\n      <mrow>\n        <mn>1</mn>\n        <mo>-</mo>\n        <msup>\n          <mrow>\n            <mi>z</mi>\n          </mrow>\n          <mrow>\n            <mo>-</mo>\n            <mn>1</mn>\n          </mrow>\n        </msup>\n      </mrow>\n      <mrow>\n        <mn>1</mn>\n        <mo>-</mo>\n        <mi>p</mi>\n        <msup>\n          <mrow>\n            <mi>z</mi>\n          </mrow>\n          <mrow>\n            <mo>-</mo>\n            <mn>1</mn>\n          </mrow>\n        </msup>\n      </mrow>\n    </mfrac>\n  </mrow>\n</math>\n\nThe parameter *p* is a pole, and has a big influence on the filter's transfer function, as shown on the figure below:\n\n![HPFilter](/images/new-arduino-nano-every-board/hp.svg)\n\nBy the way, I used Octave to create this figure, here's the code to replicate it:\n\n```matlab\nps = [0 0.5 0.9 0.99];\n\nfor p = ps\n\n    p\n    b = [1 -1];\n    a = [1 -p];\n\n\n    [h, w] = freqz(b, a);\n\n    n = length(w);\n    \n    plot(w(1:n/2), 20*log10(abs(h(1:n/2))), \"linewidth\", 3);\n    hold on;\n\nendfor\n\nxlabel('Freq. (rad/s)');\nylabel('Gain (dB)');\ngrid on;\nlegend(\"show\")\nlegend(\"p = 0\", \"p = 0.5\", \"p = 0.9\", \"p = 0.99\")\nset(gca, \"linewidth\", 3, \"fontsize\", 14)\n```\n\nWhat we'd like is to have something that's close to the curve given by *p = 0.99*, as it blocks DC values and keeps all higher frequencies.\n\n### Fixed-Point Arithmetic\n\nClearly, the main advantage of fixed-point arithmetic is speed.\nThe Arduino Nano Every doesn't have a floating-point unit, so every operation that involves floating-point numbers is super slow, as it requires a lot of instructions. Multiplying two floats (that are 32-bit numbers) takes several milliseconds, which is way too long for our purposes.\n\nOur goal is to find a way to perform the high-pass filtering operation using algorithms that operate on bytes.\nThis will involve fixed-point operations, but will also require a few tricks to make things work as expected.\n\n### Fixed-Point DC Blocker\n\nWe can use the previous equation to compute the current output value as a function of the previous output value, and the current and previous input values:\n\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\" title=\"y[n] = p y[n - 1] + x[n] - x[n - 1] \">\n  <mrow>\n    <mi>y</mi>\n    <mi>[</mi>\n    <mi>n</mi>\n    <mi>]</mi>\n    <mo>=</mo>\n    <mi>p</mi>\n    <mi>y</mi>\n    <mi>[</mi>\n    <mi>n</mi>\n    <mo>-</mo>\n    <mn>1</mn>\n    <mi>]</mi>\n    <mo>+</mo>\n    <mi>x</mi>\n    <mi>[</mi>\n    <mi>n</mi>\n    <mi>]</mi>\n    <mo>-</mo>\n    <mi>x</mi>\n    <mi>[</mi>\n    <mi>n</mi>\n    <mo>-</mo>\n    <mn>1</mn>\n    <mi>]</mi>\n  </mrow>\n</math>\n<br>\n\nWhere *y* is the output and *x* is the input.\nOf course this formula is valid if we use floating-point numbers.\nHowever, we can notice that this is equation can be applied in two distinct steps:\n\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\" title=\"w[n] = x[n] - x[n-1] \">\n  <mrow>\n    <mi>d</mi>\n    <mi>[</mi>\n    <mi>n</mi>\n    <mi>]</mi>\n    <mo>=</mo>\n    <mi>x</mi>\n    <mi>[</mi>\n    <mi>n</mi>\n    <mi>]</mi>\n    <mo>-</mo>\n    <mi>x</mi>\n    <mi>[</mi>\n    <mi>n</mi>\n    <mo>-</mo>\n    <mn>1</mn>\n    <mi>]</mi>\n  </mrow>\n</math>\n\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\" title=\"y[n] = p\\,y[n-1] + w[n] \">\n  <mrow>\n    <mi>y</mi>\n    <mi>[</mi>\n    <mi>n</mi>\n    <mi>]</mi>\n    <mo>=</mo>\n    <mi>p</mi>\n    <mi>y</mi>\n    <mi>[</mi>\n    <mi>n</mi>\n    <mo>-</mo>\n    <mn>1</mn>\n    <mi>]</mi>\n    <mo>+</mo>\n    <mi>d</mi>\n    <mi>[</mi>\n    <mi>n</mi>\n    <mi>]</mi>\n  </mrow>\n</math>\n<br>\nThe first step represents a differentiator, and the second step a leaky integrator.\nThe differentiator has the transfer function of the very first equation when p = 0, so it's basically a DC blocker, but it blocks more than just low frequencies.\nThanks to the leaky integrator, those frequencies are less attenuated, so it's definitely what we want to obtain.\n\n### Understanding and Prototyping a Fixed-Point DC Blocker\n\nUsing integers instead of floats results in quantization errors, especially due to the leaky integrator.\nFurthermore, how do we deal with *p*, whose value lies between 0 and 1?\nLet's assume that the input is an unsigned 8-bit integer, and the output is a signed 8-bit integer.\nThe input values go from 0 to 255 whereas the output values go from -127 to 128.\n\nBefore rushing into it, let's make a little detour and try to implement the DC blocker algorithm using Octave.\nWe need to convert the previous equations into something we can use in a fixed-point algorithm.\nHere's what we have so far:\n\n- x<sub>n</sub> is the input of the DC blocker.\n- d<sub>n</sub> is the output of the differentiator.\n- y<sub>n</sub> is the output of the DC blocker.\n\nNow we're going to have to use the previous equation with integers, so at some point, we'll have a quantization that will introduce a quantization error: e<sub>n</sub>.\nThe technique that we are going to use is called fraction-saving, it works very well when *p* is close to 1.\nIt consists in memorizing the round-off error of the previous sample and subtract it to the next sample, to minimize that error.\n\nSo now we need and extra variable to store the error.\nThe thing is that it's possible to overflow the 8-bit capacity, because we'll add the previous value of the error, e<sub>n-1</sub>.\nWe have no choice but to make our new variable a 16-bit integer to store the extra bit that might be required. Fortunately, the ATMega4809 can perform some 16-bit operations very efficiently, so that's not a big deal.\nTo optimize things as much as possible, we'll use this variable to store the error as well as the current value of y<sub>n</sub>.\n\nIt's now time to do some prototyping and testing.\nLet's call the new variable *acc*. We can store the quantized value of y<sub>n</sub> in the upper 9 bits (to avoid any overflow) of *acc* and e<sub>n</sub> in the lower 7 bits.  \nWe'll use Octave to make sure everything works out before we implement the final filter in C++.\n\nTo that end, we'll introduce three main variables, `prevX`, `prevY` and `acc`.\nThe names speak for themselves.\nOur test will consist of an input of 100 samples that basically repeat the values 77 and 177 until the end of the sequence.\nThis input signal is centered around 127 and oscillates from 77 to 177.\nIf the DC component is removed, we'll end up with an output that is centered around 0 and goes from -50 to +50.\n\nHere's the code for our prototype, with p = 0.98:\n\n```matlab\nprevX = int16(0);\nprevY = int16(0);\nacc = int16(0);\n\nxa = repmat([uint8(77), uint8(177)], [1, 50]);\n\nt = linspace(0, length(xa), length(xa));\n\ny = [];\n\nfor x = xa\n                                    % acc = y_{n-1} << 7 - e_{n-1}\n  acc = acc - prevX;                % acc = acc - x_{n-1} << 7\n  prevX = bitshift(int16(x), 7);    % prevX = x_n << 7\n  acc = acc + prevX;                % acc = acc + x_n << 7 - e_{n-1}\n  % d_n is now in the upper 9 bits of acc\n  % acc = (y_{n-1} + d_n )<< 7 - e_{n-1}\n  acc = acc - prevY * 256*(1 - .98);% acc = acc - y_{n-1} * (1<<8 * (1 - p)) - e_{n-1}\n  % acc = [ y_{n-1} - y_{n-1} * (1<<8 * (1 - p)) + d_n ] << 7 - e_{n-1}\n  prevY = bitshift(acc, -7);        % prevY = acc >> 7 + e_n (error introduced by quantization)\n  y = [y; prevY];\n\nendfor\n\nplot(t, y)\n```\n\nAnd here's the result:\n\n![DCBlocker](/images/new-arduino-nano-every-board/dc_blocker.svg)\n\nAs expected, after a transient phase, the signal oscillates between -50 ans 50.\nThe transient phase is tightly related to the value of *p*.\nThe closer *p* gets to 1, the longer the transient.\n\nNow, let's dig into the code and got through the comments.\nFirst of all, let's assume that the loop already iterated at least once.\nThe *acc* variable holds y<sub>n-1</sub> << 7 - e<sub>n-1</sub>.\n\nFirstly, we perform the following operation: acc = acc - x<sub>n-1</sub> << 7, which means that the upper 9 bits of *acc* are now y<sub>n-1</sub> - x<sub>n-1</sub>.\nWe then store x<sub>n</sub> into the upper 9 bits of *prevX*, and add that value to *acc*.\nAt this point, we have acc = y<sub>n-1</sub> - x<sub>n-1</sub> - e<sub>n-1</sub> (remember that the initial value of *acc* held the value -e<sub>n-1</sub> in its lowest bits).\n\nAlright, now we encounter that line: `acc = acc - prevY * 256*(1 - .98);`.\nWithout going into too much detail, if we take the previous equations, we get:\n\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\" title=\"y_n = Q{p\\,y_{n-1} + d_n - e_{n-1}}  \">\n  <mrow>\n    <msub>\n      <mrow>\n        <mi>y</mi>\n      </mrow>\n      <mrow>\n        <mi>n</mi>\n      </mrow>\n    </msub>\n    <mo>=</mo>\n    <mi>Q</mi>\n    <mi>{</mi>\n    <mi>p</mi>\n    <mspace width=\"0.167em\"/>\n    <msub>\n      <mrow>\n        <mi>y</mi>\n      </mrow>\n      <mrow>\n        <mi>n</mi>\n        <mo>-</mo>\n        <mn>1</mn>\n      </mrow>\n    </msub>\n    <mo>+</mo>\n    <msub>\n      <mrow>\n        <mi>d</mi>\n      </mrow>\n      <mrow>\n        <mi>n</mi>\n      </mrow>\n    </msub>\n    <mo>-</mo>\n    <msub>\n      <mrow>\n        <mi>e</mi>\n      </mrow>\n      <mrow>\n        <mi>n</mi>\n        <mo>-</mo>\n        <mn>1</mn>\n      </mrow>\n    </msub>\n    <mi>}</mi>\n  </mrow>\n</math>\n<br>\n\nwhere *Q* represents the quantization, which is of course implicit.\nNotice that we are feeding the quantization error from the previous iteration of the loop (e<sub>n-1</sub>) on purpose.\nThe error for the n<sup>th</sup> iteration is thus given by:\n\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\" title=\"e_n = Q{p\\,y_{n-1} + d_n - e_{n-1}} - \\left(p\\,y_{n-1} + d_n - e_{n-1}\\right) = y_n - \\left(p\\,y_{n-1} + d_n - e_{n-1}\\right) \">\n  <mrow>\n    <msub>\n      <mrow>\n        <mi>e</mi>\n      </mrow>\n      <mrow>\n        <mi>n</mi>\n      </mrow>\n    </msub>\n    <mo>=</mo>\n    <mi>Q</mi>\n    <mi>{</mi>\n    <mi>p</mi>\n    <mspace width=\"0.167em\"/>\n    <msub>\n      <mrow>\n        <mi>y</mi>\n      </mrow>\n      <mrow>\n        <mi>n</mi>\n        <mo>-</mo>\n        <mn>1</mn>\n      </mrow>\n    </msub>\n    <mo>+</mo>\n    <msub>\n      <mrow>\n        <mi>d</mi>\n      </mrow>\n      <mrow>\n        <mi>n</mi>\n      </mrow>\n    </msub>\n    <mo>-</mo>\n    <msub>\n      <mrow>\n        <mi>e</mi>\n      </mrow>\n      <mrow>\n        <mi>n</mi>\n        <mo>-</mo>\n        <mn>1</mn>\n      </mrow>\n    </msub>\n    <mi>}</mi>\n    <mo>-</mo>\n    <mrow>\n      <mo>(</mo>\n      <mrow>\n        <mi>p</mi>\n        <mspace width=\"0.167em\"/>\n        <msub>\n          <mrow>\n            <mi>y</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n            <mo>-</mo>\n            <mn>1</mn>\n          </mrow>\n        </msub>\n        <mo>+</mo>\n        <msub>\n          <mrow>\n            <mi>d</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n          </mrow>\n        </msub>\n        <mo>-</mo>\n        <msub>\n          <mrow>\n            <mi>e</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n            <mo>-</mo>\n            <mn>1</mn>\n          </mrow>\n        </msub>\n      </mrow>\n      <mo>)</mo>\n    </mrow>\n    <mo>=</mo>\n    <msub>\n      <mrow>\n        <mi>y</mi>\n      </mrow>\n      <mrow>\n        <mi>n</mi>\n      </mrow>\n    </msub>\n    <mo>-</mo>\n    <mrow>\n      <mo>(</mo>\n      <mrow>\n        <mi>p</mi>\n        <mspace width=\"0.167em\"/>\n        <msub>\n          <mrow>\n            <mi>y</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n            <mo>-</mo>\n            <mn>1</mn>\n          </mrow>\n        </msub>\n        <mo>+</mo>\n        <msub>\n          <mrow>\n            <mi>d</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n          </mrow>\n        </msub>\n        <mo>-</mo>\n        <msub>\n          <mrow>\n            <mi>e</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n            <mo>-</mo>\n            <mn>1</mn>\n          </mrow>\n        </msub>\n      </mrow>\n      <mo>)</mo>\n    </mrow>\n  </mrow>\n</math>\n<br>\n\nWhen you think about it, it is quite obvious!\nLet's re-order the terms, without forgetting that y<sub>n</sub> has been subject to quantization:\n\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\" title=\"y_n = \\left(p\\,y_{n-1} + d_n - e_{n-1} + e_n\\right) \">\n  <mrow>\n    <msub>\n      <mrow>\n        <mi>y</mi>\n      </mrow>\n      <mrow>\n        <mi>n</mi>\n      </mrow>\n    </msub>\n    <mo>=</mo>\n    <mrow>\n      <mo>(</mo>\n      <mrow>\n        <mi>p</mi>\n        <mspace width=\"0.167em\"/>\n        <msub>\n          <mrow>\n            <mi>y</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n            <mo>-</mo>\n            <mn>1</mn>\n          </mrow>\n        </msub>\n        <mo>+</mo>\n        <msub>\n          <mrow>\n            <mi>d</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n          </mrow>\n        </msub>\n        <mo>-</mo>\n        <msub>\n          <mrow>\n            <mi>e</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n            <mo>-</mo>\n            <mn>1</mn>\n          </mrow>\n        </msub>\n        <mo>+</mo>\n        <msub>\n          <mrow>\n            <mi>e</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n          </mrow>\n        </msub>\n      </mrow>\n      <mo>)</mo>\n    </mrow>\n  </mrow>\n</math>\n<br>\n\nThe reason why y<sub>n-1</sub> is already stored in *acc* is that it is simply the last line of our loop.\nSince we've already ran through it at least once, that makes sense.\nHowever, this value is y<sub>n-1</sub>, and not p.y<sub>n-1</sub>.\nThat's too bad because the previous equation contains p.y<sub>n-1</sub>...\nLet's rewrite it so that it fits our needs:\n\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\" title=\"y_n = \\left(y_{n-1} - (1 - p)\\,y_{n-1} + d_n - e_{n-1} + e_n\\right) \">\n  <mrow>\n    <msub>\n      <mrow>\n        <mi>y</mi>\n      </mrow>\n      <mrow>\n        <mi>n</mi>\n      </mrow>\n    </msub>\n    <mo>=</mo>\n    <mrow>\n      <mo>(</mo>\n      <mrow>\n        <msub>\n          <mrow>\n            <mi>y</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n            <mo>-</mo>\n            <mn>1</mn>\n          </mrow>\n        </msub>\n        <mo>-</mo>\n        <mo stretchy=\"false\">(</mo>\n        <mn>1</mn>\n        <mo>-</mo>\n        <mi>p</mi>\n        <mo stretchy=\"false\">)</mo>\n        <mspace width=\"0.167em\"/>\n        <msub>\n          <mrow>\n            <mi>y</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n            <mo>-</mo>\n            <mn>1</mn>\n          </mrow>\n        </msub>\n        <mo>+</mo>\n        <msub>\n          <mrow>\n            <mi>d</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n          </mrow>\n        </msub>\n        <mo>-</mo>\n        <msub>\n          <mrow>\n            <mi>e</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n            <mo>-</mo>\n            <mn>1</mn>\n          </mrow>\n        </msub>\n        <mo>+</mo>\n        <msub>\n          <mrow>\n            <mi>e</mi>\n          </mrow>\n          <mrow>\n            <mi>n</mi>\n          </mrow>\n        </msub>\n      </mrow>\n      <mo>)</mo>\n    </mrow>\n  </mrow>\n</math>\n<br>\n\nNow the line `acc = acc - prevY * 256*(1 - .98);` makes a lot of sense, as this is almost exactly the equation we've just written.\nI say almost for two reasons.\nThe first one is that the term e<sub>n</sub> is missing for now, as it is introduced by the next line of code.\nThe other reason is that the equation doesn't show the `256` that is basically a normalization factor so that *p* no longer acts on floats, but on bytes instead (8-bit integers).\nBy the way, in practice, the value 256*(1 - .98) is not 5.12 as it should be because we're not dealing with floating-point numbers.\nSo, we should replace that whole expression by 5, which means that p = 0.9805.\n\nThat means not all values of *p* are allowed.\nFor instance, excluding 1, the first 10 values of *p* are: 0.9961, 0.9922, 0.9883, 0.9844, 0.9805, 0.9766, 0.9727, 0.9688, 0.9648, 0.9609.\n\nNow all that's left is the step where the quantization actually happens, which corresponds to the very last operation of the loop.\nThat line translates to `prevY = acc >> 7;` in C++.\nYou may notice that this means *prevY* could be an 8-bit integer instead of a 16-bit one, but that would make the code a tad more complex, so we'll keep a 16-bit integer.\n\nSince the quantization happens here, this line is equivalent to prevY = y<sub>n</sub> + e<sub>n</sub> - e<sub>n-1</sub>, because we introduced the term -e<sub>n-1</sub> a few lines ago on purpose.\nAs we can see, this explains why we assumed that acc = y<sub>n-1</sub> << 7 - e<sub>n-1</sub> at the beginning.\nThis also shows that we found a way to compensate for the quantization error.\n\n## Fixed-Point DC Blocker Implementation in C and C++\n\nSo far, everything behaves as expected.\nThanks to a few tricks, we've optimized things quite a lot and are down to a few lines of code to perform the DC blocking operation.\nAll the operations that are involved operate on 16-bit integer. They are mainly additions and subtraction, however, there is one multiplication involved.\n\nWe know that we need to multiply *prevY* by 256*(1 - p).\nAs I have already explained, using integer types limits the possible values.\nThat's why there are only 10 possible values between p = 0.996 and p = 0.96.\nBut if we restrict the values even more, we can make sure that our final multiplication end-up being a multiple of two.\nThis means that it won't be a multiplication anymore, but a simple bit shift operation, which is a lot more efficient.\nSimply put, that limitation leads to these four values between 0.996 and 0.96: 0.9961, 0.9922, 0.9844, 0.9688.\n\nLet's choose p = 0.9922, that lead us to a multiplication by 2.\nHere's how it translates in C++ ([and can easily be adapted to C](https://dspguru.com/dsp/tricks/fixed-point-dc-blocking-filter-with-noise-shaping/)):\n\n```cpp\n\nstatic int16_t prevX = 0;\nstatic int16_t prevY = 0;\nstatic int16_t acc = 0;\n\nint8_t RemoveDC(uint8_t x)\n{\n\n  acc   -= prevX;\n  prevX = static_cast<int16_t>(x) << 7;\n  acc   += prevX;\n  acc   -= prevY << 2; // p = .9922 => 256 * (1 - p) = 2\n  prevY = acc >> 7;\n\n  return static_cast<int8_t>(prevY);\n}\n```\n\nHere we are, only 5 lines of code to perform a DC blocking operation, using only additions, subtractions, and bit shift operations.\nOn a ATMega4809 clocked at 16MHz that is less than 10µs of execution time, that's just perfect!\n\nBefore concluding, I think it's worth mentioning that the transient response of the DC blocker lasts for about 350 samples.\nThat's not a lot, rounding up to 400 samples, that's 4ms at 100ksps, not too bad.\n\n## From a DC Blocker to a C++ Drum Trigger\n\nSo, what happens after we remove the DC offset from the input signal?\nIn the [previous part of this series](/article/new-arduino-nano-every-board-part6), we've imagined a `Trigger` class that would contain a `Process` method:\n\n```cpp\nvoid Trigger::Process(uint8_t data, uint8_t time) const\n{\n    // [...]\n\n    const uint8_t delta = this->trigTime + this->scanTime - time;\n\n    if(static_cast<int8_t>(delta) <= 0)\n    {\n        // ...\n    }\n\n    // [...]\n}\n```\n\nWe knew what to do with the `time` variable, now we know what to do with the `data` variable.\nFirst of all, it has to go through the `RemoveDC` function, and then, we can take the absolute value of the filtered signal and apply some peak detection and other algorithms to it.\nThe code is on [Github](https://github.com/SpintroniK/exadrumino-Nano-Every/blob/de670fde4b6f3fe18d61a9d21d77866de8024d00/src/Module/Trigger.hpp#L25), but if you only care about the `Process` method, here's a snippet:\n\n```cpp\nvoid Process(uint8_t value, uint8_t currentTime) noexcept\n{\n    acc   -= prevX;\n    prevX = static_cast<int16_t>(value) << 7;\n    acc   += prevX;\n    acc   -= prevY << 2;\n    prevY = acc >> 7;\n\n    const uint8_t velocity = ::abs(prevY);\n\n\n    if(state == 0) // Idle\n    {\n        if(velocity >= threshold)\n        {\n            trigTime = currentTime;\n            state = 1;\n            return;\n        }\n    }\n\n    if(state == 1) // Scan\n    {\n        maxVelocity = velocity > maxVelocity ? velocity : maxVelocity;\n        maxVelocity = maxVelocity >= 127 ? 127 : maxVelocity;\n\n        const uint8_t delta = trigTime + scanTime - currentTime;\n        if(static_cast<int8_t>(delta) <= 0)\n        {\n            state = 2;\n            trigVelocity = maxVelocity;\n            return;\n        }\n    }\n\n    if(state == 2)\n    {\n        const uint8_t delta = trigTime + maskTime - currentTime;\n        if(static_cast<int8_t>(delta) <= 0)\n        {\n            state = 0;\n            maxVelocity = 0;\n            return;\n        }\n    }\n\n    return;\n}\n```\n\nIt is basically a state machine.\n\n## What's Next?\n\nNext time we'll talk about how to read and write values to the Arduino's EEPROM.\n\nHappy new year, and see you next time!\n",
            "url": "https://news.exadrums.com/article/new-arduino-nano-every-board-part7",
            "title": "New Arduino Nano Every Trigger Board - Part 7",
            "summary": "This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 6.\nIn this part, we are going to talk about digital filtering.\nThe board that was made for this project adds a DC offset to the signal to keep the voltage above 0V, as shown below.\n\nIf we get bytes from the ADC, the values are going to be centered around 127, and go from 0 to 255.\nHowever, the offset won't always be exactly 127, as it depends on a voltage source and a voltage divider.\nThe offset may vary over time, so we can't really subtract 127 to the value read by the ADC.\nThis is why we need a high-pass filter.",
            "date_modified": "2023-01-01T11:32:42.000Z",
            "date_published": "2023-01-01T11:32:42.000Z"
        }
    ]
}