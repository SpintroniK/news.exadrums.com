{
    "version": "https://jsonfeed.org/version/1",
    "title": "exadrums - news",
    "home_page_url": "https://news.exadrums.com/latest.json",
    "description": "eXaDrums project: latest news.",
    "items": [
        {
            "id": "https://news.exadrums.com/article/new-arduino-nano-every-board-part4",
            "content_html": "\nThis is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 3](/article/new-arduino-nano-every-board-part3).\n\nIn this part, we are going to read data from the Analog to Digital Converter (ADC) and make an oscilloscope.\nIt'll show us what the piezo voltage of drum pad looks like when hit with a drum stick.\n\n![signal](/images/new-arduino-nano-every-board/signal.png)\n\nTo understand everything correctly, make sure you read the previous parts.\n\n<!--more-->\n\n## How the ADC Works\n\nThis part is going to be a little bit more theoretical.\nBut we'll see a concrete example at the end.\n\n### ADC Configuration\n\nFirst of all, we need to talk about the ATMega4809's ADC configuration.\nWithout going into the very technical details, I'll talk about some of the important parameters of the ADC.\nIt needs a clock source, which can be obtained from the peripheral clock.\nThe way this clock signal is generated, is by dividing the CPU clock by a 'divider' that goes from 2 to 256.\nSince the CPU clock is 16 MHz, that leaves with an ADC frequency that goes from 62.5 kHz to 8 MHz.\nIn practice, it is recommended to avoid low frequencies, and to not go above 1.5 MHz.\nA normal conversion takes 13 ADC clock cycles, so the fastest conversion time we can get is 8.67 µs.\nThat is a bit over 115 kilo samples per seconds (ksps).\n\nAnother important parameter is the resolution of the ADC. Here we have two choices: 8-bit or 10-bit.\nIn the case of 8-bit sampling, we can store the data into a single byte.\nHowever, 10-bit resolution will require 16-bit integers to store the results, which can lead to slower code.\n\nThere are different modes of operation. We are interested in the 'normal' mode, in which we ask the microcontroller to start a new conversion ourselves. There's also the free-running mode, in which the ADC starts a new conversion every time the previous one has finished.\n\n### Events and Interrupts\n\nThere are two ways the microcontroller can communicate with peripherals:\n\n- Interrupts: they let you execute a function automatically after an hardware event has occurred.\n- Events: they allow peripherals to communicate with one another.\n\nWe are going to use both of them, the event will trigger a new conversion when a timer overflows, and the interrupt will be used to fetch the conversion result.\n\n## Using the ADC in C++\n\nFirst, let's see how to use the ADC in C++.\nWe define a few useful things: \n\n```cpp\nstatic const auto Adc0Addr = reinterpret_cast<uint16_t>(&ADC0);\n\nclass Adc10bitType;\nclass Adc8bitType;\n\nenum class Vref : uint8_t\n{\n    External,\n    Internal, \n    Vdd,\n};\n\nenum class Prescaler : uint8_t\n{\n    Div2,\n    Div4,\n    Div8,\n    Div16,\n    Div32,\n    Div64,\n    Div128,\n    Div256\n};\n\ntemplate <typename T, typename Enable = void>\nclass AdcBase;\n\ntemplate <typename T>\nclass AdcBase<T, Util::enable_if_t<Util::is_same_v<T, Adc8bitType>>>\n{\npublic:\n    AdcBase() = delete;\n    ~AdcBase() = delete;\n\nprotected:\n\n    inline static uint8_t value{};\n\n};\n\n\ntemplate <typename T>\nclass AdcBase<T, Util::enable_if_t<Util::is_same_v<T, Adc10bitType>>>\n{\npublic:\n    AdcBase() = delete;\n    ~AdcBase() = delete;\n\nprotected:\n\n    inline static uint16_t value{};\n\n};\n```\n\nThe ADC register's address is stored in `Adc0Addr`.\nWe've defined utilities for the ADC resolution, its voltage reference, and the frequency divider.\n\nNotice the use of `enable_if`, which is defined as:\n\n```cpp\nnamespace Util\n{\n    \n    template <class T, T v>\n    struct integral_constant \n    {\n        static constexpr T value = v;\n        using value_type = T;\n        using type = integral_constant; // using injected-class-name\n        constexpr operator value_type() const noexcept { return value; }\n        constexpr value_type operator()() const noexcept { return value; } // since c++14\n    };\n\n    template <class T, class U>\n    struct is_same : integral_constant<bool, false> {};\n    \n    template <class T>\n    struct is_same<T, T> : integral_constant<bool, true> {};\n\n    template<bool B, class T = void>\n    struct enable_if {};\n    \n    template<class T>\n    struct enable_if<true, T> { using type = T; };\n\n    template< bool B, class T = void >\n    using enable_if_t = typename enable_if<B,T>::type;\n\n    template< class T, class U >\n    inline constexpr bool is_same_v = is_same<T, U>::value;\n\n} // namespace Util\n```\n\nThis is usually part of the standard C++ library, but we don't have it, so these definitions help us achieve what we need: two different types for the 8-bit and 10-bit modes.\nAlright, now we're done with the boilerplate, so let's get all the basic stuff out of the way:\n\n```cpp\ntemplate <uint16_t addr, typename ValueType>\nclass Adc : private AdcBase<ValueType>\n{\n\npublic:\n\n    Adc() = delete;\n    ~Adc() = delete;\n\n    template <Prescaler div>\n    static constexpr void SetPrescaler()\n    {\n        switch(div)\n        {\n            case Prescaler::Div2:   adc().CTRLC |= ADC_PRESC_DIV2_gc; break;\n            case Prescaler::Div4:   adc().CTRLC |= ADC_PRESC_DIV4_gc; break;\n            case Prescaler::Div8:   adc().CTRLC |= ADC_PRESC_DIV8_gc; break;\n            case Prescaler::Div16:  adc().CTRLC |= ADC_PRESC_DIV16_gc; break;\n            case Prescaler::Div32:  adc().CTRLC |= ADC_PRESC_DIV32_gc; break;\n            case Prescaler::Div64:  adc().CTRLC |= ADC_PRESC_DIV64_gc; break;\n            case Prescaler::Div128: adc().CTRLC |= ADC_PRESC_DIV128_gc; break;\n            case Prescaler::Div256: adc().CTRLC |= ADC_PRESC_DIV256_gc; break;\n        }\n    }\n\n    template <Vref vref>\n    static constexpr void SetReference()\n    {\n        switch(vref)\n        {\n            case Vref::External: adc().CTRLC |= ADC_REFSEL_VREFA_gc; break;\n            case Vref::Internal: adc().CTRLC |= ADC_REFSEL_INTREF_gc; break;\n            case Vref::Vdd: adc().CTRLC |= ADC_REFSEL_VDDREF_gc; break;\n        }\n    }\n\n    static constexpr void SelectChannel(ADC_MUXPOS_t chan)\n    {\n        channel = chan;\n        adc().MUXPOS = channel;\n    }\n\n    static constexpr void Enable()\n    {\n        if constexpr(Util::is_same_v<ValueType, Adc8bitType>)\n        {\n            adc().CTRLA = ADC_ENABLE_bm | ADC_RESSEL_8BIT_gc;\n        }\n        \n        if constexpr(Util::is_same_v<ValueType, Adc10bitType>)\n        {\n            adc().CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc;\n        }\n    }\n\n    static constexpr void StartConversion()\n    {\n        adc().COMMAND = ADC_STCONV_bm;\n    }\n\n\n    static constexpr bool ConversionDone()\n    {\n        return adc().INTFLAGS & ADC_RESRDY_bm;\n    }\n\n    static constexpr auto GetValue()\n    {\n        return Adc<addr, ValueType>::value;\n    }\n\n\nprivate:\n\n    static constexpr auto& adc()\n    {\n        return *reinterpret_cast<ADC_t*>(addr);\n    }\n\n    inline static ValueType value = 0;\n    inline static ADC_MUXPOS_t channel = ADC_MUXPOS_t::ADC_MUXPOS_AIN0_gc;\n\n};\n```\n\nHere are the things we can do with this code:\n\n- Set the ADC clock frequency by changing the clock divider (or prescaler) using `SetPrescaler()`.\n- Set the voltage reference (we'll use an external reference here) using `SetReference()`.\n- Select the input channel (from 0 to 7), using `SelectChannel(ADC_MUXPOS_t chan)`.\n- Of course, we can enable the ADC, start a conversion, and check if the conversion is done.\n\nWith all that we can write an infinite loop, start a conversion, do some things, wait until the conversion is done (in a loop), read the result and use the value as we see fit.\nBut that wouldn't correspond to what we really need.\nWhat we do need is to trigger conversions at a regular interval so that we know exactly how much time has elapsed since the previous value was retrieved from the ADC.\n\n## Using a Timer to Trigger the ADC at Regular Intervals\n\nWe are not going to go into much details about setting up the timer.\nHowever, we are going to focus on the event system that allows to trigger the ADC when the timer overflows.\n\n### Timer Configuration\n\nWe are going to use the TCA timer.\nIt will be configured as follows:\n\n```cpp\n// Configure TCA\nTca::SetSingleMode<Timing::TCASingleMode::Normal>();\nTca::DisableEventCounting();\nTca::SetPeriod(13);             // 14 µs\n\nTca::SetClockDivider<Timing::TCAClockDiv::Div16>();\nTca::Enable();\n```\n\nThe complete code will be on [GitHub](https://github.com/SpintroniK/exadrumino-Nano-Every) soon.\nI believe the code speaks for itself: the timer will overflow every 14 µs.\nIt will count up to 13 (including 0), at a frequency of 1 MHz (CPU clock divided by 16).\n\n### Event System\n\nLet's see how we can trigger an ADC conversion automatically when the timer overflows.\nTo that end, we are going to use the ATMega4809's event system.\nThe event system has 8 channels that allows peripherals to communicate with each other.\nEach channel can be used to connect a peripheral to another one, or itself.\nWe are interested in the overflow event of the TCA timer and the ADC conversion start event.\n\nBut first let's use a little helper that'll make our life easier and the code more readable: \n\n```cpp\n#include <avr/io.h>\n\n#include <stdint.h>\n\ninline constexpr uint8_t EVSYS_GENERATOR_TCA0_OVF_gc = 0x80 << 0; // Should already be defined, but it's not...\n\nnamespace Event\n{\n\n    using Generator = uint8_t;\n    using Event = register8_t;\n\n\n    class EventSystem\n    {\n        \n    public:\n        EventSystem() = delete;\n        ~EventSystem() = delete;\n\n        template <uint8_t channel>\n        static constexpr void Connect(Generator in, Event& out)\n        {\n            switch(channel)\n            {\n                case 0:\n                {\n                    EVSYS.CHANNEL0 = in;\n                    out = EVSYS_CHANNEL_CHANNEL0_gc;\n                    break;\n                }\n\n                case 1:\n                {\n                    EVSYS.CHANNEL1 = in;\n                    out = EVSYS_CHANNEL_CHANNEL1_gc;\n                    break;\n                }\n\n                default: static_assert(channel <= 7, \"\"); break;\n            }\n        }\n\n    private:\n\n    };\n    \n} // namespace Event\n```\n\nI've only implemented the code for channel 0 and channel 1. Other channels can be added by filling the switch-case statement.\nAnd that's how we 'connect' the TCA's overflow to the ADC's start conversion event:\n\n```cpp\nEvent::EventSystem::Connect<0>(EVSYS_GENERATOR_TCA0_OVF_gc, EVSYS.USERADC0);\n```\n\n## ADC Events and Interrupts\n\nA few things are missing in our ADC class.\nWe need to be able to enable events and interrupts, so we can add the following member functions:\n\n```cpp\nstatic constexpr void EnableInterrupts()\n{\n    adc().INTCTRL |= ADC_RESRDY_bm;\n}\n\nstatic constexpr void EnableEvents()\n{\n    adc().EVCTRL |= ADC_STARTEI_bm;\n}\n```\n\nThat's it for the event's configuration, but what about the interrupt?\nAn interrupt is triggered by the hardware, but it needs to be handled on the software side.\nMore precisely, we need to define a function that is going to be called when an interrupt is fired.\nIt is kind of a callback function that takes no arguments and returns nothing.\n\nI'm not going to go into the gory details of gcc, but because of a bug in the compiler, with have to define a new class with a static function that handles the interrupt:\n\n```cpp\nclass AdcInterrupts\n{\npublic:\n\n    AdcInterrupts() = delete;\n    ~AdcInterrupts() = delete;\n\nprivate:\n\n    static void ResReady() __asm__(\"__vector_22\") __attribute__((__signal__, __used__, __externally_visible__));\n};\n```\n\nWe can handle some other ADC interrupts in the same class if we need to.\nBut how do we know that we need to use the vector 22?\nAgain without going into a lot of details, the answer is in the `iom4809.h` header, where we can find:\n\n```cpp\n/* ADC0 interrupt vectors */\n#define ADC0_RESRDY_vect_num  22\n#define ADC0_RESRDY_vect      _VECTOR(22)  /*  */\n#define ADC0_WCOMP_vect_num  23\n#define ADC0_WCOMP_vect      _VECTOR(23)  /*  */\n```\n\n## Putting it All Together\n\nOkay, now we have almost everything we need, so it's time to write our main function.\nBut before that, we need to define the body of our ADC interrupt in a `.cpp` file.\nLet's put it in our `main.cpp` file then:\n\n```cpp\n\nusing Adc0 = Adc<Adc0Addr, Adc8bitType>;\n\nvoid Analog::AdcInterrupts::ResReady()\n{\n    Adc0::ResetInterrupt();\n    // Do somehing with the ADC value ADC0.RES here\n}\n```\n\nWhat we do with the resulting value is up to us, as long as our computations finish before the timer overflows again.\n\nNow to our main function.\n\n```cpp\nint main()\n{\n\n    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler\n\n    sei();\n\n    Event::EventSystem::Connect<0>(EVSYS_GENERATOR_TCA0_OVF_gc, EVSYS.USERADC0);\n\n    // Configure ADC\n    Adc0::EnableInterrupts();\n    Adc0::EnableEvents();\n    Adc0::SelectChannel(ADC_MUXPOS_AIN0_gc);\n    Adc0::SetPrescaler<Analog::Prescaler::Div8>();\n    Adc0::SetReference<Analog::Vref::External>();\n    Adc0::Enable();\n\n    // Configure TCA\n    Tca::SetSingleMode<Timing::TCASingleMode::Normal>();\n    Tca::DisableEventCounting();\n    Tca::SetPeriod(13);             // 14 µs\n    \n    Tca::SetClockDivider<Timing::TCAClockDiv::Div16>();\n    Tca::Enable();\n\n\n\n    for(;;)\n    {\n    }\n\n    return 0;\n}\n```\n\nFirst of all, we disable the CPU clock prescaler.\nThen, we enable interrupts, and we connect the TCA overflow event to the ADC start conversion event.\nWe configure the ADC and the TCA.\nAnd finally, we write an infinite loop.\nOur ADC is sampling `AIN0` but, so far, we're not doing anything with the result.\n\n## Arduino Nano Every Oscilloscope\n\nIn this last section, we are going to use everything that has been presented above, plus the previous part of this series of articles.\nSo if you haven't read the [previous part](/article/new-arduino-nano-every-board-part3), I encourage you to do so.\n\n### Retrieve the ADC Value\n\nWe are going to need a variable to store the ADC value.\nAs this variable will be accessed by both the ADC interrupt and our main function, we ought to declare it as a global variable.\n\n```cpp\n\nusing Adc0 = Adc<Adc0Addr, Adc8bitType>;\n\nstatic uint8_t adcValue{};\n\nvoid Analog::AdcInterrupts::ResReady()\n{\n    Adc0::ResetInterrupt();\n    adcValue = ADC0.RES;\n}\n```\n\n### Send ADC Values Over the USART\n\nWe're going to use the USART code that we wrote in the previous part of this series.\nThe last thing we need to do is to is be able to send strings over the USART.\nIn the previous part, we wrote a function that allowed us to send a single byte.\nA string is an array of characters, and every character can be represented as a single byte.\nAll we need is to format the string and send the bytes it is made of.\nUsing `string.h` this isn't too hard to achieve.\n\n```cpp\n#include \"Adc.hpp\"\n#include \"Usart.hpp\"\n\n#include <avr/io.h>\n#include <avr/interrupt.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nusing Adc0 = Adc<Adc0Addr, Adc8bitType>;\nusing Tca = TCA<TCASingle>;\n\nstatic uint8_t adcValue{};\n\nstatic DigitalIO::Usart<3> usart{115'200};\n\nvoid Analog::AdcInterrupts::ResReady()\n{\n    Adc0::ResetInterrupt();\n    adcValue = ADC0.RES;\n}\n\nint main()\n{\n\n    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler\n\n    sei();\n\n    Event::EventSystem::Connect<0>(EVSYS_GENERATOR_TCA0_OVF_gc, EVSYS.USERADC0);\n\n    // Configure ADC\n    Adc0::EnableInterrupts();\n    Adc0::EnableEvents();\n    Adc0::SelectChannel(ADC_MUXPOS_AIN2_gc);\n    Adc0::SetPrescaler<Analog::Prescaler::Div8>();\n    Adc0::SetReference<Analog::Vref::External>();\n    Adc0::Enable();\n\n    // Configure TCA\n    Tca::SetSingleMode<Timing::TCASingleMode::Normal>();\n    Tca::DisableEventCounting();\n    Tca::SetPeriod(13);             // 14 µs\n    \n    Tca::SetClockDivider<Timing::TCAClockDiv::Div16>();\n    Tca::Enable();\n\n    for(;;)\n    {\n        // brain.SendMidiNotes();\n        static char str[32];\n        ::sprintf(str, \"%d\\n\", adcValue);\n\n        for(uint8_t i = 0; i < ::strlen(str); ++i)\n        {\n            usart.SendByte(str[i]);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\nAnd here we are, we have an Arduino Nano Every oscilloscope.\nYou can use the [new exadrums Arduino Nano Every board](/article/new-arduino-nano-every-board-part3) to connect your e-drums to and have look at a piezo signal in real time, for instance the snare drum.\n\n![arduino-board](/images/new-arduino-nano-every-board/board-arduino.png)\n\nThen, you can launch the Arduino IDE, and hit Ctrl + Shift + L.\nYou'll see something like that if you play flams, for instance:\n\n![oscilloscope](/images/new-arduino-nano-every-board/oscilloscope.png)\n\nYou'll notice that we are getting one new sample every 14 µs, but sending data at a baudrate of 115200 bps, which corresponds to about 5000 values per second in average.\nWe are getting samples way to fast, but that's not really a problem since this is just a step towards our goal: making a drum module.\nSo getting one sample every 14 µs means we can aim for 8928 samples per second and per piezo if we use 8 piezos.\n\n## What's Next?\n\nNew time I'll share the code, as it is now usable and I've tested it with my Roland TD17 e-drum.\nStay tuned!\n",
            "url": "https://news.exadrums.com/article/new-arduino-nano-every-board-part4",
            "title": "New Arduino Nano Every Trigger Board - Part 4",
            "summary": "This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 3.\nIn this part, we are going to read data from the Analog to Digital Converter (ADC) and make an oscilloscope.\nIt'll show us what the piezo voltage of drum pad looks like when hit with a drum stick.\n\nTo understand everything correctly, make sure you read the previous parts.",
            "date_modified": "2022-06-06T19:48:22.000Z",
            "date_published": "2022-06-06T19:48:22.000Z"
        }
    ]
}