<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>exadrums - news</title>
        <link>https://news.exadrums.com/feed.xml</link>
        <description>eXaDrums project: latest news.</description>
        <lastBuildDate>Sun, 08 May 2022 19:58:28 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/nuxt-community/feed-module</generator>
        <item>
            <title><![CDATA[TD-4KP Configuration]]></title>
            <link>https://news.exadrums.com/article/TD-4KP-configuration</link>
            <guid>https://news.exadrums.com/article/TD-4KP-configuration</guid>
            <pubDate>Mon, 27 Sep 2021 20:26:32 GMT</pubDate>
            <description><![CDATA[You might not now that you can export and import your exadrums configuration.
This is a simple feature, but it can be very useful to create backups of your drum kits, or share them.
The first eXaDrums triggers input board has been designed for the Roland TD-4KP.
Wouldn't be nice to save all the triggers settings, instruments sounds, etc. for this drum kit, so that anyone can play with the TD-4KP?
Here's why I'm sharing the configuration I've been using for my tests on that drum kit: https://github.com/SpintroniK/exadrums-data/tree/TD-4KP.]]></description>
            <content:encoded><![CDATA[
You might not now that you can export and import your exadrums configuration.
This is a simple feature, but it can be very useful to create backups of your drum kits, or share them.
The first eXaDrums triggers input board has been designed for the Roland TD-4KP.
Wouldn't be nice to save all the triggers settings, instruments sounds, etc. for this drum kit, so that anyone can play with the TD-4KP?
Here's why I'm sharing the configuration I've been using for my tests on that drum kit: [https://github.com/SpintroniK/exadrums-data/tree/TD-4KP](https://github.com/SpintroniK/exadrums-data/tree/TD-4KP).

<!--more-->

If you click on the link, you'll notice that there's a little Readme file to help you install the kit.
It's a very simple and quick operation.

With any luck, reading this post will make you want to export some of your kits.
I think this is one of the steps that will add a social dimension to exadrums, so be prepared to see more things going in that direction in the future!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Debian 11 - Bullseye]]></title>
            <link>https://news.exadrums.com/article/debian-bullseye</link>
            <guid>https://news.exadrums.com/article/debian-bullseye</guid>
            <pubDate>Sat, 14 Aug 2021 12:08:07 GMT</pubDate>
            <description><![CDATA[Today, Debian 11 (Bullseye), has been officially released. This is a great news for exadrums, as this means it is now available in Debian. If you're using Debian (or Ubuntu, Raspberry Pi OS, and some other distros), you can install exadrums via apt, i.e.:
sudo apt install exadrums
]]></description>
            <content:encoded><![CDATA[
Today, Debian 11 (Bullseye), has been officially released. This is a great news for *exadrums*, as this means it is now available in Debian. If you're using Debian (or Ubuntu, Raspberry Pi OS, and some [other distros](https://repology.org/project/exadrums/packages)), you can install exadrums via `apt`, i.e.:

```bash
sudo apt install exadrums
```
<!--more-->

## What does this mean?

Well, if you have about 5 MB to spare, you can install exadrums from the command line directly.
Here's what you see from a fresh Debian Bullseye install:

![image](/images/debian-bullseye/Screenshot_2021-08-15_11-14-02.png)

No more compiling, etc. `apt` handles everything for you!

## What about Raspberry Pi OS?

It's only been a few hours since Debian 11 has been released, so there's no news about the next Raspberry Pi OS (formerly Raspbian). Let's give them some time to publish a proper release.
I can already tell you that you'll get the same version of exadrums as Debian in Raspberry Pi OS, it'll be exadrums 0.6.0.

Anyhow, when the new Raspberry Pi OS will be released, you'll be able to install exadrums via `apt` on your Raspberry Pi.

## Using Debian Bullseye on a Raspberry Pi

If you don't want to wait until the version of Raspberry Pi OS comes out, you can install Debian Bullseye on your Raspberry Pi using one of the images available at: [ Tested images](https://raspi.debian.net/tested-images/). I haven't tried any of them, but they've been tested, so they should work.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Exadrums.com]]></title>
            <link>https://news.exadrums.com/article/exadrums-dot-com</link>
            <guid>https://news.exadrums.com/article/exadrums-dot-com</guid>
            <pubDate>Wed, 01 Sep 2021 17:04:20 GMT</pubDate>
            <description><![CDATA[The official exadrums website, exadrums.com, is online.
It shows that there's more than a just software to exadrums.
Even though it is more a landing page than a website, it gives valuable information about the project.
And frankly, I'm quite proud of the video!

    
        
            
            
             
            Your browser does not support the video tag.
        
    
]]></description>
            <content:encoded><![CDATA[
The official exadrums website, [exadrums.com](https://exadrums.com), is online.
It shows that there's more than a just software to exadrums.
Even though it is more a landing page than a website, it gives valuable information about the project.
And frankly, I'm quite proud of the video!

<div class="columns">
    <div class="column has-text-centered is-centered">
        <video controls="" playsinline loop style="max-width: 40%;" poster="/images/exadrums-dot-com/hero_img.jpg">
            <source src="https://freewebmaster.fr/exadrums.com/assets/exadrums_hero_video.mp4" type="video/mp4">
            <source src="https://freewebmaster.fr/exadrums.com/assets/exadrums_hero_video.webm" type="video/webm">
            <source src="https://freewebmaster.fr/exadrums.com/assets/exadrums_hero_video.ogv" type="video/ogg"> 
            Your browser does not support the video tag.
        </video>
    </div>
</div>

<!--more-->

The website's goal is also to explain how to build an exadrums module.
Building the whole module (which is currently designed to work with the Roland TD4-KP), requires three main steps:

- To install the software on a Raspberry Pi
- To make the trigger input board.
- To 3D-print the enclosure.

Just so you know, you don't have to go through each step, as you can already play a fair bit with the software even on your PC or laptop.

There is also this _Make your Own_ button, which redirects to another web page that is currently under construction.
This page will be a custom user guide generator.

The idea is that everyone wants something different (or have a different drum set configuration), so it makes sense to have a custom user guide.
I'll keep you informed about the progress I make on that page.
It should be available in a few weeks, or a few months.
I'm not in a rush, as my goal is to make the best user guide possible.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to Make a Modern Drum Module]]></title>
            <link>https://news.exadrums.com/article/how-to-make-a-drum-module</link>
            <guid>https://news.exadrums.com/article/how-to-make-a-drum-module</guid>
            <pubDate>Sat, 02 Oct 2021 06:27:36 GMT</pubDate>
            <description><![CDATA[Over the past few years, I've worked on improving exadrums to make it as complete as possible.
However, before that, I spent a lot of time making sure the software and hardware would meet some very specific requirements.
On the software side, the latency had to be below 10ms, and the sound quality at least as good as our dear old compact discs.
And on the hardware side, the trigger input board had to preserve the piezos' dynamics, and be compatible with most edrums out there.
Achieving all of this wasn't an easy task, and took about three years, from September 2015 to September 2018.
Moreover, exadrums had to be a modern and accessible drum module. Which is why it is based on the Raspberry Pi (2+) and uses a 7" touchscreen. So, September 2018 was the confirmation that all those targets were reached, and it was time to write down how all these things came together.]]></description>
            <content:encoded><![CDATA[
Over the past few years, I've worked on improving exadrums to make it as complete as possible.
However, before that, I spent a lot of time making sure the software and hardware would meet some very specific requirements.
On the software side, the latency had to be below 10ms, and the sound quality at least as good as our dear old compact discs.
And on the hardware side, the trigger input board had to preserve the piezos' dynamics, and be compatible with most edrums out there.
Achieving all of this wasn't an easy task, and took about three years, from September 2015 to September 2018.

Moreover, exadrums had to be a *modern* and accessible drum module. Which is why it is based on the Raspberry Pi (2+) and uses a 7" touchscreen. So, September 2018 was the confirmation that all those targets were reached, and it was time to write down how all these things came together.

<!--more-->

## How to Make it Work as Expected?

About three years ago, I wrote a short article that describes how and why I defined the software and hardware requirements, but also how I managed to make everything work as expected. I'll go into a bit more details below, but you can skip that part if you're in a hurry, and go straight to the article.

## Making a Modern Drum Module

Making a modern drum module means breaking the rules. Nearly a hundred percent of the existing drum modules use a microcontroller to leverage their real-time properties. However, that means that the amount of memory is often limited, and the user interface is rudimentary (buttons, sliders, etc.), and can't evolve without modifying the hardware.

By choosing the Raspberry Pi, I made it possible to have a modern user interface, using a touchscreen, but I lost all the real-time goodness that microcontrollers have to offer.
Fortunately, there was a solution to reduce the latency with a Raspberry Pi.
Unsurprisingly, getting more performance means going low-level, but also getting a good soundcard.
The soundcard latency represents a third of the total latency.
The software adds another third, and the last third is the trigger scan time.

## Making a Trigger Input Board

Making a trigger input board, is not overly complicated. But there are still two big challenges:

- Make sure all the components fit on the board.
- Find a way to make the board compatible with all the drum pads out there.

The first challenge is not too hard, thanks to SMD components. Especially for a 8-input board. That'll be a bit more difficult with 16 inputs...
As for making the board compatible with all the drum pads, I decided to connect potentiometers to the piezos, so that their output voltage can be scaled down if necessary. That avoids the biggest problem: clipping!

## How to Make a Modern Drum Module

Now that you've got the context, maybe you'd like to read the article, so here it is.
If for some reason your web browser doesn't show the pdf, here's a link to it: <a href="/docs/how-to-make-a-drum-module/HTMADM.pdf" target="_blank">How to Make a Modern Drum Module</a>.
<object data="/docs/how-to-make-a-drum-module/HTMADM.pdf" type="application/pdf" style="width: 100%; height: 100vh"></object>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[libexadrums.js]]></title>
            <link>https://news.exadrums.com/article/libexadrums-js</link>
            <guid>https://news.exadrums.com/article/libexadrums-js</guid>
            <pubDate>Sat, 16 Oct 2021 13:26:21 GMT</pubDate>
            <description><![CDATA[Achieving low latency and performance for exadrums was possible thanks to the C++ programming language.
C++ is a great language because it offers both low- and high-level programming styles, but I find it a bit limited when it comes to user interfaces.
On the other hand, javascript isn't the best language for performance, but or user interfaces it really shines, thanks to its integration with html and css.
But can we get a nice and responsive html + css + js user interface, and get the C++ performance?
That's what libexadrums.js does.
It is basically javascript a wrapper of the exadrums C++ library (libexadrums).
Using the Node-API interface, (lib)exadrums can be used in any nodejs project, with almost no performance loss.
It is a node package that brings libexadrums to the nodejs world, and you can find it here: https://www.npmjs.com/package/@exadrums/libexadrums.js.]]></description>
            <content:encoded><![CDATA[
Achieving low latency and performance for exadrums was possible thanks to the C++ programming language.
C++ is a great language because it offers both low- and high-level programming styles, but I find it a bit limited when it comes to user interfaces.
On the other hand, javascript isn't the best language for performance, but or user interfaces it really shines, thanks to its integration with html and css.

But can we get a nice and responsive html + css + js user interface, and get the C++ performance?
That's what [libexadrums.js](https://github.com/SpintroniK/libexadrums.js) does.
It is basically javascript a wrapper of the exadrums C++ library (libexadrums).
Using the Node-API interface, (lib)exadrums can be used in any nodejs project, with almost no performance loss.
It is a node package that [brings libexadrums to the nodejs world](https://news.exadrums.com/article/the-future-of-exadrums), and you can find it here: https://www.npmjs.com/package/@exadrums/libexadrums.js.

<!--more-->

## How it works

The way libexadrums.js works is very simple, it is just a javascript wrapper around the original C++ library.
Every function call is translated from javascript to a C++ function call.

So when you start your drum module, a javascript function calls the C++ start function, which in turns starts the module.
But the cool thing is, once the module has started, it runs the native compiled C++ program, so there's no performance hit whatsoever.
That way, you do get the best of both worlds.

## What's next?

So far, libexadrums.js is not complete, some functions are missing, and it will take some time to add them.
But the main goal is to make a better user interface.
The plan is to develop an [electron](https://www.electronjs.org/) application, that will become an alternative to the native C++ interface.
I don't think it will replace it, but it'll be used by people who want a more connected experience.

Imagine a user interface than leverages CSS transitions, animations, together with [vuejs](https://vuejs.org/), and javascript's fetch api. I think that can make the development easier, and faster. And hopefully drummers that use exadrums will highly benefit from that!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[New Arduino Nano Every Trigger Board - Part 1]]></title>
            <link>https://news.exadrums.com/article/new-arduino-nano-every-board-part1</link>
            <guid>https://news.exadrums.com/article/new-arduino-nano-every-board-part1</guid>
            <pubDate>Sun, 01 May 2022 12:41:05 GMT</pubDate>
            <description><![CDATA[This project has been in the works for about a year.
I often get questions about MIDI support, so I spent some time developing a new exadrums board that supports MIDI.
Before we start, please note that this post will be split into several parts.
The board is capable of handling 8 triggers.
It can send MIDI notes over USB, or directly to a serial device such as a Raspberry Pi.
There is no on-board Analog to Digital Converter (ADC). Instead, there are two 15-position Arduino Nano-compatible female headers.
Any microcontroller that is pin-compatible with the Arduino Nano will fit.
For the rest of this post, I'll assume that the microcontroller is an Arduino Nano Every.
But before we dive into the details, check out that board!


Board alone (left), and board with Arduino mounted on (right).
I went for a blue PCB so that it would match the Arduino's color.]]></description>
            <content:encoded><![CDATA[
This project has been in the works for about a year.
I often get questions about MIDI support, so I spent some time developing a new exadrums board that supports MIDI.
Before we start, please note that this post will be split into several parts.

The board is capable of handling 8 triggers.
It can send MIDI notes over USB, or directly to a serial device such as a Raspberry Pi.
There is no on-board Analog to Digital Converter (ADC). Instead, there are two 15-position Arduino Nano-compatible female headers.
Any microcontroller that is pin-compatible with the Arduino Nano will fit.
For the rest of this post, I'll assume that the microcontroller is an Arduino Nano Every.

But before we dive into the details, check out that board!

![image](/images/new-arduino-nano-every-board/board.png)
![image](/images/new-arduino-nano-every-board/board-arduino.png)

Board alone (left), and board with Arduino mounted on (right).
I went for a blue PCB so that it would match the Arduino's color.


<!--more-->

## Board Specs

So far, with an Arduino Nano Every, I've achieved the following:

- Compatible with Roland TD-9, TD-11, TD-15, TD-17, TD-25, and TD-27-based edrum kits (DB25 connector).
- Sample rate greater than 70ksps (kilo samples per second).
- Nearly 9 samples per milliseconds and per channel (8.93 in average).
- Configurable trigger parameters: threshold, scan time and mask time (1ms step).
- Configurable MIDI channel and notes.

Using 7 of the 8 inputs (the pads only), I managed to optimize the firmware quite a bit, as it fits into less than 2k bytes of flash and uses less than 128 bytes of RAM. Of course, this will increase a little when the hi-hat pedal code will be added.

## This New Board is Called TB08-SE

This new board's name is *eXaDrums TB08-SE*.
Read *eXaDrums Trigger Board, 8 inputs, Special Edition*.
I consider this board a special edition because this is the first exadrums board that is MIDI-compliant, and also because it is modular.
As you can see on the photos above, the Arduino isn't soldered to the board, which means you can use another microcontroller if you want to (for instance an STM32 Nucleo board). As long as the pinout is compabitle, of course. Note that I don't recommend the Arduino Nano for this board, as its ADC is way too slow. The Arduino Nano Every, on the other hand, is a perfect fit!

## How it Works

### Analog Circuitry

The analog part of the board is quite straightforward. It uses op-amps and passive components to scale down the piezo voltage to the 0-3.3V range.
At rest, the output voltage is 1.65V (3.3V/2).
Among the 8 inputs, 7 are intended to be used with single-zone pads, and one is to be used with a hi-hat controller.

Here's how everything is wired:

|  Instrument   | Cable Reference | Arduino Analog Input | ATMega4809 Analog Input |
|---------------|-----------------|----------------------|-------------------------|
| Kick          |  KIK            |  A0                  |  AIN3                   |
| Snare         |  SNR            |  A1                  |  AIN2                   |
| Hi-hat        |  HH             |  A2                  |  AIN1                   |
| Hi-hat Control|  HHC            |  A3                  |  AIN0                   |
| Crash         |  CR1            |  A4                  |  AIN12                  |
| Tom1          |  T1             |  A5                  |  AIN13                  |
| Tom3          |  T3             |  A6                  |  AIN4                   |
| Ride          |  RD             |  A7                  |  AIN5                   |

### Arduino Nano Every

I chose the Arduino Nano Every because it's affordable, popular, small, and more importantly, because it has the right specs for the job!
The on-board ATMega4809 has plenty of flash and RAM, so I knew these wouldn't cause any issues.
The ADC is a crucial element for an edrum project, and the ATMega4809 has a 10-bit ADC that is capable of running at a 115ksps.
For a 8-input board, that means about 14 samples per millisecond and per channel, which is quite good (it's recommended to get, at the very least, 5 samples per ms and per channel. But usually, [it's best to get around 10 samples/ms/channel](https://www.vdrums.com/forum/advanced/technical/1215866-edrumin-let-s-talk-about-it?p=1216107#post1216107)).

However, the ATMega4809 isn't a powerful beast. First of all, the Arduino Nano Every runs at 16MHz by default.
Although you can change the CPU clock to a slightly higher frequency of 20MHz, I decided not to do that in order to keep things simple (and challenging).
You might think that 16MHz is quite a lot, after all it means that one clock cycle is as short as 62.5ns, but there's another catch.
The ATMega4809 is an 8-bit microcontroller, which means that even adding two 32-bit integers requires several clock cycles.
So, when you only have a few microseconds between each ADC reading, it's kind of foolish to consider floating point arithmetic...
FIY, the Arduino Nano Every's score at the CoreMark CPU Benchmark is 8.20, where 32-bit microcontroller such as the Teensy 3.2 (72MHz) scores well above 100, and a Teensy 3.6 gets a core of 440, [which is more than 50 times the Arduino Nano Every score](https://github.com/PaulStoffregen/CoreMark).

So with all those limitations in mind, I decided to go for 12 microseconds between each sample.
That leaves around 200 instructions (per channel) for all the computations.
Unfortunately, that was a bit ambitious, so I had to increase that time to 14µs, which leads to almost 9 samples per millisecond and per channel.
But you already knew that if you read the post from the beginning.

## The Devil is in the Details

So what do we need to make this work?
Here's a list I came up with when I was starting to think about this project.
We need to:

- Get at least 5 samples per milliseconds and per channel.
- Provide an internal time reference.
- Avoid floating point numbers and complex calculations.
- Use hardware capabilities whenever possible.
- Go as low level as possible to optimize computations.
- Write high level code to improve readability.

But how to go as high level as possible and optimize the code at the same time?
To be honest, I didn't even think about that at first...
I started to write all the code in C, so that I could get a working prototype.
Then I introduced some high level C++ to improve the code readability.
As I was doing that, I noticed the compiled program was getting smaller and smaller.
So, without any massive effort, I managed to write high level readable code that was also quite optimized.
At some point, the program was mainly written in C and was using 978 bytes of flash.
Rewriting the same program in C++ decreased the program size to 918 bytes.
I didn't try to find the reason why that is, but my conclusion was that gcc is awesome!

## What's Next?

It would take a long time to describe everything that's going on, so I'll stop here for now and cover more things in part 2.
The next part will be about getting the code to compile and upload to the Arduino board, without the Arduino library.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[New Arduino Nano Every Trigger Board - Part 2]]></title>
            <link>https://news.exadrums.com/article/new-arduino-nano-every-board-part2</link>
            <guid>https://news.exadrums.com/article/new-arduino-nano-every-board-part2</guid>
            <pubDate>Sun, 08 May 2022 15:42:25 GMT</pubDate>
            <description><![CDATA[This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 1.
In this part, I'm going to describe how to compile C++ code and upload it to the Arduino Nano Every without using the Arduino library.
But why would one want to do that, you may ask?
The answer is simple: the Arduino library does a lot of things that may impact performance.
For instance, some interrupts are being fired frequently, and slow things down.
Let's be honest, we're not going to reinvent the wheel, most of what we are going to do here is to use the Arduino IDE's compiler and tools.
Say we install the Arduino IDE (version 1.8.9) and compile a program.
Here's what we're going to see:

The interesting part is the console, where all the compilation-related messages are shown.
We see that the IDE uses avr-gcc version 7.3.0, along with a few other tools.
Let's see what we can do with that.]]></description>
            <content:encoded><![CDATA[
This is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 1](/article/new-arduino-nano-every-board-part1).
In this part, I'm going to describe how to compile C++ code and upload it to the Arduino Nano Every without using the Arduino library.

But why would one want to do that, you may ask?
The answer is simple: the Arduino library does a lot of things that may impact performance.
For instance, some interrupts are being fired frequently, and slow things down.

Let's be honest, we're not going to reinvent the wheel, most of what we are going to do here is to use the Arduino IDE's compiler and tools.
Say we install the Arduino IDE (version 1.8.9) and compile a program.
Here's what we're going to see:

![image](/images/new-arduino-nano-every-board/arduino-ide.png)

The interesting part is the console, where all the compilation-related messages are shown.
We see that the IDE uses avr-gcc version 7.3.0, along with a few other tools.
Let's see what we can do with that.

<!--more-->

First of all, we can see *where* all these tools are located.
A little digging reveals that an environment variable named *AVR_TOOLS_DIR* contains the tools folder location.
Thus, we can type the following: `$AVR_TOOLS_DIR/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin/avr-gcc --version` and execute the command in a terminal.
This will print the avr-gcc version.

## Makefile for the Arduino Nano Every

This is not a tutorial about makefiles, if you want an in-depth tutorial about makefiles, please read the official [GNU Make Manual](https://www.gnu.org/software/make/manual/).
With that out of the way, let's write a makefile.

### Variables

First of all, we need to define some variables.
Having the avr-gcc bin directory as variable seems like a good idea, so we define the following: `BIN_DIR?=${AVR_TOOLS_DIR}/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin`.
Your bin directory may differ, so be sure to check its correct location.
That's the only variable we'll need for the compiling process.

There's one more thing that we need in order to upload the compiled program to the Arduino, though.
This thing is avrdude.
It's a little bit trickier, as we need the avrdude executable and a configuration file.
So here are our variables:

```makefile
AVRDUDE_DIR?=${AVR_TOOLS_DIR}/avrdude/6.3.0-arduino17/
AVRDUDE?=${AVRDUDE_DIR}/bin/avrdude
CONFDIR?=${AVRDUDE_DIR}/etc/avrdude.conf
```

Again, be sure to check the the executable path.
If you want to provide your own configuration file, you can use the following (sorry, it isn't a short snippet...):

```ini

#------------------------------------------------------------
# AVR8X family common values
#------------------------------------------------------------

part
    id        = ".avr8x";
    desc    = "AVR8X family common values";
    has_updi    = yes;
    nvm_base    = 0x1000;
    ocd_base    = 0x0F80;

    memory "signature"
        size        = 3;
        offset        = 0x1100;
    ;

    memory "prodsig"
        size        = 0x3D;
        offset        = 0x1103;
        page_size    = 0x3D;
        readsize    = 0x3D;
    ;

    memory "fuses"
        size        = 9;
        offset        = 0x1280;
    ;

    memory "fuse0"
        size        = 1;
        offset        = 0x1280;
    ;

    memory "fuse1"
        size        = 1;
        offset        = 0x1281;
    ;

    memory "fuse2"
        size        = 1;
        offset        = 0x1282;
    ;

    memory "fuse4"
        size        = 1;
        offset        = 0x1284;
    ;

    memory "fuse5"
        size        = 1;
        offset        = 0x1285;
    ;

    memory "fuse6"
        size        = 1;
        offset        = 0x1286;
    ;

    memory "fuse7"
        size        = 1;
        offset        = 0x1287;
    ;

    memory "fuse8"
        size        = 1;
        offset        = 0x1288;
    ;

    memory "lock"
        size        = 1;
        offset        = 0x128a;
    ;

    memory "data"
        # SRAM, only used to supply the offset
        offset        = 0x1000000;
    ;
;


#------------------------------------------------------------
# AVR8X mega family common values
#------------------------------------------------------------

part parent    ".avr8x"
    id            = ".avr8x_mega";
    desc        = "AVR8X mega family common values";
    family_id    = "megaAVR";

    memory "usersig"
        size        = 0x40;
        offset        = 0x1300;
        page_size    = 0x40;
        readsize    = 0x100;
    ;
;

#------------------------------------------------------------
# ATmega4809
#------------------------------------------------------------

part parent    ".avr8x_mega"
    id        = "m4809";
    desc      = "ATmega4809";
    signature = 0x1E 0x96 0x51;

    memory "flash"
        size      = 0xC000;
        offset    = 0x4000;
        page_size = 0x80;
        readsize  = 0x100;
    ;

    memory "eeprom"
        size      = 0x100;
        offset    = 0x1400;
        page_size = 0x40;
        readsize  = 0x100;
    ;
;

programmer
  id    = "jtag2updi";
  desc  = "JTAGv2 to UPDI bridge";
  type  = "jtagmkii_pdi";
  connection_type = serial;
  baudrate = 115200;
;

```

And the last variable that we need is the Arduino serial port: `PORT?=/dev/ttyACM0`.
You can find that information in the Arduino IDE (in the *tools* menu).

### Rules

Now that we have defined all the variables that we need, we have to create some rules to compile and upload our code to the Arduino.
To that end, we are going to have three rules: `all`, to compile the code, `upload`, to upload the binary to the board, and `clean` to remove all the build files.

Let's start with the `all` rule:

```makefile
all:
    ${BIN_DIR}/avr-g++ -c -g -Os -w -std=c++17 -fpermissive -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -Wno-error=narrowing -MMD -flto -mmcu=atmega4809 -DF_CPU=16000000L -DARDUINO=10809 -DARDUINO_AVR_NANO_EVERY main.cpp -o main.o
    ${BIN_DIR}/avr-g++ -w -Os -g -flto -fuse-linker-plugin -Wl,--gc-sections -Wl,--section-start=.text=0x0 -mmcu=atmega4809 -o main.elf main.o
    ${BIN_DIR}/avr-objcopy -O binary -R .eeprom main.elf main.bin
    ${BIN_DIR}/avr-objcopy -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 main.elf main.eep
    ${BIN_DIR}/avr-objcopy -O ihex -R .eeprom main.elf main.hex
    ${BIN_DIR}/avr-size -C main.elf
```

This mostly comes from the Arduino IDE's console output window.
I've made only very small modifications.
The `upload` rule is also taken from the Arduino IDE:

```makefile
upload:
    python3 ./reset.py ${PORT}
    ${AVRDUDE} -C${CONFDIR} -v -patmega4809 -cjtag2updi -P${PORT} -b115200 -e -D -Uflash:w:main.hex:i -Ufuse2:w:0x01:m -Ufuse5:w:0xC9:m -Ufuse8:w:0x00:m
```

There is one subtle thing here.
If we check the Arduino IDE's console output, we can read the following message: `Forcing reset using 1200 bps open/close on port /dev/ttyACM0`.
This means that we need to reset the Arduino before avrdude starts uploading the program.
I found that the more reliable way to do that is to use a little python3 script:

```python
#!/usr/bin/python

import sys
import serial

com = serial.Serial(sys.argv[1], 1200)
com.dtr=False
com.close()
```

Finally, we need a `clean` rule that removes all the compiled files.
This is a pretty easy rule to write, so I'll just throw the whole makefile there:

```makefile
BIN_DIR?=${AVR_TOOLS_DIR}/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin
AVRDUDE_DIR?=${AVR_TOOLS_DIR}/avrdude/6.3.0-arduino17/
AVRDUDE?=${AVRDUDE_DIR}/bin/avrdude
CONFDIR?=${AVRDUDE_DIR}/etc/avrdude.conf

PORT?=/dev/ttyACM0

all:
    ${BIN_DIR}/avr-g++ -c -g -Os -w -std=c++17 -fpermissive -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -Wno-error=narrowing -MMD -flto -mmcu=atmega4809 -DF_CPU=16000000L -DARDUINO=10809 -DARDUINO_AVR_NANO_EVERY main.cpp -o main.o
    ${BIN_DIR}/avr-g++ -w -Os -g -flto -fuse-linker-plugin -Wl,--gc-sections -Wl,--section-start=.text=0x0 -mmcu=atmega4809 -o main.elf main.o
    ${BIN_DIR}/avr-objcopy -O binary -R .eeprom main.elf main.bin
    ${BIN_DIR}/avr-objcopy -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 main.elf main.eep
    ${BIN_DIR}/avr-objcopy -O ihex -R .eeprom main.elf main.hex
    ${BIN_DIR}/avr-size -C main.elf


upload:
    python3 ./reset.py ${PORT}
    ${AVRDUDE} -C${CONFDIR} -v -patmega4809 -cjtag2updi -P${PORT} -b115200 -e -D -Uflash:w:main.hex:i -Ufuse2:w:0x01:m -Ufuse5:w:0xC9:m -Ufuse8:w:0x00:m


clean:
    rm -f main.bin main.d main.eep main.elf main.hex main.o
```

There we are, all that's left is to put this in a `Makefile`file.
Now we can type `make` to compile the code and `make upload` to upload it to the board.

## Example: Blink the On-board LED

We are going to go through a very simple example: the LED blink example.

### Arduino Version

Here's the Arduino code for the LED blink example:

```cpp
const int ledPin = 13;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  digitalWrite(ledPin, HIGH);   // set the LED on
  delay(1000);                  // wait for a second
  digitalWrite(ledPin, LOW);    // set the LED off
  delay(1000);                  // wait for a second
}
```

Using the Arduino IDE to compile this code, we get the following message:

```text
Sketch uses 1118 bytes (2%) of program storage space. Maximum is 49152 bytes.
Global variables use 22 bytes (0%) of dynamic memory, leaving 6122 bytes for local variables. Maximum is 6144 bytes.
```

So, in order to make a LED blink every second, we need 1118 bytes of program space, and 22 bytes of RAM.
To me, that sounds like a lot!

### C Version

Now let's go low-level and see what we can do without using the Arduino library.
Since we're using a C++ compiler, it's not really C code, but it looks like it is:

```cpp
#include <avr/io.h>
#include <util/delay.h>

int main()
{
    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler

    PORTE.DIRSET |= PIN2_bm;

    for(;;)
    {
        _delay_ms(1000);
        PORTE.OUTTGL |= PIN2_bm;
    }

    return 0;
}
```

The first line of the main function is used to disable the prescaler, which ensures that the CPU runs at the wanted 16MHz frequency.
If you check out the Arduino Nano Every connector pinouts, you'll see that the on-board LED is connected to `D13`.
This pin is also labeled `SCK` and `PE2`.
The latter tells us that this particular pin is wired to port E, pin 2.
And that's all we need for our LED blink example.
First we use the `DIRSET` register of port E to set the pin 2 bit, which will set pin 2 as an output.
Then, in the main for loop, we write the pin 2 bit into the `OUTTGL` register, which toggles the state of pin 2.
In between each toggling, we use the `_delay_ms` function, which allows us to wait for a given time.

The ports registers and pins definitions are provided by the `avr/io.h` header which contains everything we need.
Because we passed the `-mmcu=atmega4809` flag to avr-gcc in our makefile, it knows that we are using an ATMega4809.
The `_delay_ms` function comes from `util/delay.h`, it needs to know the CPU clock frequency, which why we passed to avr-gcc using `-DF_CPU=16000000L`.

This program does the same thing as the previous one, except it uses a lot less memory and needs no RAM:

```text
AVR Memory Usage
----------------
Device: Unknown

Program:     238 bytes
(.text + .data + .bootloader)

Data:          0 bytes
(.data + .bss + .noinit)
```

### C++ Version

Okay, so I'm not a big fan of C, and I wonder if we could make this code more readable.
I would like to be able to write something like `led.Toggle()` instead of `PORTE.OUTTGL |= PIN2_bm`.

In order to be as generic as possible, we are going to define a class that allows pin manipulation.
One more thing: I really don't like pointers, so we are going to try to avoid them at all cost.

First of all, we need to know how `PORTE` is defined.
Its definition lies in the `avr/include/avr/iom4809.h` file: `#define PORTE                (*(PORT_t *) 0x0480) /* I/O Ports */`, where `PORT_t` is a big struct with a bunch of `register_t` in it.
Fort instance, `OUTTGL` and `DIRSET` are in that struct.
And here's where it gets kind of ugly: `typedef volatile uint8_t register8_t;`.
Every `register8_t` is declared as volatile, which makes sense because our LED blink wouldn't work otherwise (the compiler would optimize away the `PORTE.OUTTGL |= PIN2_bm` line).

So, the first thing that we need, is the address of `PORTE`.
Because of that `volatile` keyword, we can't use `constexpr` nor `static_cast`, so we are going to define it as: `static const auto PORTE_ADDR = reinterpret_cast<uint16_t>(&PORTE);`.
Note that this is a 16-bit address

Now we define a pin as a port and a pin number.
In our case: port E (its address) and pin 2 (its bit mask).
These two things are known at compile time, so we can use them as template parameters.
Hence, we are going to define a `Pin` class that take these two parameters as template parameters:

```cpp
namespace DigitalIO
{

    static const auto PORTE_ADDR = reinterpret_cast<uint16_t>(&PORTE);

    template <uint16_t portAddr, uint8_t mask>
    class Pin
    {
    public:
        Pin() = delete;
        ~Pin() = delete;

        static constexpr void ConfigureAsInput()
        {
            port().DIRSET &= ~mask;
        }

        static constexpr void ConfigureAsOutput()
        {
            port().DIRSET |= mask;
        }

        static constexpr void Toggle()
        {
            port().OUTTGL |= mask;
        }

        static constexpr void SetHigh()
        {
            port().OUTSET |= mask;
        }

        static constexpr void SetLow()
        {
            port().OUTCLR |= mask;
        }

        static constexpr auto& port()
        {
            return *reinterpret_cast<PORT_t*>(portAddr);
        }
        
    private:

    };
    
} // namespace IO
```

We need to cast the port address back to a `PORT_t` struct, which is the role of the `port()` function.
The rest of the code is pretty straightforward, we encapsulate our C code into `static` methods.

Here's how to use this code:

```cpp
#include "DigitalIO.h"

#include <avr/io.h>
#include <util/delay.h>

#include <stdint.h>

using Led = DigitalIO::Pin<DigitalIO::PORTE_ADDR, PIN2_bm>;

int main()
{
    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler

    Led::ConfigureAsOutput();

    for(;;)
    {
        _delay_ms(1000);
        Led::Toggle();
    }

    return 0;
}
```

It looks almost the same as the previous code, except that it's a bit more readable.

But we did add quite a bit of boilerplate code in our `DigitalIO.h` file, is that a good idea?
I believe it is. Right now, we don't see how this can be very useful because our program is small and basic.
With a bigger code base, I think it would be way easier to understand our code with a well-structured C++ program.

But wait a minute, isn't all that code going to add more bytes to our program?
Let's check that, shall we?

```text
AVR Memory Usage
----------------
Device: Unknown

Program:     238 bytes
(.text + .data + .bootloader)

Data:          0 bytes
(.data + .bss + .noinit)
```

It doesn't. In fact the assembly code is exactly the same as the previous one.
Why is that? Because gcc is awesome, of course!
So, we can write C++ code and get the same assembly code as a C program, that's what we call *zero cost abstraction*.

## What's Next?

Okay, so we've seen how to program an Arduino Nano Every without using the Arduino library.
Through a very simple example, we've also seen that C and C++ code lead to the same assembly code.

In the next part, we will focus on MIDI and see how we can turn our Arduino Nano Every into a MIDI device.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[New SPI Sensors Configurator ⇒ More Trigger Inputs]]></title>
            <link>https://news.exadrums.com/article/new-spi-sensors-config</link>
            <guid>https://news.exadrums.com/article/new-spi-sensors-config</guid>
            <pubDate>Sat, 11 Dec 2021 13:31:28 GMT</pubDate>
            <description><![CDATA[Exadrums 0.7.0 is currently under development. The biggest feature of this release is the addition of configurable SPI (Serial Peripheral Interface) devices.
This features aims to provide a way to add as many SPI devices as you want.
Currently supported devices are of the MCP3XXX family, including MCP3008, MCP3204, and MCP3208, but there's a good chance more chips will be added before and after the release of this new version.
This means that it'll become possible to add more inputs to the trigger input board, by adding more analog to digital converters.
]]></description>
            <content:encoded><![CDATA[
Exadrums 0.7.0 is currently under development. The biggest feature of this release is the addition of configurable SPI (Serial Peripheral Interface) devices.
This features aims to provide a way to add as many SPI devices as you want.
Currently supported devices are of the MCP3XXX family, including MCP3008, MCP3204, and MCP3208, but there's a good chance more chips will be added before and after the release of this new version.

This means that it'll become possible to add more inputs to the trigger input board, by adding more analog to digital converters.

![image](/images/new-spi-sensors-config/spidev-config.png)

<!--more-->

## How SPI Devices Work

An SPI analog to digital converter takes in analog data, digitizes it, and sends it to a Raspberry Pi using the SPI bus.
SPI communication offers many advantages, and one of them is that it's quite easy to communicate with several devices.
The first eXaDrums input board uses a single MCP3008 chip, which limits the number of inputs to 8.
Adding another MCP3008 would increase that number to 16, and if you want even more inputs, you could add a third one.

The Raspberry Pi offers at least one SPI interface that has two `Chip Select` inputs (also called *Chip Enable*).
So, with a single SPI bus, `SPI0`, the Raspberry Pi can communicate with two devices, by changing the states of the chip selects pins `CE0` and `CE1`.

But that's not it. Recent Raspberry Pis have another SPI *bus*: `SPI1`. And it can handle up to three devices via its three chip select inputs `CE0`, `CE1`, and `CE2`.
So, in theory it's possible to have up to 5 SPI Analog to Digital converters. Imagine 5 MCP3008, that would mean up to 40 inputs!
Note that the Raspberry Pi 4 has even more SPI buses, so that should be more than enough, even for a big drum kit with a lot of triggers.

It's important to note that SPI devices are grouped by bus and chip select, and this is exactly how the SPI configuration works in exadrums.

## How to Configure SPI Devices

Only supported devices are allowed in the SPI configuration dialog. They are currently limited to MCP3008, MCP3204, and MCP3208.
Each device must be associated to a bus and a chip select.
And that's basically it.

Here is an example.
You make a trigger input board that needs to handle up to 16 analog inputs.
The MCP3008 is a good choice, so you decide to use two of them.
You can either have one of them use the `SPI0`, and the other the `SPI1`, or you can have them both use `SPI1` and choose to use two different chip selects, i.e. `CE0` and `CE1`.
So your configuration is:
|  Name   | Bus | CS |
|---------|-----|----|
| MCP3008 |  0  |  0 |
| MCP3008 |  0  |  1 |

And this is exactly how you can configure your SPI devices in exadrums (see screenshot above).
By doing that, you'll be able to create up to 16 triggers, numbered 0 to 15, and everything will work out of the box.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Raspberry Pi OS - Bullseye]]></title>
            <link>https://news.exadrums.com/article/raspberry-pi-os-bullseye</link>
            <guid>https://news.exadrums.com/article/raspberry-pi-os-bullseye</guid>
            <pubDate>Fri, 12 Nov 2021 18:07:46 GMT</pubDate>
            <description><![CDATA[Remember this article about exadrums becoming an official Debian package?
It's now time to play (exa)drums on your Raspberry Pi.
The Raspberry Pi Foundation released the latest Raspberry Pi OS bullseye a few days ago, and as you may have guessed, it includes exadrums packages:

Now, you simply have to type sudo apt install exadrums into a terminal to install exadrums on your Raspberry Pi.]]></description>
            <content:encoded><![CDATA[
Remember this article about [exadrums becoming an official Debian package](article/debian-bullseye)?
It's now time to play (exa)drums on your Raspberry Pi.
The Raspberry Pi Foundation released the latest Raspberry Pi OS *bullseye* a few days ago, and as you may have guessed, it includes exadrums packages:

![image](/images/raspberry-pi-os-bullseye/screenshot.png)

Now, you simply have to type `sudo apt install exadrums` into a terminal to install exadrums on your Raspberry Pi.

<!--more-->

It took some time to get to that point, but you get exadrums 0.6.0, which fairly recent, and works on my Roland TD-4KP drum set.
If you'd like to try exadrums with your TD-4KP drum set, it's quite easy.
First of all, you'll need to install *zip*, as it's not installed by default: `sudo apt install zip`.
Then, you can go to the following page: https://github.com/SpintroniK/exadrums-data/tree/TD-4KP and follow the instructions.

Obviously, the project is still under development and future versions will support more inputs, and have a lot of improvements.
The official documentation is far from being complete, but I'll make sure to add guidelines to help install the latest version of exadrums on a Raspberry Pi. I will make sure the future versions work on the current version of Raspberry Pi OS *bullseye*. Stay tuned, new versions are coming!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Future of exadrums]]></title>
            <link>https://news.exadrums.com/article/the-future-of-exadrums</link>
            <guid>https://news.exadrums.com/article/the-future-of-exadrums</guid>
            <pubDate>Wed, 25 Aug 2021 14:48:20 GMT</pubDate>
            <description><![CDATA[The future of exadrums is probably different than what you may think.
So far, exadrums is a two-part software, there's a library, libexadrums, and another component: the user interface. The whole drum module is in the library, and exposes a C++ API. That means libexadrums can be used with other languages, such as Python, Javascript, etc.]]></description>
            <content:encoded><![CDATA[
The future of exadrums is probably different than what you may think.

So far, exadrums is a two-part software, there's a library, libexadrums, and another component: the user interface. The whole drum module is in the library, and exposes a C++ API. That means libexadrums can be used with other languages, such as Python, Javascript, etc.

<!--more-->

A C++ user interface has its advantages, but exadrums could benefit from other languages. For instance,  a more "connected" experience would be easier to implement in Python or Javascript.

And that's how I see the future of exadrums: a Connected Open Source Drum Module. Some things are already in the works, but others will take some time. However, I'll do my best to publish news more frequently, to keep you informed about the project.

About that, the project website [exadrums.com](https://exadrums.com) will be online pretty soon! Hope you'll like it.
]]></content:encoded>
        </item>
    </channel>
</rss>