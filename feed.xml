<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>exadrums - news</title>
        <link>https://news.exadrums.com/feed.xml</link>
        <description>eXaDrums project: latest news.</description>
        <lastBuildDate>Thu, 07 Jul 2022 10:53:45 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/nuxt-community/feed-module</generator>
        <item>
            <title><![CDATA[Exadrums.com]]></title>
            <link>https://news.exadrums.com/article/exadrums-dot-com</link>
            <guid>https://news.exadrums.com/article/exadrums-dot-com</guid>
            <pubDate>Wed, 01 Sep 2021 17:04:20 GMT</pubDate>
            <description><![CDATA[The official exadrums website, exadrums.com, is online.
It shows that there's more than a just software to exadrums.
Even though it is more a landing page than a website, it gives valuable information about the project.
And frankly, I'm quite proud of the video!

    
        
            
            
             
            Your browser does not support the video tag.
        
    
]]></description>
            <content:encoded><![CDATA[
The official exadrums website, [exadrums.com](https://exadrums.com), is online.
It shows that there's more than a just software to exadrums.
Even though it is more a landing page than a website, it gives valuable information about the project.
And frankly, I'm quite proud of the video!

<div class="columns">
    <div class="column has-text-centered is-centered">
        <video controls="" playsinline loop style="max-width: 40%;" poster="/images/exadrums-dot-com/hero_img.jpg">
            <source src="https://freewebmaster.fr/exadrums.com/assets/exadrums_hero_video.mp4" type="video/mp4">
            <source src="https://freewebmaster.fr/exadrums.com/assets/exadrums_hero_video.webm" type="video/webm">
            <source src="https://freewebmaster.fr/exadrums.com/assets/exadrums_hero_video.ogv" type="video/ogg"> 
            Your browser does not support the video tag.
        </video>
    </div>
</div>

<!--more-->

The website's goal is also to explain how to build an exadrums module.
Building the whole module (which is currently designed to work with the Roland TD4-KP), requires three main steps:

- To install the software on a Raspberry Pi
- To make the trigger input board.
- To 3D-print the enclosure.

Just so you know, you don't have to go through each step, as you can already play a fair bit with the software even on your PC or laptop.

There is also this _Make your Own_ button, which redirects to another web page that is currently under construction.
This page will be a custom user guide generator.

The idea is that everyone wants something different (or have a different drum set configuration), so it makes sense to have a custom user guide.
I'll keep you informed about the progress I make on that page.
It should be available in a few weeks, or a few months.
I'm not in a rush, as my goal is to make the best user guide possible.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[TD-4KP Configuration]]></title>
            <link>https://news.exadrums.com/article/TD-4KP-configuration</link>
            <guid>https://news.exadrums.com/article/TD-4KP-configuration</guid>
            <pubDate>Mon, 27 Sep 2021 20:26:32 GMT</pubDate>
            <description><![CDATA[You might not now that you can export and import your exadrums configuration.
This is a simple feature, but it can be very useful to create backups of your drum kits, or share them.
The first eXaDrums triggers input board has been designed for the Roland TD-4KP.
Wouldn't be nice to save all the triggers settings, instruments sounds, etc. for this drum kit, so that anyone can play with the TD-4KP?
Here's why I'm sharing the configuration I've been using for my tests on that drum kit: https://github.com/SpintroniK/exadrums-data/tree/TD-4KP.]]></description>
            <content:encoded><![CDATA[
You might not now that you can export and import your exadrums configuration.
This is a simple feature, but it can be very useful to create backups of your drum kits, or share them.
The first eXaDrums triggers input board has been designed for the Roland TD-4KP.
Wouldn't be nice to save all the triggers settings, instruments sounds, etc. for this drum kit, so that anyone can play with the TD-4KP?
Here's why I'm sharing the configuration I've been using for my tests on that drum kit: [https://github.com/SpintroniK/exadrums-data/tree/TD-4KP](https://github.com/SpintroniK/exadrums-data/tree/TD-4KP).

<!--more-->

If you click on the link, you'll notice that there's a little Readme file to help you install the kit.
It's a very simple and quick operation.

With any luck, reading this post will make you want to export some of your kits.
I think this is one of the steps that will add a social dimension to exadrums, so be prepared to see more things going in that direction in the future!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Debian 11 - Bullseye]]></title>
            <link>https://news.exadrums.com/article/debian-bullseye</link>
            <guid>https://news.exadrums.com/article/debian-bullseye</guid>
            <pubDate>Sat, 14 Aug 2021 12:08:07 GMT</pubDate>
            <description><![CDATA[Today, Debian 11 (Bullseye), has been officially released. This is a great news for exadrums, as this means it is now available in Debian. If you're using Debian (or Ubuntu, Raspberry Pi OS, and some other distros), you can install exadrums via apt, i.e.:
sudo apt install exadrums
]]></description>
            <content:encoded><![CDATA[
Today, Debian 11 (Bullseye), has been officially released. This is a great news for *exadrums*, as this means it is now available in Debian. If you're using Debian (or Ubuntu, Raspberry Pi OS, and some [other distros](https://repology.org/project/exadrums/packages)), you can install exadrums via `apt`, i.e.:

```bash
sudo apt install exadrums
```
<!--more-->

## What does this mean?

Well, if you have about 5 MB to spare, you can install exadrums from the command line directly.
Here's what you see from a fresh Debian Bullseye install:

![image](/images/debian-bullseye/Screenshot_2021-08-15_11-14-02.png)

No more compiling, etc. `apt` handles everything for you!

## What about Raspberry Pi OS?

It's only been a few hours since Debian 11 has been released, so there's no news about the next Raspberry Pi OS (formerly Raspbian). Let's give them some time to publish a proper release.
I can already tell you that you'll get the same version of exadrums as Debian in Raspberry Pi OS, it'll be exadrums 0.6.0.

Anyhow, when the new Raspberry Pi OS will be released, you'll be able to install exadrums via `apt` on your Raspberry Pi.

## Using Debian Bullseye on a Raspberry Pi

If you don't want to wait until the version of Raspberry Pi OS comes out, you can install Debian Bullseye on your Raspberry Pi using one of the images available at: [ Tested images](https://raspi.debian.net/tested-images/). I haven't tried any of them, but they've been tested, so they should work.]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to Make a Modern Drum Module]]></title>
            <link>https://news.exadrums.com/article/how-to-make-a-drum-module</link>
            <guid>https://news.exadrums.com/article/how-to-make-a-drum-module</guid>
            <pubDate>Sat, 02 Oct 2021 06:27:36 GMT</pubDate>
            <description><![CDATA[Over the past few years, I've worked on improving exadrums to make it as complete as possible.
However, before that, I spent a lot of time making sure the software and hardware would meet some very specific requirements.
On the software side, the latency had to be below 10ms, and the sound quality at least as good as our dear old compact discs.
And on the hardware side, the trigger input board had to preserve the piezos' dynamics, and be compatible with most edrums out there.
Achieving all of this wasn't an easy task, and took about three years, from September 2015 to September 2018.
Moreover, exadrums had to be a modern and accessible drum module. Which is why it is based on the Raspberry Pi (2+) and uses a 7" touchscreen. So, September 2018 was the confirmation that all those targets were reached, and it was time to write down how all these things came together.]]></description>
            <content:encoded><![CDATA[
Over the past few years, I've worked on improving exadrums to make it as complete as possible.
However, before that, I spent a lot of time making sure the software and hardware would meet some very specific requirements.
On the software side, the latency had to be below 10ms, and the sound quality at least as good as our dear old compact discs.
And on the hardware side, the trigger input board had to preserve the piezos' dynamics, and be compatible with most edrums out there.
Achieving all of this wasn't an easy task, and took about three years, from September 2015 to September 2018.

Moreover, exadrums had to be a *modern* and accessible drum module. Which is why it is based on the Raspberry Pi (2+) and uses a 7" touchscreen. So, September 2018 was the confirmation that all those targets were reached, and it was time to write down how all these things came together.

<!--more-->

## How to Make it Work as Expected?

About three years ago, I wrote a short article that describes how and why I defined the software and hardware requirements, but also how I managed to make everything work as expected. I'll go into a bit more details below, but you can skip that part if you're in a hurry, and go straight to the article.

## Making a Modern Drum Module

Making a modern drum module means breaking the rules. Nearly a hundred percent of the existing drum modules use a microcontroller to leverage their real-time properties. However, that means that the amount of memory is often limited, and the user interface is rudimentary (buttons, sliders, etc.), and can't evolve without modifying the hardware.

By choosing the Raspberry Pi, I made it possible to have a modern user interface, using a touchscreen, but I lost all the real-time goodness that microcontrollers have to offer.
Fortunately, there was a solution to reduce the latency with a Raspberry Pi.
Unsurprisingly, getting more performance means going low-level, but also getting a good soundcard.
The soundcard latency represents a third of the total latency.
The software adds another third, and the last third is the trigger scan time.

## Making a Trigger Input Board

Making a trigger input board, is not overly complicated. But there are still two big challenges:

- Make sure all the components fit on the board.
- Find a way to make the board compatible with all the drum pads out there.

The first challenge is not too hard, thanks to SMD components. Especially for a 8-input board. That'll be a bit more difficult with 16 inputs...
As for making the board compatible with all the drum pads, I decided to connect potentiometers to the piezos, so that their output voltage can be scaled down if necessary. That avoids the biggest problem: clipping!

## How to Make a Modern Drum Module

Now that you've got the context, maybe you'd like to read the article, so here it is.
If for some reason your web browser doesn't show the pdf, here's a link to it: <a href="/docs/how-to-make-a-drum-module/HTMADM.pdf" target="_blank">How to Make a Modern Drum Module</a>.
<object data="/docs/how-to-make-a-drum-module/HTMADM.pdf" type="application/pdf" style="width: 100%; height: 100vh"></object>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[libexadrums.js]]></title>
            <link>https://news.exadrums.com/article/libexadrums-js</link>
            <guid>https://news.exadrums.com/article/libexadrums-js</guid>
            <pubDate>Sat, 16 Oct 2021 13:26:21 GMT</pubDate>
            <description><![CDATA[Achieving low latency and performance for exadrums was possible thanks to the C++ programming language.
C++ is a great language because it offers both low- and high-level programming styles, but I find it a bit limited when it comes to user interfaces.
On the other hand, javascript isn't the best language for performance, but or user interfaces it really shines, thanks to its integration with html and css.
But can we get a nice and responsive html + css + js user interface, and get the C++ performance?
That's what libexadrums.js does.
It is basically javascript a wrapper of the exadrums C++ library (libexadrums).
Using the Node-API interface, (lib)exadrums can be used in any nodejs project, with almost no performance loss.
It is a node package that brings libexadrums to the nodejs world, and you can find it here: https://www.npmjs.com/package/@exadrums/libexadrums.js.]]></description>
            <content:encoded><![CDATA[
Achieving low latency and performance for exadrums was possible thanks to the C++ programming language.
C++ is a great language because it offers both low- and high-level programming styles, but I find it a bit limited when it comes to user interfaces.
On the other hand, javascript isn't the best language for performance, but or user interfaces it really shines, thanks to its integration with html and css.

But can we get a nice and responsive html + css + js user interface, and get the C++ performance?
That's what [libexadrums.js](https://github.com/SpintroniK/libexadrums.js) does.
It is basically javascript a wrapper of the exadrums C++ library (libexadrums).
Using the Node-API interface, (lib)exadrums can be used in any nodejs project, with almost no performance loss.
It is a node package that [brings libexadrums to the nodejs world](https://news.exadrums.com/article/the-future-of-exadrums), and you can find it here: https://www.npmjs.com/package/@exadrums/libexadrums.js.

<!--more-->

## How it works

The way libexadrums.js works is very simple, it is just a javascript wrapper around the original C++ library.
Every function call is translated from javascript to a C++ function call.

So when you start your drum module, a javascript function calls the C++ start function, which in turns starts the module.
But the cool thing is, once the module has started, it runs the native compiled C++ program, so there's no performance hit whatsoever.
That way, you do get the best of both worlds.

## What's next?

So far, libexadrums.js is not complete, some functions are missing, and it will take some time to add them.
But the main goal is to make a better user interface.
The plan is to develop an [electron](https://www.electronjs.org/) application, that will become an alternative to the native C++ interface.
I don't think it will replace it, but it'll be used by people who want a more connected experience.

Imagine a user interface than leverages CSS transitions, animations, together with [vuejs](https://vuejs.org/), and javascript's fetch api. I think that can make the development easier, and faster. And hopefully drummers that use exadrums will highly benefit from that!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[New Arduino Nano Every Trigger Board - Part 1]]></title>
            <link>https://news.exadrums.com/article/new-arduino-nano-every-board-part1</link>
            <guid>https://news.exadrums.com/article/new-arduino-nano-every-board-part1</guid>
            <pubDate>Sun, 01 May 2022 12:41:05 GMT</pubDate>
            <description><![CDATA[This project has been in the works for about a year.
I often get questions about MIDI support, so I spent some time developing a new exadrums board that supports MIDI.
Before we start, please note that this post will be split into several parts.
The board is capable of handling 8 triggers.
It can send MIDI notes over USB, or directly to a serial device such as a Raspberry Pi.
There is no on-board Analog to Digital Converter (ADC). Instead, there are two 15-position Arduino Nano-compatible female headers.
Any microcontroller that is pin-compatible with the Arduino Nano will fit.
For the rest of this post, I'll assume that the microcontroller is an Arduino Nano Every.
But before we dive into the details, check out that board!


Board alone (left), and board with Arduino mounted on (right).
I went for a blue PCB so that it would match the Arduino's color.]]></description>
            <content:encoded><![CDATA[
This project has been in the works for about a year.
I often get questions about MIDI support, so I spent some time developing a new exadrums board that supports MIDI.
Before we start, please note that this post will be split into several parts.

The board is capable of handling 8 triggers.
It can send MIDI notes over USB, or directly to a serial device such as a Raspberry Pi.
There is no on-board Analog to Digital Converter (ADC). Instead, there are two 15-position Arduino Nano-compatible female headers.
Any microcontroller that is pin-compatible with the Arduino Nano will fit.
For the rest of this post, I'll assume that the microcontroller is an Arduino Nano Every.

But before we dive into the details, check out that board!

![image](/images/new-arduino-nano-every-board/board.png)
![image](/images/new-arduino-nano-every-board/board-arduino.png)

Board alone (left), and board with Arduino mounted on (right).
I went for a blue PCB so that it would match the Arduino's color.


<!--more-->

## Board Specs

So far, with an Arduino Nano Every, I've achieved the following:

- Compatible with Roland TD-9, TD-11, TD-15, TD-17, TD-25, and TD-27-based edrum kits (DB25 connector).
- Sample rate greater than 70ksps (kilo samples per second).
- Nearly 9 samples per milliseconds and per channel (8.93 in average).
- Configurable trigger parameters: threshold, scan time and mask time (1ms step).
- Configurable MIDI channel and notes.

Using 7 of the 8 inputs (the pads only), I managed to optimize the firmware quite a bit, as it fits into less than 2k bytes of flash and uses less than 128 bytes of RAM. Of course, this will increase a little when the hi-hat pedal code will be added.

## This New Board is Called TB08-SE

This new board's name is *eXaDrums TB08-SE*.
Read *eXaDrums Trigger Board, 8 inputs, Special Edition*.
I consider this board a special edition because this is the first exadrums board that is MIDI-compliant, and also because it is modular.
As you can see on the photos above, the Arduino isn't soldered to the board, which means you can use another microcontroller if you want to (for instance an STM32 Nucleo board). As long as the pinout is compabitle, of course. Note that I don't recommend the Arduino Nano for this board, as its ADC is way too slow. The Arduino Nano Every, on the other hand, is a perfect fit!

## How it Works

### Analog Circuitry

The analog part of the board is quite straightforward. It uses op-amps and passive components to scale down the piezo voltage to the 0-3.3V range.
At rest, the output voltage is 1.65V (3.3V/2).
Among the 8 inputs, 7 are intended to be used with single-zone pads, and one is to be used with a hi-hat controller.

Here's how everything is wired:

|  Instrument   | Cable Reference | Arduino Analog Input | ATMega4809 Analog Input |
|---------------|-----------------|----------------------|-------------------------|
| Kick          |  KIK            |  A0                  |  AIN3                   |
| Snare         |  SNR            |  A1                  |  AIN2                   |
| Hi-hat        |  HH             |  A2                  |  AIN1                   |
| Hi-hat Control|  HHC            |  A3                  |  AIN0                   |
| Crash         |  CR1            |  A4                  |  AIN12                  |
| Tom1          |  T1             |  A5                  |  AIN13                  |
| Tom3          |  T3             |  A6                  |  AIN4                   |
| Ride          |  RD             |  A7                  |  AIN5                   |

### Arduino Nano Every

I chose the Arduino Nano Every because it's affordable, popular, small, and more importantly, because it has the right specs for the job!
The on-board ATMega4809 has plenty of flash and RAM, so I knew these wouldn't cause any issues.
The ADC is a crucial element for an edrum project, and the ATMega4809 has a 10-bit ADC that is capable of running at a 115ksps.
For a 8-input board, that means about 14 samples per millisecond and per channel, which is quite good (it's recommended to get, at the very least, 5 samples per ms and per channel. But usually, [it's best to get around 10 samples/ms/channel](https://www.vdrums.com/forum/advanced/technical/1215866-edrumin-let-s-talk-about-it?p=1216107#post1216107)).

However, the ATMega4809 isn't a powerful beast. First of all, the Arduino Nano Every runs at 16MHz by default.
Although you can change the CPU clock to a slightly higher frequency of 20MHz, I decided not to do that in order to keep things simple (and challenging).
You might think that 16MHz is quite a lot, after all it means that one clock cycle is as short as 62.5ns, but there's another catch.
The ATMega4809 is an 8-bit microcontroller, which means that even adding two 32-bit integers requires several clock cycles.
So, when you only have a few microseconds between each ADC reading, it's kind of foolish to consider floating point arithmetic...
FIY, the Arduino Nano Every's score at the CoreMark CPU Benchmark is 8.20, where 32-bit microcontroller such as the Teensy 3.2 (72MHz) scores well above 100, and a Teensy 3.6 gets a core of 440, [which is more than 50 times the Arduino Nano Every score](https://github.com/PaulStoffregen/CoreMark).

So with all those limitations in mind, I decided to go for 12 microseconds between each sample.
That leaves around 200 instructions (per channel) for all the computations.
Unfortunately, that was a bit ambitious, so I had to increase that time to 14µs, which leads to almost 9 samples per millisecond and per channel.
But you already knew that if you read the post from the beginning.

## The Devil is in the Details

So what do we need to make this work?
Here's a list I came up with when I was starting to think about this project.
We need to:

- Get at least 5 samples per milliseconds and per channel.
- Provide an internal time reference.
- Avoid floating point numbers and complex calculations.
- Use hardware capabilities whenever possible.
- Go as low level as possible to optimize computations.
- Write high level code to improve readability.

But how to go as high level as possible and optimize the code at the same time?
To be honest, I didn't even think about that at first...
I started to write all the code in C, so that I could get a working prototype.
Then I introduced some high level C++ to improve the code readability.
As I was doing that, I noticed the compiled program was getting smaller and smaller.
So, without any massive effort, I managed to write high level readable code that was also quite optimized.
At some point, the program was mainly written in C and was using 978 bytes of flash.
Rewriting the same program in C++ decreased the program size to 918 bytes.
I didn't try to find the reason why that is, but my conclusion was that gcc is awesome!

## What's Next?

It would take a long time to describe everything that's going on, so I'll stop here for now and cover more things in part 2.
The next part will be about getting the code to compile and upload to the Arduino board, without the Arduino library.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[New Arduino Nano Every Trigger Board - Part 2]]></title>
            <link>https://news.exadrums.com/article/new-arduino-nano-every-board-part2</link>
            <guid>https://news.exadrums.com/article/new-arduino-nano-every-board-part2</guid>
            <pubDate>Sun, 08 May 2022 15:42:25 GMT</pubDate>
            <description><![CDATA[This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 1.
In this part, I'm going to describe how to compile C++ code and upload it to the Arduino Nano Every without using the Arduino library.
But why would one want to do that, you may ask?
The answer is simple: the Arduino library does a lot of things that may impact performance.
For instance, some interrupts are being fired frequently, and slow things down.
Let's be honest, we're not going to reinvent the wheel, most of what we are going to do here is to use the Arduino IDE's compiler and tools.
Say we install the Arduino IDE (version 1.8.9) and compile a program.
Here's what we're going to see:

The interesting part is the console, where all the compilation-related messages are shown.
We see that the IDE uses avr-gcc version 7.3.0, along with a few other tools.
Let's see what we can do with that.]]></description>
            <content:encoded><![CDATA[
This is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 1](/article/new-arduino-nano-every-board-part1).
In this part, I'm going to describe how to compile C++ code and upload it to the Arduino Nano Every without using the Arduino library.

But why would one want to do that, you may ask?
The answer is simple: the Arduino library does a lot of things that may impact performance.
For instance, some interrupts are being fired frequently, and slow things down.

Let's be honest, we're not going to reinvent the wheel, most of what we are going to do here is to use the Arduino IDE's compiler and tools.
Say we install the Arduino IDE (version 1.8.9) and compile a program.
Here's what we're going to see:

![image](/images/new-arduino-nano-every-board/arduino-ide.png)

The interesting part is the console, where all the compilation-related messages are shown.
We see that the IDE uses avr-gcc version 7.3.0, along with a few other tools.
Let's see what we can do with that.

<!--more-->

First of all, we can see *where* all these tools are located.
A little digging reveals that an environment variable named *AVR_TOOLS_DIR* contains the tools folder location.
Thus, we can type the following: `$AVR_TOOLS_DIR/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin/avr-gcc --version` and execute the command in a terminal.
This will print the avr-gcc version.

## Makefile for the Arduino Nano Every

This is not a tutorial about makefiles, if you want an in-depth tutorial about makefiles, please read the official [GNU Make Manual](https://www.gnu.org/software/make/manual/).
With that out of the way, let's write a makefile.

### Variables

First of all, we need to define some variables.
Having the avr-gcc bin directory as variable seems like a good idea, so we define the following: `BIN_DIR?=${AVR_TOOLS_DIR}/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin`.
Your bin directory may differ, so be sure to check its correct location.
That's the only variable we'll need for the compiling process.

There's one more thing that we need in order to upload the compiled program to the Arduino, though.
This thing is avrdude.
It's a little bit trickier, as we need the avrdude executable and a configuration file.
So here are our variables:

```makefile
AVRDUDE_DIR?=${AVR_TOOLS_DIR}/avrdude/6.3.0-arduino17/
AVRDUDE?=${AVRDUDE_DIR}/bin/avrdude
CONFDIR?=${AVRDUDE_DIR}/etc/avrdude.conf
```

Again, be sure to check the the executable path.
If you want to provide your own configuration file, you can use the following (sorry, it isn't a short snippet...):

```ini

#------------------------------------------------------------
# AVR8X family common values
#------------------------------------------------------------

part
    id        = ".avr8x";
    desc    = "AVR8X family common values";
    has_updi    = yes;
    nvm_base    = 0x1000;
    ocd_base    = 0x0F80;

    memory "signature"
        size        = 3;
        offset        = 0x1100;
    ;

    memory "prodsig"
        size        = 0x3D;
        offset        = 0x1103;
        page_size    = 0x3D;
        readsize    = 0x3D;
    ;

    memory "fuses"
        size        = 9;
        offset        = 0x1280;
    ;

    memory "fuse0"
        size        = 1;
        offset        = 0x1280;
    ;

    memory "fuse1"
        size        = 1;
        offset        = 0x1281;
    ;

    memory "fuse2"
        size        = 1;
        offset        = 0x1282;
    ;

    memory "fuse4"
        size        = 1;
        offset        = 0x1284;
    ;

    memory "fuse5"
        size        = 1;
        offset        = 0x1285;
    ;

    memory "fuse6"
        size        = 1;
        offset        = 0x1286;
    ;

    memory "fuse7"
        size        = 1;
        offset        = 0x1287;
    ;

    memory "fuse8"
        size        = 1;
        offset        = 0x1288;
    ;

    memory "lock"
        size        = 1;
        offset        = 0x128a;
    ;

    memory "data"
        # SRAM, only used to supply the offset
        offset        = 0x1000000;
    ;
;


#------------------------------------------------------------
# AVR8X mega family common values
#------------------------------------------------------------

part parent    ".avr8x"
    id            = ".avr8x_mega";
    desc        = "AVR8X mega family common values";
    family_id    = "megaAVR";

    memory "usersig"
        size        = 0x40;
        offset        = 0x1300;
        page_size    = 0x40;
        readsize    = 0x100;
    ;
;

#------------------------------------------------------------
# ATmega4809
#------------------------------------------------------------

part parent    ".avr8x_mega"
    id        = "m4809";
    desc      = "ATmega4809";
    signature = 0x1E 0x96 0x51;

    memory "flash"
        size      = 0xC000;
        offset    = 0x4000;
        page_size = 0x80;
        readsize  = 0x100;
    ;

    memory "eeprom"
        size      = 0x100;
        offset    = 0x1400;
        page_size = 0x40;
        readsize  = 0x100;
    ;
;

programmer
  id    = "jtag2updi";
  desc  = "JTAGv2 to UPDI bridge";
  type  = "jtagmkii_pdi";
  connection_type = serial;
  baudrate = 115200;
;

```

And the last variable that we need is the Arduino serial port: `PORT?=/dev/ttyACM0`.
You can find that information in the Arduino IDE (in the *tools* menu).

### Rules

Now that we have defined all the variables that we need, we have to create some rules to compile and upload our code to the Arduino.
To that end, we are going to have three rules: `all`, to compile the code, `upload`, to upload the binary to the board, and `clean` to remove all the build files.

Let's start with the `all` rule:

```makefile
all:
    ${BIN_DIR}/avr-g++ -c -g -Os -w -std=c++17 -fpermissive -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -Wno-error=narrowing -MMD -flto -mmcu=atmega4809 -DF_CPU=16000000L -DARDUINO=10809 -DARDUINO_AVR_NANO_EVERY main.cpp -o main.o
    ${BIN_DIR}/avr-g++ -w -Os -g -flto -fuse-linker-plugin -Wl,--gc-sections -Wl,--section-start=.text=0x0 -mmcu=atmega4809 -o main.elf main.o
    ${BIN_DIR}/avr-objcopy -O binary -R .eeprom main.elf main.bin
    ${BIN_DIR}/avr-objcopy -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 main.elf main.eep
    ${BIN_DIR}/avr-objcopy -O ihex -R .eeprom main.elf main.hex
    ${BIN_DIR}/avr-size -C main.elf
```

This mostly comes from the Arduino IDE's console output window.
I've made only very small modifications.
The `upload` rule is also taken from the Arduino IDE:

```makefile
upload:
    python3 ./reset.py ${PORT}
    ${AVRDUDE} -C${CONFDIR} -v -patmega4809 -cjtag2updi -P${PORT} -b115200 -e -D -Uflash:w:main.hex:i -Ufuse2:w:0x01:m -Ufuse5:w:0xC9:m -Ufuse8:w:0x00:m
```

There is one subtle thing here.
If we check the Arduino IDE's console output, we can read the following message: `Forcing reset using 1200 bps open/close on port /dev/ttyACM0`.
This means that we need to reset the Arduino before avrdude starts uploading the program.
I found that the more reliable way to do that is to use a little python3 script:

```python
#!/usr/bin/python

import sys
import serial

com = serial.Serial(sys.argv[1], 1200)
com.dtr=False
com.close()
```

Finally, we need a `clean` rule that removes all the compiled files.
This is a pretty easy rule to write, so I'll just throw the whole makefile there:

```makefile
BIN_DIR?=${AVR_TOOLS_DIR}/avr-gcc/7.3.0-atmel3.6.1-arduino5/bin
AVRDUDE_DIR?=${AVR_TOOLS_DIR}/avrdude/6.3.0-arduino17/
AVRDUDE?=${AVRDUDE_DIR}/bin/avrdude
CONFDIR?=${AVRDUDE_DIR}/etc/avrdude.conf

PORT?=/dev/ttyACM0

all:
    ${BIN_DIR}/avr-g++ -c -g -Os -w -std=c++17 -fpermissive -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -Wno-error=narrowing -MMD -flto -mmcu=atmega4809 -DF_CPU=16000000L -DARDUINO=10809 -DARDUINO_AVR_NANO_EVERY main.cpp -o main.o
    ${BIN_DIR}/avr-g++ -w -Os -g -flto -fuse-linker-plugin -Wl,--gc-sections -Wl,--section-start=.text=0x0 -mmcu=atmega4809 -o main.elf main.o
    ${BIN_DIR}/avr-objcopy -O binary -R .eeprom main.elf main.bin
    ${BIN_DIR}/avr-objcopy -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 main.elf main.eep
    ${BIN_DIR}/avr-objcopy -O ihex -R .eeprom main.elf main.hex
    ${BIN_DIR}/avr-size -C main.elf


upload:
    python3 ./reset.py ${PORT}
    ${AVRDUDE} -C${CONFDIR} -v -patmega4809 -cjtag2updi -P${PORT} -b115200 -e -D -Uflash:w:main.hex:i -Ufuse2:w:0x01:m -Ufuse5:w:0xC9:m -Ufuse8:w:0x00:m


clean:
    rm -f main.bin main.d main.eep main.elf main.hex main.o
```

There we are, all that's left is to put this in a `Makefile`file.
Now we can type `make` to compile the code and `make upload` to upload it to the board.

## Example: Blink the On-board LED

We are going to go through a very simple example: the LED blink example.

### Arduino Version

Here's the Arduino code for the LED blink example:

```cpp
const int ledPin = 13;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  digitalWrite(ledPin, HIGH);   // set the LED on
  delay(1000);                  // wait for a second
  digitalWrite(ledPin, LOW);    // set the LED off
  delay(1000);                  // wait for a second
}
```

Using the Arduino IDE to compile this code, we get the following message:

```text
Sketch uses 1118 bytes (2%) of program storage space. Maximum is 49152 bytes.
Global variables use 22 bytes (0%) of dynamic memory, leaving 6122 bytes for local variables. Maximum is 6144 bytes.
```

So, in order to make a LED blink every second, we need 1118 bytes of program space, and 22 bytes of RAM.
To me, that sounds like a lot!

### C Version

Now let's go low-level and see what we can do without using the Arduino library.
Since we're using a C++ compiler, it's not really C code, but it looks like it is:

```cpp
#include <avr/io.h>
#include <util/delay.h>

int main()
{
    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler

    PORTE.DIRSET |= PIN2_bm;

    for(;;)
    {
        _delay_ms(1000);
        PORTE.OUTTGL |= PIN2_bm;
    }

    return 0;
}
```

The first line of the main function is used to disable the prescaler, which ensures that the CPU runs at the wanted 16MHz frequency.
If you check out the Arduino Nano Every connector pinouts, you'll see that the on-board LED is connected to `D13`.
This pin is also labeled `SCK` and `PE2`.
The latter tells us that this particular pin is wired to port E, pin 2.
And that's all we need for our LED blink example.
First we use the `DIRSET` register of port E to set the pin 2 bit, which will set pin 2 as an output.
Then, in the main for loop, we write the pin 2 bit into the `OUTTGL` register, which toggles the state of pin 2.
In between each toggling, we use the `_delay_ms` function, which allows us to wait for a given time.

The ports registers and pins definitions are provided by the `avr/io.h` header which contains everything we need.
Because we passed the `-mmcu=atmega4809` flag to avr-gcc in our makefile, it knows that we are using an ATMega4809.
The `_delay_ms` function comes from `util/delay.h`, it needs to know the CPU clock frequency, which why we passed to avr-gcc using `-DF_CPU=16000000L`.

This program does the same thing as the previous one, except it uses a lot less memory and needs no RAM:

```text
AVR Memory Usage
----------------
Device: Unknown

Program:     238 bytes
(.text + .data + .bootloader)

Data:          0 bytes
(.data + .bss + .noinit)
```

### C++ Version

Okay, so I'm not a big fan of C, and I wonder if we could make this code more readable.
I would like to be able to write something like `led.Toggle()` instead of `PORTE.OUTTGL |= PIN2_bm`.

In order to be as generic as possible, we are going to define a class that allows pin manipulation.
One more thing: I really don't like pointers, so we are going to try to avoid them at all cost.

First of all, we need to know how `PORTE` is defined.
Its definition lies in the `avr/include/avr/iom4809.h` file: `#define PORTE                (*(PORT_t *) 0x0480) /* I/O Ports */`, where `PORT_t` is a big struct with a bunch of `register_t` in it.
Fort instance, `OUTTGL` and `DIRSET` are in that struct.
And here's where it gets kind of ugly: `typedef volatile uint8_t register8_t;`.
Every `register8_t` is declared as volatile, which makes sense because our LED blink wouldn't work otherwise (the compiler would optimize away the `PORTE.OUTTGL |= PIN2_bm` line).

So, the first thing that we need, is the address of `PORTE`.
Because of that `volatile` keyword, we can't use `constexpr` nor `static_cast`, so we are going to define it as: `static const auto PORTE_ADDR = reinterpret_cast<uint16_t>(&PORTE);`.
Note that this is a 16-bit address

Now we define a pin as a port and a pin number.
In our case: port E (its address) and pin 2 (its bit mask).
These two things are known at compile time, so we can use them as template parameters.
Hence, we are going to define a `Pin` class that take these two parameters as template parameters:

```cpp
namespace DigitalIO
{

    static const auto PORTE_ADDR = reinterpret_cast<uint16_t>(&PORTE);

    template <uint16_t portAddr, uint8_t mask>
    class Pin
    {
    public:
        Pin() = delete;
        ~Pin() = delete;

        static constexpr void ConfigureAsInput()
        {
            port().DIRSET &= ~mask;
        }

        static constexpr void ConfigureAsOutput()
        {
            port().DIRSET |= mask;
        }

        static constexpr void Toggle()
        {
            port().OUTTGL |= mask;
        }

        static constexpr void SetHigh()
        {
            port().OUTSET |= mask;
        }

        static constexpr void SetLow()
        {
            port().OUTCLR |= mask;
        }

        static constexpr auto& port()
        {
            return *reinterpret_cast<PORT_t*>(portAddr);
        }
        
    private:

    };
    
} // namespace IO
```

We need to cast the port address back to a `PORT_t` struct, which is the role of the `port()` function.
The rest of the code is pretty straightforward, we encapsulate our C code into `static` methods.

Here's how to use this code:

```cpp
#include "DigitalIO.h"

#include <avr/io.h>
#include <util/delay.h>

#include <stdint.h>

using Led = DigitalIO::Pin<DigitalIO::PORTE_ADDR, PIN2_bm>;

int main()
{
    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler

    Led::ConfigureAsOutput();

    for(;;)
    {
        _delay_ms(1000);
        Led::Toggle();
    }

    return 0;
}
```

It looks almost the same as the previous code, except that it's a bit more readable.

But we did add quite a bit of boilerplate code in our `DigitalIO.h` file, is that a good idea?
I believe it is. Right now, we don't see how this can be very useful because our program is small and basic.
With a bigger code base, I think it would be way easier to understand our code with a well-structured C++ program.

But wait a minute, isn't all that code going to add more bytes to our program?
Let's check that, shall we?

```text
AVR Memory Usage
----------------
Device: Unknown

Program:     238 bytes
(.text + .data + .bootloader)

Data:          0 bytes
(.data + .bss + .noinit)
```

It doesn't. In fact the assembly code is exactly the same as the previous one.
Why is that? Because gcc is awesome, of course!
So, we can write C++ code and get the same assembly code as a C program, that's what we call *zero cost abstraction*.

## What's Next?

Okay, so we've seen how to program an Arduino Nano Every without using the Arduino library.
Through a very simple example, we've also seen that C and C++ code lead to the same assembly code.

In the next part, we will focus on MIDI and see how we can turn our Arduino Nano Every into a MIDI device.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[New Arduino Nano Every Trigger Board - Part 3]]></title>
            <link>https://news.exadrums.com/article/new-arduino-nano-every-board-part3</link>
            <guid>https://news.exadrums.com/article/new-arduino-nano-every-board-part3</guid>
            <pubDate>Sun, 15 May 2022 12:49:07 GMT</pubDate>
            <description><![CDATA[This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 2.
In this part, we are going to send MIDI notes over USB using the Arduino Nano Every.
To understand everything correctly, make sure you read the previous parts.
♬ ♪ ♬ ♪]]></description>
            <content:encoded><![CDATA[
This is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 2](/article/new-arduino-nano-every-board-part2).

In this part, we are going to send MIDI notes over USB using the Arduino Nano Every.
To understand everything correctly, make sure you read the previous parts.

♬ ♪ ♬ ♪

<!--more-->

## MIDI Protocol for a Basic Drum Module

First, we are going to talk about MIDI and what it actually is at the "hardware" level.
I'll be honest, I probably know only the basis of MIDI.
However, I believe I know enough to make a drum module that sends MIDI notes and messages.

For a basic drum module, we'll need two MIDI ingredients: notes and control change.
MIDI is old, so most messages are represented by bytes, that is values that can go from 0 to 255, or -128 to 127 if you represent byte as signed integers using two's complement.
But there's a catch, MIDI doesn't always use 8-bit data, rather, some parameters use 7-bit data, so their values go from 0 to 127.
That means, there are 128 MIDI notes.

So what is a MIDI (drum) note exactly?
Well, drums are a bit different than other instruments in a sense that there aren't actual notes per say.
There is one thing called *Universal General MIDI Drum Notes* that saves us, though.
It defines more than 40 "notes" (from note 35 to 81) that [represent drum instruments](https://www.zendrum.com/resource-site/drumnotes.htm).
Here are some examples: 35 is *Acoustic Bass Drum*, 38 is *Acoustic Snare*, 70 is *Maracas*, and 81 is *Open Triangle*.

### MIDI Commands

In practice, MIDI notes are sent using commands. There are two note commands: *Note On* and *Note Off*.
As the names suggest, the former tells the instrument to play a note, and the latter says that we need to stop playing that note.
A command, such as *Note On*, is represented by a byte.
This byte is divided into two distinct parts: the command itself, and the MIDI channel.
There are 16 MIDI channels, so in theory you can send 16 *Note On* commands over the 16 available channels.

The way it works is that the command byte is cut in half. The most significant bits represent the command, and the least significant bits represent the channel number.
Here's an example. We would like to send a *Note On* command over channel 0.
The command number for *Note On* is 144, so we simply send a byte that holds the value 144, easy.
But, in MIDI, drums use channel 10, so how do we send a note over channel 10?

To answer that question, we are going to use hexadecimal values instead of decimal.
The *Note On* command for channel 0 is 144, which becomes `0x90` in hexadecimal.
Channel number 10, becomes channel number `0x09` (because they are numbered from 0!), so a *Note On* command over channel 10 is `0x99`.
By the way `0x99` is 153 in decimal, so that's just `144 + 9`, which is the *Note On* command *plus* the channel number (with the first channel being numbered as 0).

### Drum Notes

Now, we know how to send a *Note On* command. It is quite simple, as only one byte needs to be sent.
This byte value is `0x99` in hexadecimal if we use channel 10.

If a MIDI instrument were to received that command, it would need to know which note to play.
This is why the *Note On* command must be followed by the note number.
Lets say we want a snare drum sound, we need to send `0x99` followed by 38, or `0x26`.

And that's it. If an instrument receives those two bytes one after another it will know that it should play a snare drum note.
But it won't, because there's still one thing that's missing here: the velocity.

### Note Velocity

It would be no fun at all if all the notes had the same velocity.
That's why a third byte follows the MIDI command and MIDI note number, and that third byte represents the velocity.
The velocity goes from 0 to 127 (yes it uses only 7 bits).

Finally, to send a snare drum note with a velocity of 92, we have to send 3 bytes: `154, 38, 92` or, in hexadecimal: `0x99, 0x26, 0x5C`.

### Baud Rate & Latency

You probably think that sending only 3 bytes must be very fast, but is it really that fast?
MIDI communications usually happen at 38400 bauds per second.
The actual speed in bytes per seconds is 38400 divided by 8, which gives 4800 Bps.
Say we send 3 bytes per note, that gives us 1600 notes per second, or 0.625 milliseconds (ms) to send a note.
That may not seem like a lot, and it isn't really a lot, but that's getting close to 1 ms.

Do we really have to stick with 38400 bps?
I believe we don't, but it depends on the VST (Virtual Studio Technology) you use.
Now, if we use a baud rate of 115200 bps, we get 14400 Bps, so 4800 notes per second.
That means we're sending one note in nearly 0.2 ms. That's a bit better.

### Control Change

Okay, it's quite easy to understand what a note is, but perhaps we need a little bit more than that.
With MIDI notes, we can have a drum kit that's made of pads.
Every time we hit a pad, we send a note whose velocity is proportional to the pad's volume.
We can have drums and cymbals, but how do we deal with the hi-hat controller?

We could vary the note number according to the pedal's openness.
After all, there are two notes dedicated to the hi-hat: 42 is *Closed Hi-Hat* and 46 *Open Hi-Hat*, and some VSTs also define a *Semi-Open Hi-Hat* note.
That's a totally fine thing to do, but there's a better solution: control change.

Control change may seem more complicated than note commands, but it really is based on the same principle: send 3 bytes.
The first byte is the command byte, and it is 176 or `0xB0` in hexadecimal.
As for the notes, it has to be combined with the channel number.
So for channel 10, we get 186 or `0xBA`.

The second byte represents the control function. It can be a modulation wheel, a foot controller, an expression controller, etc.
There are 128 possible control functions, but some of them are undefined.
For the hi-hat controller, the one we are interested in is the *foot controller*, so control function number 4.
The second byte is 4, `0x04`.

Now the third byte is the value the control function should take.
Just like the velocity, this value goes from 0 to 127.

If the hi-hat pedal is half-open, we send the following three bytes: `186, 4, 63`, or `0xBA, 0x04, 0x3F`.
At least that what we send when a control change message needs to be sent. But when do we send a control change exactly?

Two options come to mind: when the sensor register a change that's big enough to be perceptible, or at regular time interval.
We'll go for the former, as there's no reason to send a control change if there's no change in the sensor value.

## Serial MIDI Over USB

So far we've talked about MIDI as bytes we send to a device, but we need to address how we send those bytes.

### The Hard Truth About the ATMega4809

The ATMega4809 has 4 USART (universal synchronous and asynchronous receiver-transmitter) preipherals.
One of them is accessible via the Arduino Nano Every board pins `RX` and `TX`, and the other one is hardwired to another microcontroller that's on the board: the SAMD11D14A.

Why is there another microcontroller on the board? Here's what the official documentation has to say:

```text
The SAMD11D14A processor is shipped with a firmware that implements USB to serial bridge and handles
ATMega4809 firmware upgrade through the UPDI interface.
```

The ATMega4809 doesn't support the USB protocol, so another microcontroller handles that instead.
It acts as a USB to serial bridge, and is connected to one of the ATMega4809's USART peripherals.
So when you use `Serial.println` in your Arduino IDE, the data goes from your Arduino USART numnber 3 to the SAMD11D14A which sends it over USB to you PC.

As a consequence, the Arduino Nano Every can't be recognized as a USB device, so no USB MIDI!

### How to Send MIDI Notes to a Computer

All hope is not lost, we can send MIDI data over USB, the catch is that we can't use the USB protocol.
Instead we can transfer serial data directly, which has one advantage: the code is simpler to write!
There are two options: we can use a serial to USB adapter and connect our Arduino (using two resistors) to it.
Or we can use the on-board USB and convert the serial data adequately on the target PC.

We are going to go for option number two, as we'd prefer not to rely on additional hardware.
The way it works is pretty straightforward, we are just going to send our bytes over the USART3.

## ATMega4809 USART & MIDI

Here we are, ready to write some code.
In order to send the notes over USB, we need to use USART3.
The ATMega4809's documentation tells us a few things:

- We need to set the USART pins as output (TX) and input (RX).
- Then, we have to configure the USART (especially its baud rate).
- Only after the USART's been configured, we can use its registers to send and receive data.

We are going to need to configure PORTB (please refer to [part 2 of this series](/article/new-arduino-nano-every-board-part2) for more info).
To that end, we use the following code:

```cpp

#include <avr/io.h>

#include <stdint.h>

namespace DigitalIO
{
    
    static const auto PORTA_ADDR = reinterpret_cast<uint16_t>(&PORTA); 
    static const auto PORTB_ADDR = reinterpret_cast<uint16_t>(&PORTB); 
    static const auto PORTC_ADDR = reinterpret_cast<uint16_t>(&PORTC); 
    static const auto PORTD_ADDR = reinterpret_cast<uint16_t>(&PORTD); 
    static const auto PORTE_ADDR = reinterpret_cast<uint16_t>(&PORTE);
    static const auto PORTF_ADDR = reinterpret_cast<uint16_t>(&PORTF);


    template <uint16_t portAddr, uint8_t mask>
    class Pin
    {
    public:
        Pin() = delete;
        ~Pin() = delete;

        static constexpr void ConfigureAsInput()
        {
            port().DIRSET &= ~mask;
        }

        static constexpr void ConfigureAsOutput()
        {
            port().DIRSET |= mask;
        }

        static constexpr void Toggle()
        {
            port().OUTTGL |= mask;
        }

        static constexpr void SetHigh()
        {
            port().OUTSET |= mask;
        }

        static constexpr void SetLow()
        {
            port().OUTCLR |= mask;
        }

        static constexpr auto& port()
        {
            return *reinterpret_cast<PORT_t*>(portAddr);
        }
        
    private:

    };
    
} // namespace IO
```

Now we need to configure the USART. I'll give the code for USART3 only, feel free to improve it to handle other USARTs if you wish.

```cpp
#include "Pin.hpp"
#include "Port.hpp"

#include <avr/io.h>

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

namespace DigitalIO
{

    template <uint8_t N>
    class Usart
    {
    public:

    constexpr explicit Usart(uint32_t br)
    {
        switch(N)
        {
            // TODO: configure Usart 0 to 2
            case 3: 
            {    
                PORTMUX.USARTROUTEA |= PORTMUX_USART30_bm;
                using Usart3InputPin = Pin<PORTB_ADDR, PIN5_bm>;
                using Usart3OutputPin = Pin<PORTB_ADDR, PIN4_bm>;

                Usart3InputPin::ConfigureAsInput();
                Usart3OutputPin::ConfigureAsOutput();
                
                break;
            }
            default: static_assert(N <= 3, "Invalid USART number."); break;
        }

        usart().BAUD = BaudRate(br);
        usart().CTRLB |= USART_RXEN_bm | USART_TXEN_bm; 
        usart().CTRLC |= USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc;
    }

    constexpr void SendByte(uint8_t c)
    {
        while(!(usart().STATUS & USART_DREIF_bm))
        {
            ;
        }        
        usart().TXDATAL = c;
    }

    static constexpr uint16_t BaudRate(uint32_t baudRate)
    {
        return static_cast<uint16_t>(static_cast<float>((F_CPU * 64 / (16 * static_cast<float>(baudRate))) + 0.5));
    }

    static constexpr USART_t& usart()
    {
        switch(N)
        {
            case 0: return USART0;
            case 1: return USART1;
            case 2: return USART2;
            case 3: return USART3;
            default: static_assert(N <= 3, "Invalid USART number.");
        }
    }

    private:

    };

} // namespace IO
```

You'll notice that there is a `SendByte` function.
That's all we need to send MIDI notes, as we need to send 3 bytes for each `Note On` command.

## Sending MIDI Over USART

All right, lets wring some code that sends MIDI notes.
We are going to use one more little helper:

```cpp
#include "DigitalIO/Usart.hpp"

template <typename Usart>   
class SerialMidi
{

public:

    SerialMidi() = delete;
    ~SerialMidi() = default;

    SerialMidi(Usart& usart) : usart_{usart}
    {

    }

    template <uint8_t channel>
    inline void NoteOn(uint8_t note, uint8_t velocity) const noexcept
    {
        usart_.SendByte(0x90 | (channel & 0x0f));
        usart_.SendByte(note);
        usart_.SendByte(velocity);
    }

    template <uint8_t channel, uint8_t control>
    inline void ControlChange(uint8_t value) const noexcept
    {
        static_assert(control <= 127, "Invalid control value.");
        usart_.SendByte(0xB0 | (channel & 0x0f));
        usart_.SendByte(control);
        usart_.SendByte(value);
    }


private:

    Usart& usart_;

};
```

Even if we are not going to use it, I included the `ControlChange` function.

```cpp
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

using Usart3 = DigitalIO::Usart<3>;

static Usart3 usart{115'200};
static SerialMidi midi{usart};

int main()
{
    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler

    sei();

    const uint8_t snareNote = 38;
    const uint8_t bdNote = 36;
    const uint8_t hhNote = 42;

    const uint8_t nbNotes = 8;
    const uint8_t snareNotes[nbNotes] =    {0, 0, 1, 0, 0, 0, 1, 0};
    const uint8_t hihatNotes[nbNotes] =    {1, 1, 1, 1, 1, 1, 1, 1};
    const uint8_t bassDrumNotes[nbNotes] = {1, 0, 0, 0, 1, 1, 0, 0};

    uint8_t i = 0;

    for(;;)
    {
        _delay_ms(400);

        if(snareNotes[i] == 1)
        {
            midi.NoteOn<9>(snareNote, 80);
        }

        if(hihatNotes[i] == 1)
        {
            midi.NoteOn<9>(hhNote, 80);
        }

        if(bassDrumNotes[i] == 1)
        {
            midi.NoteOn<9>(bdNote, 80);
        }

        i = ++i % nbNotes;
    }

    return 0;
}
```

We have defined three instruments: a snare drum, a hi-hat, and a bass drum, each having its MIDI note: 38, 42 and 36, respectively.
We also define an array of eight notes for each instrument.
In that array, a "1" means that the instrument's note is to be played, and a "0" means nothing happens.
We iterate the array in loop, and play a note every 400 ms.
I believe the code is self-explanatory.

## Playing Those Notes

As I have already mentioned, our Arduino isn't recognized as a MIDI device because it doesn't use the USB protocol.
Consequently, we need to *convert* the incoming serial data to MIDI data.
To that end, we can use [ttymidi](https://github.com/cjbarnes18/ttymidi).
It isn't too hard to use, and works well on Linux.
First of all, we need to clone the repository: `git clone https://github.com/cjbarnes18/ttymidi`.
Then, in the `ttymidi` directory, we need to compile it using `make`.
And finally, to start the program, we run the following command:

```text
./ttymidi -s /dev/ttyACM0 -b 115200 -v
```

Where `/dev/ttyACM0` is the Arduino's serial port.
Let ttymidi run with the Arduino plugged in and you'll see MIDI notes being received in real-time.

## What's Next?

We are going to take a break for now.
I don't when the next part will be posted, but I know it'll be about the Analog to Digital Converter (ADC).
We'll probably get back to MIDI-related topics another time.
See you next time!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[New Arduino Nano Every Trigger Board - Part 5]]></title>
            <link>https://news.exadrums.com/article/new-arduino-nano-every-board-part5</link>
            <guid>https://news.exadrums.com/article/new-arduino-nano-every-board-part5</guid>
            <pubDate>Wed, 15 Jun 2022 18:25:57 GMT</pubDate>
            <description><![CDATA[This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 4.
As mentioned in the previous parts, especially the first one, the eXaDrums TB08-SE board can be used together with an Arduino Nano Every and the eXaDrumino Nano Every code to make a MIDI drum module. Here's a picture of the board.

I've been able to test it with my Roland TD17 and it works very well.
In particular, it is very impressive to see how much a tiny Arduino Nano Every can do.
Thanks to MIDI, the sound quality is spectacular, and we get multilayer sounds, round-robin, etc. for free by using a VST that handles those things.
For my tests, I used hydrogen as a VST. It may not be the best, but it felt like playing with high quality material.]]></description>
            <content:encoded><![CDATA[
This is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 4](/article/new-arduino-nano-every-board-part4).

As mentioned in the previous parts, especially the first one, the eXaDrums TB08-SE board can be used together with an Arduino Nano Every and the eXaDrumino Nano Every code to make a MIDI drum module. Here's a picture of the board.

![image](/images/new-arduino-nano-every-board/board.png)

I've been able to test it with my Roland TD17 and it works very well.
In particular, it is very impressive to see how much a tiny Arduino Nano Every can do.
Thanks to MIDI, the sound quality is spectacular, and we get multilayer sounds, round-robin, etc. for free by using a VST that handles those things.
For my tests, I used [hydrogen](https://hydrogen-music.org/) as a VST. It may not be the best, but it felt like playing with high quality material.

<!--more-->

## Context and Description

This project is part of the eXaDrums project.
It features a new board that allows to connect 8 drum pads to an Arduino Nano Every that, in turns, sends MIDI notes over USB.
The board hardware and software are both compatible with eXaDrums, but it can also be used as a standalone device.

The project name is eXadrumino Nano Every. It is a high performance firmware that allows to read eight analog inputs very fast and send MIDI notes over USB, or via the on-board USART. Using eXaDrums or a PC loaded with a VST, it allows to play drums with a very low latency.
The board itself is called *eXaDrums TB08-SE*, and it is compatible with other microcontrollers than the Arduino Nano Every.

Here's a brief reminder of the specs I gave in the first part of this series of articles:

- Works on PC and Raspberry Pi.
- Up to 7 single-zone pads + 1 hi-hat controller.
- Compatible with Roland TD-9, TD-11, TD-15, TD-17, TD-25, and TD-27-based edrum kits (DB25 connector).
- Sample rate greater than 70ksps (kilo samples per second).
- Nearly 9000 samples per second and per channel (8928 in average).
- Configurable trigger parameters: threshold, scan time and mask time (1ms step).
- Configurable MIDI channel and notes.

The last two are still under development.

## How to Get the Board?

I designed a board and got 5 prototypes PCBs.
However, that board requires some refinements. I would like to make some changes before I share the whole PCB so that it is as good as it can be.
Meanwhile, you can easily replicate the schematics, as it is a quite simple circuit.
Every piezo is wired to a single operational amplifier that acts as a simple amplifier that adds a bias voltage to the signal.
Here's how it looks:

![Circuit](/images/new-arduino-nano-every-board/Piezo-circuit.png)

The `Vcc` voltage is taken from the Arduino's 5V `power out` (pin number 12).
At the `Vbias` pin, the voltage is 1.65V.
It is obtained by using a voltage divider made of two 10k resistors that are wired to the 3.3V `power out` pin of the Arduino (pin number 2).

The hi-hat controller input is a little different, and simpler.
It consists of a single 4.7k resistor wired to the 3.3V pin of the Arduino on one side, and the hi-hat controller as well as the `+` input of voltage follower. It is the same divider for all operational amplifiers.

And that's it, you know everything. There are 4 dual operational amplifiers on the board, which makes a total of 8 inputs.
I got my prototypes from JLCPCB, using their SMT sevice, which means that I received assembled boards, that is, all the components were already soldered, except for the Raspberry Pi GPIO header socket.
If you'd like to get you own board, I do recommend JLCPCB, the PCBs are good quality and affordable, the only downside is the shipping cost.
Or, if you're patient, you can wait until I'm done with improving the board's layout, it shouldn't take too long.
Again, I just want to make the best board possible, which will require a few changes.

## Where is the Code?

The code is freely available at [GitHub](https://github.com/SpintroniK/exadrumino-Nano-Every).
You'll find more details as well as instructions that will help you flash the code to your Arduino.
Note that the code is still a work in progress, some features are not their yet.
The most important missing features are those that allow to change trigger and MIDI parameters via the USART, and save those parameters to the on-board EEPROM.

## Previous and Next Parts

So far there has been 4 parts published in this series of articles. This is the fifth one.
Here's a reminder of the previous parts and what they talk about:

- [Part 1](/article/new-arduino-nano-every-board-part1): New board specs, and how it works.
- [Part 2](/article/new-arduino-nano-every-board-part2): Makefile and the way C++ has been used to write the firmware.
- [Part 3](/article/new-arduino-nano-every-board-part3): Sending serial MIDI notes over USB.
- [Part 4](/article/new-arduino-nano-every-board-part4): How to use the ADC to make an oscilloscope and read triggers voltages.

There will be at least two more parts which will deal with the following topics:

- Part 6: How to get an efficient real-time counter.
- Part 7: How to filter the piezo output signal very fast to make a drum trigger.
- Part 8: How to read and write values to the on-board EEPROM.
- Maybe more...

See you next time!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[New Arduino Nano Every Trigger Board - Part 6]]></title>
            <link>https://news.exadrums.com/article/new-arduino-nano-every-board-part6</link>
            <guid>https://news.exadrums.com/article/new-arduino-nano-every-board-part6</guid>
            <pubDate>Tue, 05 Jul 2022 16:11:31 GMT</pubDate>
            <description><![CDATA[This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 5.
In this part, we are going to talk about real-time counters.
In particular, we'll see advantages of using a relative time reference.
And we'll also see how the following figure helps us measure a time difference efficiently using a single byte as our time reference!
]]></description>
            <content:encoded><![CDATA[
This is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 5](/article/new-arduino-nano-every-board-part5).

In this part, we are going to talk about real-time counters.
In particular, we'll see advantages of using a relative time reference.

And we'll also see how the following figure helps us measure a time difference efficiently using a single byte as our time reference!

![delta](/images/new-arduino-nano-every-board/delta.png)

<!--more-->

## Absolute and Relative Time Reference

The first important thing that we need to know is that we can't have an absolute time reference.
Because our time reference needs to store the time in a variable, it will overflow at some point.
That means, an absolute time reference remains absolute as long as the counter variable doesn't overflow.

This is a major drawback, especially for limited hardware, where incrementing a 32-bit variable can be very expensive.
An 8-bit microcontroller such as the ATMega4809 isn't able to increment a 32-bit variable in a single instruction.
So, to avoid overflows, we need to either decrease the resolution of our counter, or store its value into a bigger variable.
But, this won't prevent the counter from overflowing at some point anyway... So what can we do about that?

Here's an example to illustrate our problem.
Say we want to increment a counter every microsecond.
We are playing drums an hour or two every day, and we'd like our time reference to be absolute.

Let's say we want to store our counter value in a 32-bit integer.
That leaves us with 4295 seconds before the counter overflows, which is slightly more than an hour.
We have three solutions:

- Use a 64-bit variable, which will cause an overflow after a few billion years.
- Increase the resolution of our timer to, say 1 ms, so that we get nearly 50 days before the variable overflows.
- Work with a relative time reference instead of an absolute one.

All three options work, but we are interested in the latter, as this will allow us to store our count in a 16-bit, possibly a 8-bit variable.

A relative time reference is a single variable that is incremented at regular interval.
The only difference with an absolute time reference is that we know it will overflow at some point, and that's not a problem.

## Relative Time Reference

### How it Works

Contrary to the absolute time reference, the relative time reference needs to be compared to another variable.
For instance, if a drum pad is hit, we get the value of our relative time reference (counter) and memorize it.
After some time, we are going to check how much time has elapsed since we've memorized the time reference value.

### Practical Example

First of all, we need to state the requirements for our time reference.
We'd like to make a drum module, so the time reference will be used to manage the triggers states.
That includes the trig time, scan time, and mask time.
For those values, it would be nice to have a resolution of 0.1 or 0.5 ms, something like that.
However, I will choose a step of 1 ms.
The main reason for that, is that 0.1 ms is too small and 0.5 ms could lead to confusion...

Let's say we use a 8-bit variable for our counter.
It is incremented every millisecond, so it can count from zero to 255 ms.
And it does so continuously until it overflows and goes back to zero.

Now if a drum pad is hit, the trigger registers the current value of the counter.
Imagine that the value of the counter is 42. It is stored in a `trigTime` variable.
We set the scan time to 4 ms, which means the scan time will be done when the counter reaches 46.
The only thing we need to know is: is the counter greater or equal to 46.

A problem arises if the counter overflows, though.
Let's say the pad has been hit when the counter's value was 254.
We'll know that the scan time is over when the counter's value will be greater or equal to 258.
But our 8-bit variable will overflow before that, so we'll get the following sequence: 254, 255, 0, 1, 2, instead of 254, 255, 256, 257, 258.

Fortunately, we can do something about that.
Instead of using unsigned integers, we can use signed integers, but we're going to go over a few other details before we do so.
We still use a 8-bit unsigned integer to store our counter's value, so it can go from 0 to 255.
We do the same for our scan time variable.
In order to determine if we have waited for a longer time than the scan time here's what we need to compute: `const uint8_t delta = trigTime + scanTime - currentTime;`.

So far, we still use an unsigned integer, but, let's examine precisely what happens with the previous values.
We have `trigTime = 254` and `scanTime = 4`.
Here's what happens if we subtract the `currentTime` variable to the previous value:

1. If `currentTime = 255` we get `delta =  254 + 4 - 255 = 3`.
2. If `currentTime` overflows, for instance, `currentTime = 1`, we get `delta =  254 + 4 - 1 = 1`.
3. If `currentTime` overflows, and we've waited longer than the scan time, for instance, `currentTime = 4`, we get `delta = 254 + 4 - 4 = 254`.

### A Little Bit of Theory

Now let's see what happens for a different value of `trigTime`: `trigTime = 120`, and consider a longer scanTime: `scanTime = 100`.

1. If `currentTime = 128` we get `delta =  120 + 100 - 128 = 92`.
2. If `currentTime` doesn't overflow, for instance, `currentTime = 200`, we get `delta =  120 + 100 - 200 = 20`.
3. If `currentTime` doesn't overflow, and we've waited longer than the scan time, for instance, `currentTime = 240`, we get `delta = 120 + 100 - 240 = 236`.

We see something interesting here, for cases 1 and 2, delta remains below 127, but in both cases, point number 3 gives us a value that is above 128.
This is understandable, because if `currentTime >= trigTime + scanTime`, `deltat = rigTime + scanTime - currentTime` goes below zero.
But with unsigned integers, that means `delta` is now 255 minus something, so we get 254 or 236 in the second third case.
Notice how the result is the same whether the value overflows or not!

What that means is that perhaps we should treat `delta` as a signed integer.
It's important to note that, even if we treat `delta` as a signed integer, the underlying binary value of `delta` remains the same.

A signed 8-bit integer goes from -128 to 127. The most significant bit, or MSB, determines the sign.
If that bit is set to 1, the value is negative, otherwise, it is positive.
So, if we count from zero, the value goes like this: 0, 1, 2, 3, ..., 126, 127, -128, -127, -126, ..., -3, -2, -1.
Which is to be compared to a unsigned integer that goes like: 0, 1, 2, 3, ..., 126, 127, 128, 129, 130, ..., 253, 254, 255.
Both sequences are different representations of the same binary value.

This means that `delta` is negative if the elapsed time since the trig time is longer than the scan time.
Back to our first example, but this time using the signed representation of delta:

1. If `currentTime = 255` we get `delta =  254 + 4 - 255 = 3`.
2. If `currentTime` overflows, for instance, `currentTime = 2`, we get `delta =  254 + 4 - 2 = 0`.
3. If `currentTime` overflows, and we've waited longer than the scan time, for instance, `currentTime = 4`, we get `delta = 254 + 4 - 4 = -2`.

We have the following three cases:

- If we have waited less than the scan time duration, the value is positive.
- If we have waited exactly the duration of the scan time, the value is zero.
- If we have waited more than the scan time duration, the value is negative.

Let's visualize what's happening here.

![delta](/images/new-arduino-nano-every-board/delta.png)

The value of `delta` reaches 0 when the elapsed time since the trig time is exactly the scan time.
For an unsigned integer, the next value is 255, and if we cast `delta` to a signed integer, it is -1.
There are a few options to detect the transition:

- We could simply test if the unsigned representation of `delta` is greater or equal to 128.
- We could test the MSB of the unsigned representation of `delta`.
- Or we could cast `delta` to a signed integer an check if the value is negative.

I like the latter the most because it gives us a useful information for free: the elapsed time since the end of the scan time.
That time is equal to `-delta`.
However, there's one thing that I didn't mention: we loose half of the values of our 8-bit integer.
All three options above lead to the same result, we can now only measure time differences that go from 0 to 128ms.

If you'd like a to read a slightly different explanation of this idea, please read the [following article from Lucky Resistor](https://luckyresistor.me/2019/07/10/real-time-counter-and-integer-overflow/).

## Using TCB0 as a Real Time Counter

We are already using the TCA counter to trigger the ADC conversions, so we are going to use the TCB0 timer/counter instead.

### Configure TCB0 and Handle Interrupts

The TCB timer/counter can do a lot of things, but we're only going to use it as a counter here.
First of all, we define a class to handle the counters interrupts:

```cpp
class TCBInterrupts
{

public:
    TCBInterrupts() = delete;
    ~TCBInterrupts() = delete;

private:

    static void TCB0Overflow() __asm__("__vector_12") __attribute__((__signal__, __used__, __externally_visible__));
    static void TCB1Overflow() __asm__("__vector_13") __attribute__((__signal__, __used__, __externally_visible__));

};
```

And yes, "counters" with an "s", as there are 4 TCB timers.
Note that I implemented the interrupts for TCB0 and TCB1 only.

Now let's add a little helper to choose the right clock for TCB0:

```cpp
enum class TCBClock
{
    Div1,
    Div2,
    TCA
};
```

We'll use the same clock as TCA.
And now a class to configure the TCB counters:

```cpp
template <uint8_t nb>
class TCB
{

public:
    TCB() = delete;
    ~TCB() = delete;

    static constexpr void EnableInterrupts()
    {
        tcb().INTCTRL =  TCB_CAPT_bm;
    }

    static constexpr void ResetInterrupt()
    {
        tcb().INTFLAGS |= TCB_CAPT_bm;
    }

    static constexpr void SetCompareOrCapture(uint16_t value)
    {
        tcb().CCMP = value;
    }

    static constexpr void Enable()
    {
        tcb().CTRLA |= TCB_ENABLE_bm;
    }

    template <TCBClock clock>
    static constexpr void SetClock()
    {
        switch(clock)
        {
            case TCBClock::Div1: tcb().CTRLA |= TCB_CLKSEL_CLKDIV1_gc; break;
            case TCBClock::Div2: tcb().CTRLA |= TCB_CLKSEL_CLKDIV2_gc; break;
            case TCBClock::TCA: tcb().CTRLA |= TCB_CLKSEL_CLKTCA_gc; break;
        }
    }

private:

    static constexpr auto& tcb()
    {
        switch(nb)
        {
            case 0: return TCB0;
            case 1: return TCB1;
            case 2: return TCB2;
            case 3: return TCB3;
            default: static_assert(nb <= 3, "Wrong TCB number.");
        }
    }

};

```

The functions names are self-explanatory.

### A Real-Time Counter

Before we continue, we need one more ingredient: a counter.
To that end, I'll make a class template that will allow to choose the type of variable that the counter uses.

```cpp
template <typename T>
class Counter
{     

public:

    Counter() = default;
    ~Counter() = default;

    constexpr T GetCount()
    {
        return count;
    }

    constexpr void Increment()
    {
        ++count;
    }

private:

    T count{};
};
```

And that's it, now we can add all these niceties to our main function.

```cpp

#include "Adc.hpp"
#include "Counter.hpp"
#include "TCB.hpp"

#include <avr/io.h>
#include <avr/interrupt.h>

using Adc0 = Adc<Adc0Addr, Adc8bitType>;
using Tcb = TCB<0>;

Counter<uint8_t> clock{};

void Analog::AdcInterrupts::ResReady()
{
    Adc0::ResetInterrupt();
    trigger.Process(ADC0.RES, clock.GetCount());
}

void Timing::TCBInterrupts::TCB0Overflow()
{
    Tcb::ResetInterrupt();
    clock.Increment();
}

int main()
{

    while(1)
    {
        ;
    }

    return 0;
}

```

We use the relative time reference in the ADC interrupt, so that we know how much time has elapsed since we've received the previous samples.
In this interrupt there's a `trigger.Process()` function.
It is the function that will process the ADC data, together with the time reference, to compute the trigger state.
Here's an example that shows how this function can use the relative time reference:

```cpp
void Trigger::Process(uint8_t data, uint8_t time) const
{
    // [...]

    const uint8_t delta = this->trigTime + this->scanTime - time;

    if(static_cast<int8_t>(delta) <= 0)
    {
        // ...
    }

    // [...]
}
```

At some point in time, the ADC value exceeds a certain threshold, which in turn, puts the trigger in scan state.
The trigger remains in that state for `scanTime` milliseconds.
During that time, the peak value of the signal is computed.

The question we answer here is: how do we know when the scan time is over?
And the answer is simple: we check whether the signed representation of `delta` is positive or negative.
As soon as it becomes a negative value, we know that the scan time is over and we're done computing the signal's peak value.
Thus, we can go on and put the trigger in its next state, etc.

There we are, with a single byte we get a relative time reference that we can use to measure delays from 1 to 128 ms.
We don't need it to be an absolute time reference as long as we use a variable to memorize the start of the delay (`trigTime`).
Using this method, we can measure as many delays as we want as long they remain under 128 ms, and that we use a byte for each delay to memorize the when it starts.
Of course this also works if we use a 16-bit variable (or even bigger), it is just faster to use a 8-bit variable on a 8-bit CPU.

## What's Next?

Next time we'll talk about signal processing.
In particular, we will see how to make a high-pass filter that performs well with a 8-bit microcontroller.

See you next time!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[New SPI Sensors Configurator ⇒ More Trigger Inputs]]></title>
            <link>https://news.exadrums.com/article/new-spi-sensors-config</link>
            <guid>https://news.exadrums.com/article/new-spi-sensors-config</guid>
            <pubDate>Sat, 11 Dec 2021 13:31:28 GMT</pubDate>
            <description><![CDATA[Exadrums 0.7.0 is currently under development. The biggest feature of this release is the addition of configurable SPI (Serial Peripheral Interface) devices.
This features aims to provide a way to add as many SPI devices as you want.
Currently supported devices are of the MCP3XXX family, including MCP3008, MCP3204, and MCP3208, but there's a good chance more chips will be added before and after the release of this new version.
This means that it'll become possible to add more inputs to the trigger input board, by adding more analog to digital converters.
]]></description>
            <content:encoded><![CDATA[
Exadrums 0.7.0 is currently under development. The biggest feature of this release is the addition of configurable SPI (Serial Peripheral Interface) devices.
This features aims to provide a way to add as many SPI devices as you want.
Currently supported devices are of the MCP3XXX family, including MCP3008, MCP3204, and MCP3208, but there's a good chance more chips will be added before and after the release of this new version.

This means that it'll become possible to add more inputs to the trigger input board, by adding more analog to digital converters.

![image](/images/new-spi-sensors-config/spidev-config.png)

<!--more-->

## How SPI Devices Work

An SPI analog to digital converter takes in analog data, digitizes it, and sends it to a Raspberry Pi using the SPI bus.
SPI communication offers many advantages, and one of them is that it's quite easy to communicate with several devices.
The first eXaDrums input board uses a single MCP3008 chip, which limits the number of inputs to 8.
Adding another MCP3008 would increase that number to 16, and if you want even more inputs, you could add a third one.

The Raspberry Pi offers at least one SPI interface that has two `Chip Select` inputs (also called *Chip Enable*).
So, with a single SPI bus, `SPI0`, the Raspberry Pi can communicate with two devices, by changing the states of the chip selects pins `CE0` and `CE1`.

But that's not it. Recent Raspberry Pis have another SPI *bus*: `SPI1`. And it can handle up to three devices via its three chip select inputs `CE0`, `CE1`, and `CE2`.
So, in theory it's possible to have up to 5 SPI Analog to Digital converters. Imagine 5 MCP3008, that would mean up to 40 inputs!
Note that the Raspberry Pi 4 has even more SPI buses, so that should be more than enough, even for a big drum kit with a lot of triggers.

It's important to note that SPI devices are grouped by bus and chip select, and this is exactly how the SPI configuration works in exadrums.

## How to Configure SPI Devices

Only supported devices are allowed in the SPI configuration dialog. They are currently limited to MCP3008, MCP3204, and MCP3208.
Each device must be associated to a bus and a chip select.
And that's basically it.

Here is an example.
You make a trigger input board that needs to handle up to 16 analog inputs.
The MCP3008 is a good choice, so you decide to use two of them.
You can either have one of them use the `SPI0`, and the other the `SPI1`, or you can have them both use `SPI1` and choose to use two different chip selects, i.e. `CE0` and `CE1`.
So your configuration is:
|  Name   | Bus | CS |
|---------|-----|----|
| MCP3008 |  0  |  0 |
| MCP3008 |  0  |  1 |

And this is exactly how you can configure your SPI devices in exadrums (see screenshot above).
By doing that, you'll be able to create up to 16 triggers, numbered 0 to 15, and everything will work out of the box.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Raspberry Pi OS - Bullseye]]></title>
            <link>https://news.exadrums.com/article/raspberry-pi-os-bullseye</link>
            <guid>https://news.exadrums.com/article/raspberry-pi-os-bullseye</guid>
            <pubDate>Fri, 12 Nov 2021 18:07:46 GMT</pubDate>
            <description><![CDATA[Remember this article about exadrums becoming an official Debian package?
It's now time to play (exa)drums on your Raspberry Pi.
The Raspberry Pi Foundation released the latest Raspberry Pi OS bullseye a few days ago, and as you may have guessed, it includes exadrums packages:

Now, you simply have to type sudo apt install exadrums into a terminal to install exadrums on your Raspberry Pi.]]></description>
            <content:encoded><![CDATA[
Remember this article about [exadrums becoming an official Debian package](article/debian-bullseye)?
It's now time to play (exa)drums on your Raspberry Pi.
The Raspberry Pi Foundation released the latest Raspberry Pi OS *bullseye* a few days ago, and as you may have guessed, it includes exadrums packages:

![image](/images/raspberry-pi-os-bullseye/screenshot.png)

Now, you simply have to type `sudo apt install exadrums` into a terminal to install exadrums on your Raspberry Pi.

<!--more-->

It took some time to get to that point, but you get exadrums 0.6.0, which fairly recent, and works on my Roland TD-4KP drum set.
If you'd like to try exadrums with your TD-4KP drum set, it's quite easy.
First of all, you'll need to install *zip*, as it's not installed by default: `sudo apt install zip`.
Then, you can go to the following page: https://github.com/SpintroniK/exadrums-data/tree/TD-4KP and follow the instructions.

Obviously, the project is still under development and future versions will support more inputs, and have a lot of improvements.
The official documentation is far from being complete, but I'll make sure to add guidelines to help install the latest version of exadrums on a Raspberry Pi. I will make sure the future versions work on the current version of Raspberry Pi OS *bullseye*. Stay tuned, new versions are coming!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Future of exadrums]]></title>
            <link>https://news.exadrums.com/article/the-future-of-exadrums</link>
            <guid>https://news.exadrums.com/article/the-future-of-exadrums</guid>
            <pubDate>Wed, 25 Aug 2021 14:48:20 GMT</pubDate>
            <description><![CDATA[The future of exadrums is probably different than what you may think.
So far, exadrums is a two-part software, there's a library, libexadrums, and another component: the user interface. The whole drum module is in the library, and exposes a C++ API. That means libexadrums can be used with other languages, such as Python, Javascript, etc.]]></description>
            <content:encoded><![CDATA[
The future of exadrums is probably different than what you may think.

So far, exadrums is a two-part software, there's a library, libexadrums, and another component: the user interface. The whole drum module is in the library, and exposes a C++ API. That means libexadrums can be used with other languages, such as Python, Javascript, etc.

<!--more-->

A C++ user interface has its advantages, but exadrums could benefit from other languages. For instance,  a more "connected" experience would be easier to implement in Python or Javascript.

And that's how I see the future of exadrums: a Connected Open Source Drum Module. Some things are already in the works, but others will take some time. However, I'll do my best to publish news more frequently, to keep you informed about the project.

About that, the project website [exadrums.com](https://exadrums.com) will be online pretty soon! Hope you'll like it.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[New Arduino Nano Every Trigger Board - Part 4]]></title>
            <link>https://news.exadrums.com/article/new-arduino-nano-every-board-part4</link>
            <guid>https://news.exadrums.com/article/new-arduino-nano-every-board-part4</guid>
            <pubDate>Mon, 06 Jun 2022 19:48:22 GMT</pubDate>
            <description><![CDATA[This is a series of posts. If you haven't read the previous part here's a link to it: New Arduino Nano Every Trigger Board - Part 3.
In this part, we are going to read data from the Analog to Digital Converter (ADC) and make an oscilloscope.
It'll show us what the piezo voltage of drum pad looks like when hit with a drum stick.

To understand everything correctly, make sure you read the previous parts.]]></description>
            <content:encoded><![CDATA[
This is a series of posts. If you haven't read the previous part here's a link to it: [New Arduino Nano Every Trigger Board - Part 3](/article/new-arduino-nano-every-board-part3).

In this part, we are going to read data from the Analog to Digital Converter (ADC) and make an oscilloscope.
It'll show us what the piezo voltage of drum pad looks like when hit with a drum stick.

![signal](/images/new-arduino-nano-every-board/signal.png)

To understand everything correctly, make sure you read the previous parts.

<!--more-->

## How the ADC Works

This part is going to be a little bit more theoretical.
But we'll see a concrete example at the end.

### ADC Configuration

First of all, we need to talk about the ATMega4809's ADC configuration.
Without going into the very technical details, I'll talk about some of the important parameters of the ADC.
It needs a clock source, which can be obtained from the peripheral clock.
The way this clock signal is generated, is by dividing the CPU clock by a 'divider' that goes from 2 to 256.
Since the CPU clock is 16 MHz, that leaves with an ADC frequency that goes from 62.5 kHz to 8 MHz.
In practice, it is recommended to avoid low frequencies, and to not go above 1.5 MHz.
A normal conversion takes 13 ADC clock cycles, so the fastest conversion time we can get is 8.67 µs.
That is a bit over 115 kilo samples per seconds (ksps).

Another important parameter is the resolution of the ADC. Here we have two choices: 8-bit or 10-bit.
In the case of 8-bit sampling, we can store the data into a single byte.
However, 10-bit resolution will require 16-bit integers to store the results, which can lead to slower code.

There are different modes of operation. We are interested in the 'normal' mode, in which we ask the microcontroller to start a new conversion ourselves. There's also the free-running mode, in which the ADC starts a new conversion every time the previous one has finished.

### Events and Interrupts

There are two ways the microcontroller can communicate with peripherals:

- Interrupts: they let you execute a function automatically after an hardware event has occurred.
- Events: they allow peripherals to communicate with one another.

We are going to use both of them, the event will trigger a new conversion when a timer overflows, and the interrupt will be used to fetch the conversion result.

## Using the ADC in C++

First, let's see how to use the ADC in C++.
We define a few useful things: 

```cpp
static const auto Adc0Addr = reinterpret_cast<uint16_t>(&ADC0);

class Adc10bitType;
class Adc8bitType;

enum class Vref : uint8_t
{
    External,
    Internal, 
    Vdd,
};

enum class Prescaler : uint8_t
{
    Div2,
    Div4,
    Div8,
    Div16,
    Div32,
    Div64,
    Div128,
    Div256
};

template <typename T, typename Enable = void>
class AdcBase;

template <typename T>
class AdcBase<T, Util::enable_if_t<Util::is_same_v<T, Adc8bitType>>>
{
public:
    AdcBase() = delete;
    ~AdcBase() = delete;

protected:

    inline static uint8_t value{};

};


template <typename T>
class AdcBase<T, Util::enable_if_t<Util::is_same_v<T, Adc10bitType>>>
{
public:
    AdcBase() = delete;
    ~AdcBase() = delete;

protected:

    inline static uint16_t value{};

};
```

The ADC register's address is stored in `Adc0Addr`.
We've defined utilities for the ADC resolution, its voltage reference, and the frequency divider.

Notice the use of `enable_if`, which is defined as:

```cpp
namespace Util
{
    
    template <class T, T v>
    struct integral_constant 
    {
        static constexpr T value = v;
        using value_type = T;
        using type = integral_constant; // using injected-class-name
        constexpr operator value_type() const noexcept { return value; }
        constexpr value_type operator()() const noexcept { return value; } // since c++14
    };

    template <class T, class U>
    struct is_same : integral_constant<bool, false> {};
    
    template <class T>
    struct is_same<T, T> : integral_constant<bool, true> {};

    template<bool B, class T = void>
    struct enable_if {};
    
    template<class T>
    struct enable_if<true, T> { using type = T; };

    template< bool B, class T = void >
    using enable_if_t = typename enable_if<B,T>::type;

    template< class T, class U >
    inline constexpr bool is_same_v = is_same<T, U>::value;

} // namespace Util
```

This is usually part of the standard C++ library, but we don't have it, so these definitions help us achieve what we need: two different types for the 8-bit and 10-bit modes.
Alright, now we're done with the boilerplate, so let's get all the basic stuff out of the way:

```cpp
template <uint16_t addr, typename ValueType>
class Adc : private AdcBase<ValueType>
{

public:

    Adc() = delete;
    ~Adc() = delete;

    template <Prescaler div>
    static constexpr void SetPrescaler()
    {
        switch(div)
        {
            case Prescaler::Div2:   adc().CTRLC |= ADC_PRESC_DIV2_gc; break;
            case Prescaler::Div4:   adc().CTRLC |= ADC_PRESC_DIV4_gc; break;
            case Prescaler::Div8:   adc().CTRLC |= ADC_PRESC_DIV8_gc; break;
            case Prescaler::Div16:  adc().CTRLC |= ADC_PRESC_DIV16_gc; break;
            case Prescaler::Div32:  adc().CTRLC |= ADC_PRESC_DIV32_gc; break;
            case Prescaler::Div64:  adc().CTRLC |= ADC_PRESC_DIV64_gc; break;
            case Prescaler::Div128: adc().CTRLC |= ADC_PRESC_DIV128_gc; break;
            case Prescaler::Div256: adc().CTRLC |= ADC_PRESC_DIV256_gc; break;
        }
    }

    template <Vref vref>
    static constexpr void SetReference()
    {
        switch(vref)
        {
            case Vref::External: adc().CTRLC |= ADC_REFSEL_VREFA_gc; break;
            case Vref::Internal: adc().CTRLC |= ADC_REFSEL_INTREF_gc; break;
            case Vref::Vdd: adc().CTRLC |= ADC_REFSEL_VDDREF_gc; break;
        }
    }

    static constexpr void SelectChannel(ADC_MUXPOS_t chan)
    {
        channel = chan;
        adc().MUXPOS = channel;
    }

    static constexpr void Enable()
    {
        if constexpr(Util::is_same_v<ValueType, Adc8bitType>)
        {
            adc().CTRLA = ADC_ENABLE_bm | ADC_RESSEL_8BIT_gc;
        }
        
        if constexpr(Util::is_same_v<ValueType, Adc10bitType>)
        {
            adc().CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc;
        }
    }

    static constexpr void StartConversion()
    {
        adc().COMMAND = ADC_STCONV_bm;
    }


    static constexpr bool ConversionDone()
    {
        return adc().INTFLAGS & ADC_RESRDY_bm;
    }

    static constexpr auto GetValue()
    {
        return Adc<addr, ValueType>::value;
    }


private:

    static constexpr auto& adc()
    {
        return *reinterpret_cast<ADC_t*>(addr);
    }

    inline static ValueType value = 0;
    inline static ADC_MUXPOS_t channel = ADC_MUXPOS_t::ADC_MUXPOS_AIN0_gc;

};
```

Here are the things we can do with this code:

- Set the ADC clock frequency by changing the clock divider (or prescaler) using `SetPrescaler()`.
- Set the voltage reference (we'll use an external reference here) using `SetReference()`.
- Select the input channel (from 0 to 7), using `SelectChannel(ADC_MUXPOS_t chan)`.
- Of course, we can enable the ADC, start a conversion, and check if the conversion is done.

With all that we can write an infinite loop, start a conversion, do some things, wait until the conversion is done (in a loop), read the result and use the value as we see fit.
But that wouldn't correspond to what we really need.
What we do need is to trigger conversions at a regular interval so that we know exactly how much time has elapsed since the previous value was retrieved from the ADC.

## Using a Timer to Trigger the ADC at Regular Intervals

We are not going to go into much details about setting up the timer.
However, we are going to focus on the event system that allows to trigger the ADC when the timer overflows.

### Timer Configuration

We are going to use the TCA timer.
It will be configured as follows:

```cpp
// Configure TCA
Tca::SetSingleMode<Timing::TCASingleMode::Normal>();
Tca::DisableEventCounting();
Tca::SetPeriod(13);             // 14 µs

Tca::SetClockDivider<Timing::TCAClockDiv::Div16>();
Tca::Enable();
```

The complete code will be on [GitHub](https://github.com/SpintroniK/exadrumino-Nano-Every) soon.
I believe the code speaks for itself: the timer will overflow every 14 µs.
It will count up to 13 (including 0), at a frequency of 1 MHz (CPU clock divided by 16).

### Event System

Let's see how we can trigger an ADC conversion automatically when the timer overflows.
To that end, we are going to use the ATMega4809's event system.
The event system has 8 channels that allows peripherals to communicate with each other.
Each channel can be used to connect a peripheral to another one, or itself.
We are interested in the overflow event of the TCA timer and the ADC conversion start event.

But first let's use a little helper that'll make our life easier and the code more readable: 

```cpp
#include <avr/io.h>

#include <stdint.h>

inline constexpr uint8_t EVSYS_GENERATOR_TCA0_OVF_gc = 0x80 << 0; // Should already be defined, but it's not...

namespace Event
{

    using Generator = uint8_t;
    using Event = register8_t;


    class EventSystem
    {
        
    public:
        EventSystem() = delete;
        ~EventSystem() = delete;

        template <uint8_t channel>
        static constexpr void Connect(Generator in, Event& out)
        {
            switch(channel)
            {
                case 0:
                {
                    EVSYS.CHANNEL0 = in;
                    out = EVSYS_CHANNEL_CHANNEL0_gc;
                    break;
                }

                case 1:
                {
                    EVSYS.CHANNEL1 = in;
                    out = EVSYS_CHANNEL_CHANNEL1_gc;
                    break;
                }

                default: static_assert(channel <= 7, ""); break;
            }
        }

    private:

    };
    
} // namespace Event
```

I've only implemented the code for channel 0 and channel 1. Other channels can be added by filling the switch-case statement.
And that's how we 'connect' the TCA's overflow to the ADC's start conversion event:

```cpp
Event::EventSystem::Connect<0>(EVSYS_GENERATOR_TCA0_OVF_gc, EVSYS.USERADC0);
```

## ADC Events and Interrupts

A few things are missing in our ADC class.
We need to be able to enable events and interrupts, so we can add the following member functions:

```cpp
static constexpr void EnableInterrupts()
{
    adc().INTCTRL |= ADC_RESRDY_bm;
}

static constexpr void EnableEvents()
{
    adc().EVCTRL |= ADC_STARTEI_bm;
}
```

That's it for the event's configuration, but what about the interrupt?
An interrupt is triggered by the hardware, but it needs to be handled on the software side.
More precisely, we need to define a function that is going to be called when an interrupt is fired.
It is kind of a callback function that takes no arguments and returns nothing.

I'm not going to go into the gory details of gcc, but because of a bug in the compiler, with have to define a new class with a static function that handles the interrupt:

```cpp
class AdcInterrupts
{
public:

    AdcInterrupts() = delete;
    ~AdcInterrupts() = delete;

private:

    static void ResReady() __asm__("__vector_22") __attribute__((__signal__, __used__, __externally_visible__));
};
```

We can handle some other ADC interrupts in the same class if we need to.
But how do we know that we need to use the vector 22?
Again without going into a lot of details, the answer is in the `iom4809.h` header, where we can find:

```cpp
/* ADC0 interrupt vectors */
#define ADC0_RESRDY_vect_num  22
#define ADC0_RESRDY_vect      _VECTOR(22)  /*  */
#define ADC0_WCOMP_vect_num  23
#define ADC0_WCOMP_vect      _VECTOR(23)  /*  */
```

## Putting it All Together

Okay, now we have almost everything we need, so it's time to write our main function.
But before that, we need to define the body of our ADC interrupt in a `.cpp` file.
Let's put it in our `main.cpp` file then:

```cpp

using Adc0 = Adc<Adc0Addr, Adc8bitType>;

void Analog::AdcInterrupts::ResReady()
{
    Adc0::ResetInterrupt();
    // Do somehing with the ADC value ADC0.RES here
}
```

What we do with the resulting value is up to us, as long as our computations finish before the timer overflows again.

Now to our main function.

```cpp
int main()
{

    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler

    sei();

    Event::EventSystem::Connect<0>(EVSYS_GENERATOR_TCA0_OVF_gc, EVSYS.USERADC0);

    // Configure ADC
    Adc0::EnableInterrupts();
    Adc0::EnableEvents();
    Adc0::SelectChannel(ADC_MUXPOS_AIN0_gc);
    Adc0::SetPrescaler<Analog::Prescaler::Div8>();
    Adc0::SetReference<Analog::Vref::External>();
    Adc0::Enable();

    // Configure TCA
    Tca::SetSingleMode<Timing::TCASingleMode::Normal>();
    Tca::DisableEventCounting();
    Tca::SetPeriod(13);             // 14 µs
    
    Tca::SetClockDivider<Timing::TCAClockDiv::Div16>();
    Tca::Enable();



    for(;;)
    {
    }

    return 0;
}
```

First of all, we disable the CPU clock prescaler.
Then, we enable interrupts, and we connect the TCA overflow event to the ADC start conversion event.
We configure the ADC and the TCA.
And finally, we write an infinite loop.
Our ADC is sampling `AIN0` but, so far, we're not doing anything with the result.

## Arduino Nano Every Oscilloscope

In this last section, we are going to use everything that has been presented above, plus the previous part of this series of articles.
So if you haven't read the [previous part](/article/new-arduino-nano-every-board-part3), I encourage you to do so.

### Retrieve the ADC Value

We are going to need a variable to store the ADC value.
As this variable will be accessed by both the ADC interrupt and our main function, we ought to declare it as a global variable.

```cpp

using Adc0 = Adc<Adc0Addr, Adc8bitType>;

static uint8_t adcValue{};

void Analog::AdcInterrupts::ResReady()
{
    Adc0::ResetInterrupt();
    adcValue = ADC0.RES;
}
```

### Send ADC Values Over the USART

We're going to use the USART code that we wrote in the previous part of this series.
The last thing we need to do is to is be able to send strings over the USART.
In the previous part, we wrote a function that allowed us to send a single byte.
A string is an array of characters, and every character can be represented as a single byte.
All we need is to format the string and send the bytes it is made of.
Using `string.h` this isn't too hard to achieve.

```cpp
#include "Adc.hpp"
#include "Usart.hpp"

#include <avr/io.h>
#include <avr/interrupt.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


using Adc0 = Adc<Adc0Addr, Adc8bitType>;
using Tca = TCA<TCASingle>;

static uint8_t adcValue{};

static DigitalIO::Usart<3> usart{115'200};

void Analog::AdcInterrupts::ResReady()
{
    Adc0::ResetInterrupt();
    adcValue = ADC0.RES;
}

int main()
{

    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00); // Disable prescaler

    sei();

    Event::EventSystem::Connect<0>(EVSYS_GENERATOR_TCA0_OVF_gc, EVSYS.USERADC0);

    // Configure ADC
    Adc0::EnableInterrupts();
    Adc0::EnableEvents();
    Adc0::SelectChannel(ADC_MUXPOS_AIN2_gc);
    Adc0::SetPrescaler<Analog::Prescaler::Div8>();
    Adc0::SetReference<Analog::Vref::External>();
    Adc0::Enable();

    // Configure TCA
    Tca::SetSingleMode<Timing::TCASingleMode::Normal>();
    Tca::DisableEventCounting();
    Tca::SetPeriod(13);             // 14 µs
    
    Tca::SetClockDivider<Timing::TCAClockDiv::Div16>();
    Tca::Enable();

    for(;;)
    {
        // brain.SendMidiNotes();
        static char str[32];
        ::sprintf(str, "%d\n", adcValue);

        for(uint8_t i = 0; i < ::strlen(str); ++i)
        {
            usart.SendByte(str[i]);
        }
    }

    return EXIT_SUCCESS;
}
```

And here we are, we have an Arduino Nano Every oscilloscope.
You can use the [new exadrums Arduino Nano Every board](/article/new-arduino-nano-every-board-part3) to connect your e-drums to and have look at a piezo signal in real time, for instance the snare drum.

![arduino-board](/images/new-arduino-nano-every-board/board-arduino.png)

Then, you can launch the Arduino IDE, and hit Ctrl + Shift + L.
You'll see something like that if you play flams, for instance:

![oscilloscope](/images/new-arduino-nano-every-board/oscilloscope.png)

You'll notice that we are getting one new sample every 14 µs, but sending data at a baudrate of 115200 bps, which corresponds to about 5000 values per second in average.
We are getting samples way to fast, but that's not really a problem since this is just a step towards our goal: making a drum module.
So getting one sample every 14 µs means we can aim for 8928 samples per second and per piezo if we use 8 piezos.

## What's Next?

Next time I'll share the code, as it is now usable and I've tested it with my Roland TD17 e-drum.
Stay tuned!
]]></content:encoded>
        </item>
    </channel>
</rss>